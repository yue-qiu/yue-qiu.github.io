<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
<meta property="og:type" content="website">
<meta property="og:title" content="精神的壳">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="精神的壳">
<meta property="og:description" content="高山仰止，景行行止。虽不能至，心向往之。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="精神的壳">
<meta name="twitter:description" content="高山仰止，景行行止。虽不能至，心向往之。">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>精神的壳</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">精神的壳</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/调度器—Go语言的大管家/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/调度器—Go语言的大管家/" class="post-title-link" itemprop="url">调度器—Go语言的大管家</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-27 16:41:26" itemprop="dateCreated datePublished" datetime="2020-04-27T16:41:26+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-28 21:05:22" itemprop="dateModified" datetime="2020-04-28T21:05:22+08:00">2020-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源，每一次线程上下文的切换都需要消耗 1us 左右的时间。而 Go 调度器对 Goroutine 的上下文切换约为 0.2us，减少了 80% 的额外开销</p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>调度器的三个组成部分：G(Goroutine)，P(处理器)，M(线程)</p>
<ul>
<li>G：代表 Goroutine，是一个待执行的任务</li>
<li>P：代表处理器，相当于一个与线程绑定的小型调度器</li>
<li>M：代表操作系统线程</li>
</ul>
<p><img src="https://i.loli.net/2020/04/26/F617HYhRtfTrJlM.png" alt="GMP模型"></p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>Gorotuine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 表现为私有结构体 g，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack stack <span class="comment">// 栈内存范围</span></span><br><span class="line">    preempt <span class="keyword">bool</span> <span class="comment">// 抢占信号</span></span><br><span class="line">    _panic *_panic <span class="comment">// 存储 panic 结构体的链表</span></span><br><span class="line">    _defer *_defer <span class="comment">// 存储 defer 结构体的链表</span></span><br><span class="line">    m *m <span class="comment">// 当前占用线程</span></span><br><span class="line">    sched gobuf <span class="comment">// 与 Goroutine 调度相关的数据</span></span><br><span class="line">    atomicstatus <span class="keyword">uint32</span> <span class="comment">// Goroutine 的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sched</code> 字段对 Goroutine 的调度至关重要：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">    pc <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">    g guintptr <span class="comment">// 持有这个 gobuf 的 Goroutine</span></span><br><span class="line">    ret sys.Uintreg <span class="comment">// 系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine 的状态可分为三类：等待中、可运行、运行中</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态</li>
<li>运行时：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code></li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code></li>
</ul>
<p><img src="https://i.loli.net/2020/04/26/HYZyCRmugW4XA8K.png" alt="Goroutine状态"></p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，这样不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。我们也可以使用 runtime.GOMAXPROCS 来改变程序中最大的线程数。</p>
<p><img src="https://i.loli.net/2020/04/26/ihSrwOGqjRa3mCo.png" alt="M与CPU"></p>
<p>线程表现为私有结构体 m，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0 *g <span class="comment">// 持有调度栈的 goroutine，深度参与 goroutine 的创建过程</span></span><br><span class="line">    curg *g <span class="comment">// 当前线程持有的 goroutine</span></span><br><span class="line">    p puintptr <span class="comment">// 正在运行的调度器</span></span><br><span class="line">    nextp puintptr <span class="comment">// 备用调度器</span></span><br><span class="line">    oldp puintptr <span class="comment">// 之前使用的调度器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。</p>
<p>调度器在启动时就会创建 GOMAXPROCS 个处理器，即处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行 Goroutine。</p>
<p>处理器表现为私有结构体 p，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    status <span class="keyword">uint32</span> <span class="comment">// 处理器状态</span></span><br><span class="line">    m muintptr <span class="comment">// 当前绑定的线程</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span> <span class="comment">// 等待队列队头</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span> <span class="comment">// 等待队列队尾</span></span><br><span class="line">    runq [<span class="number">256</span>]guintptr <span class="comment">// 等待队列</span></span><br><span class="line">    runnext guintptr <span class="comment">// 下一个需要执行的 goroutine</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/26/TaxLscAnwlDZq7m.png" alt="GMP三者关系"></p>
<h2 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h2><p><code>go</code> 关键字会被转换为 <code>runtime.newproc</code>，该函数会接收大小和表示函数的指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runtime.newproc1</code> 根据入参初始化一个 <code>g</code>，该函数的行为可分为：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体：从处理器的 <code>gFree</code> 列表得到一个空闲的 g。如果获取失败则创建一个新的 g</li>
<li>将传入的参数移到 Goroutine 的栈上：将 fn 的参数全部压栈</li>
<li>更新 Goroutine 调度相关的属性：设置新 g 的 sp、pc并更新其状态到 <code>_Grunnable</code></li>
<li>将 Goroutine 加入运行队列 runq：Go 语言中有两个运行队列，一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列<br><img src="https://i.loli.net/2020/04/27/1bVMsIOvXk3Dlx7.png" alt="运行队列"></li>
</ol>
<h2 id="触发调度"><a href="#触发调度" class="headerlink" title="触发调度"></a>触发调度</h2><h3 id="主动挂起"><a href="#主动挂起" class="headerlink" title="主动挂起"></a>主动挂起</h3><p>当 goroutine 陷入休眠（如 <code>time.sleep</code>）或阻塞在一次 chan 操作时，goroutine 触发主动挂起。主动挂起会将当前 goroutine 暂停。调度器把 goroutine 状态设为 <code>_Gwaiting</code> 并<strong>解除 goroutine 与线程的绑定</strong>（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程。</p>
<p>当 goroutine 满足特定条件后，运行时将因主动挂起而休眠的 goroutine 唤醒并将其状态设为 <code>_Grunnable</code>，随后这个 goroutine 被放到运行队列等待调度。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并<strong>解除线程和处理器的绑定</strong>（相当于让出处理器，这样处理器就可以绑定到其它线程上。原线程陷入系统调用等待返回。这个过程触发一次线程切换的系统调用）。</p>
<p>系统调用结束后，为这个 goroutine 重新分配资源并更新其状态为 <code>_Grunnable</code>，找到一个可用的处理器与这个 goroutine 绑定。</p>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>运行时会更新 Goroutine 的状态到 <code>_Grunnable</code>，让出当前的处理器并将这个 Goroutine 放回全局队列。最后，调用 runtime.schedule 触发调度。</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>总结起来三个特点：多线程、任务窃取、抢占式：</p>
<ol>
<li>多线程：进程中可以同时存在多个活跃线程。多线程调度器引入了 GOMAXPROCS 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数</li>
<li>任务窃取：进行 goroutine 调度时，调度器会先从当前处理器或全局待运行队列中获得一个 goroutine；如果获取失败，则从其它处理器的待运行队列中随机获取 goroutine</li>
<li>抢占式：STW 和栈扫描时会触发抢占。当前 goroutine 被设为 _Gpreempted，调度器进行一次 goroutine 调度</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/17/网络IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/17/网络IO/" class="post-title-link" itemprop="url">网络IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 23:17:38" itemprop="dateCreated datePublished" datetime="2020-04-17T23:17:38+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-24 00:50:41" itemprop="dateModified" datetime="2020-04-24T00:50:41+08:00">2020-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h1><p>计算机之间可以通信，本质上也是计算机进程相互通信。为了方便不同终端进行通信，网络协议栈抽象出socket层，通过对socket文件描述符的操作来进行网络IO。当然，不同的应用场景，衍生出了不同的网络模型</p>
<h2 id="一次网络响应"><a href="#一次网络响应" class="headerlink" title="一次网络响应"></a>一次网络响应</h2><p>互联网应用中，多数架构是 CS 模式，即 client 发出请求，server 接受请求，处理之后返回响应。这样的一次交互，伴随着 client 和 server 的 IO 操作。</p>
<p>一次简单的交互，往往涉及网络 IO 和磁盘文件 IO。大致流程如图：</p>
<p><img src="https://i.loli.net/2020/04/17/jMxUNO7ltuwgRTX.png" alt="一次IO"></p>
<p>对 Server 而言，处理响应的过程如下：</p>
<ol>
<li>Server 的进程发起 Read 系统调用，内核随即从硬件 Disk 读取数据到内核缓冲区（kernel buf）</li>
<li>内核把 kernel buf 的数据 copy 到应用程序进程的缓冲区，应用程序就可以对数据进行修改。</li>
<li>应用进程将数据通过系统调用 Send 发送到 socket 缓冲区，每个 socket 文件都在内核维护了一个发送/接受缓冲区。</li>
<li>最后再把 socket 发送缓冲区的数据 copy 到 NIC 网卡中，通过协议栈发送到Client 的网卡。</li>
</ol>
<p>所谓的IO，就是将硬件（磁盘、网卡）的数据读取到程序的内存中。</p>
<p>因为应用程序很少可以直接和硬件交互，因此操作系统作为两者的桥梁。通常操作系统在对接两端（应用程序与硬件）时，自身有一个内核 buf，用于数据的 copy 中转。</p>
<p><img src="https://i.loli.net/2020/04/17/lJoTNEzbcdejuFt.png" alt="硬件、内核、应用"></p>
<p>一般网络 IO 分为两个阶段：</p>
<ol>
<li>等待数据阶段。数据通过协议栈发送到网卡，网卡再通过 DMA copy 到 kernel buf</li>
<li>拷贝数据阶段。将 kernel buf 的数据 copy 到 app buf 中。</li>
</ol>
<h2 id="Linux-5-种-IO-模型"><a href="#Linux-5-种-IO-模型" class="headerlink" title="Linux 5 种 IO 模型"></a>Linux 5 种 IO 模型</h2><h3 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h3><p>所谓阻塞 IO 指在网络 IO 的两个阶段进程都会阻塞。</p>
<p><img src="https://i.loli.net/2020/04/17/WoMVpI9X72KzcGN.png" alt="阻塞IO"></p>
<p>进程对象发起 Recv 操作，这是一个系统调用，然后内核会看 kernel buf 是否有数据，如果没有数据，那么进程将会被挂起，直到 kernek buf 从硬件或者网络读取到数据之后，内核再把数据从 kernel buf copy 到 app buf中，然后唤醒发起调用的进程，并且 Recv 操作将会返回数据。接下来进行可以对进程 buf 的数据进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sock.accept() <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">    print(<span class="string">'client &#123;&#125; connect'</span>.format(conn.fileno()))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>) <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'client &#123;&#125; closed'</span>.format(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'data is '</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p>进程在阻塞 IO 中，发起了 IO 调用之后随即被挂起，不能做别的。在 非阻塞 IO 中，如果没有数据，那么发起的系统调用会马上返回一个 <code>EWOULDBLOCK</code> 错误。函数返回之后，进程没有被挂起，可以继续做别的。</p>
<p><img src="https://i.loli.net/2020/04/17/6yAJMt5CG4dRj2Z.png" alt="非阻塞IO"></p>
<p>进程发起了非阻塞 IO 请求，获得了 EWOULDBLOCK 之后，会再次发起非阻塞 IO 请求，这个过程还是会使用 CPU，因此也称之为轮询（polling）。</p>
<p>当内核有数据的时候，内核将 kernel buf 的数据 copy 到 app buf的过程还是需要 cpu 参与，这个过程对于非阻塞 IO 来说，线程仍然是阻塞的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 获得 EWOULDBLOCK 错误，轮询</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'client &#123;&#125; connect'</span>.format(conn.fileno()))</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 轮询</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'client &#123;&#125; closed'</span>.format(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'data is '</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<h3 id="多路复用-IO"><a href="#多路复用-IO" class="headerlink" title="多路复用 IO"></a>多路复用 IO</h3><p>阻塞 IO 会让线程挂起。非阻塞 IO 需要一直做 polling，每一次 polling 都会做系统调用，某种程度下，非阻塞 IO 的性能将还不如阻塞 IO。既然需要内核频繁操作，那么就有人想出了新的模型：让内核代理去做轮询，然后应用进程只有数据准备了再发起 IO 操作不就好了吗？的确，多路复用IO就是这样的原理。由内核负责监控应用指定的 socket 文件描述符，当 socket 准备好数据（可读，可写，异常）的时候，通知应用进程。准备好数据是一个事件，当事件发生的时候，通知应用进程，而应用进程可以根据事件事先注册回调函数。</p>
<p>进程发起了 select 或 poll 或者 epoll 调用之后，可以设置阻塞进程。当内核数据准备好的时候通知应用进程，即事件发生。应用进程注册了回调函数，这里是 Recv。因此进程可以再次发起 Recv 系统调用，而且此时 Recv 一定会得到数据。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 系统调用提供一个机制来实现同步 IO：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line">FD_ZERO(fd_set *<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure>
<p>调用 select 将导致阻塞，直到指定的文件描述符准备好执行 IO，或者可选参数 timeout 指定的时间已经过去。</p>
<p>select 成功返回时，返回值是 ready 状态的 fd 数目。每组 set 都被修改以使它只包含准备好 IO 的文件描述符。例如，假设有两个文件描述符，值分别是 7 和 9，被放在 readfds 中。当 select 返回时，如果 7 仍然在 readfds 中，则这个文件描述符已经准备好被读取而不会阻塞。如果 9 已经不在 readfds 中，则读取它将可能会阻塞（”可能”是因为数据或许正好在 select 返回后就可用，这种情况下，下一次调用 select 将返回文件描述符准备好读取）。</p>
<p><strong>因为 fd_set 是静态创建的，它们对 fd 的最大数目强加了一个限制，能够放进 set 中的 fd 的数量由在 32 位机默认是 1024，64位机默认是2048。</strong></p>
<p>缺点：</p>
<ol>
<li>单进程可以打开 fd 有限制；</li>
<li>对得到的 fd_set 进行线性扫描，即采用轮询的方法，效率较低；</li>
<li>包含大量 fd 的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，也需要反复在用户态和内核态之间复制结构体，但是 poll 采用链表的方式替换原有 fd_set，使其<strong>没有连接数的限制</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>pollfd 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;         <span class="comment">/* 文件描述符 */</span></span><br><span class="line">short events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">short revents;       <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个 pollfd 指定一个被监视的 fd。可以传递一个 pollfd 数组指示 poll 监视多个 fd。每个结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域。revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有几百上千个 TCP 连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般只能处理几千的并发连接。</p>
<p>epoll 是是之前的 select/poll 的增强版本。相比 select/poll，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>
<p>epoll 提供三个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll的事件注册函数，注册要监听的事件类型。</span></span><br><span class="line"><span class="comment">第一个参数是 epoll_create()的返回值；</span></span><br><span class="line"><span class="comment">第二个参数表示动作，用三个宏来表示：EPOLL_CTL_ADD，EPOLL_CTL_MOD，EPOLL_CTL_DEL；</span></span><br><span class="line"><span class="comment">第三个参数是需要监听的 fd；</span></span><br><span class="line"><span class="comment">第四个参数是告诉内核需要监听什么事 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一步：epoll_create 系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p>
<p>第二步：epoll_ctl 系统调用。通过此调用向 epoll 对象中添加、删除、修改感兴趣的事件，返回 0 表示成功，返回 -1 表示失败。</p>
<p>第三部：epoll_wait 系统调用。通过此调用收集收集在 epoll 监控中已经发生的事件。</p>
<p><strong>下面来看看 epoll 是怎么实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每次调用 epoll_create 方法，内核创建一个 eventpoll 结构体，用于存放通过 epoll_ctl 方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来。</p>
<p>所有添加到 epoll 中的事件都会与设备(网卡等)建立回调关系。也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫 ep_poll_callback，它会将发生的事件添加到 rdlist 双链表中。</p>
<p>每一个事件都会创建一个对应的 epitem 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 epoll_wait 检查是否有事件发生时，只需要检查 eventpoll 对象中的 rdlist 双链表中是否有 epitem 元素即可。如果 rdlist 不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户:</p>
<p><img src="https://i.loli.net/2020/04/24/ZVMg1j5dHoRU6Bf.png" alt="Epoll实现"></p>
<p>优点：</p>
<ol>
<li>支持一个进程持有大数目的 fd。epoll 底层用红黑树管理 fd，所支持的 fd 上限是最大可以打开文件的数目。</li>
<li>IO 效率不随 fd 数目增加而线性下降。举个例子：传统的 select/poll 另一个致命弱点就是当你拥有一个很大的 socket 集合，任一时间只有部分 socket 处于 ready 状态。但是 select/poll 每次调用返回后都要线性扫描全部的 socket、检查所有 socket 的状态，导致效率呈现线性下降。epoll 不存在这个问题，它只会对 ready socket 进行操作。这是因为在内核实现中 epoll 是根据每个 fd 上面的 callback 函数实现的。那么，只有 ready socket 才会主动的去调用 callback 函数，idle socket 则不会。</li>
<li>epoll 对每个 fd 只会进行一次用户态到内核态的复制。</li>
</ol>
<h2 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h2><ul>
<li>水平触发（Level Triggered, LT）：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知。LT 同时支持阻塞 IO 与非阻塞 IO。在这种模式下，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。<strong>传统的 select/poll 都是采用这种模式，epoll 默认也是这种模式</strong>。</li>
<li>边缘触发（Edge Triggered, ET）：当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知。事件通知仅在被监听文件描述符的缓冲区状态在满/不满之间变化的时候才会发生一次。边缘触发需要一次性的把缓冲区的数据读完，也就是一直读直到读到 EGAIN （缓冲区为空）为止，否则在这个 fd 的内核缓冲区下一次处于满状态前无法再次获得它。因为这一点，边缘触发需要设置文件句柄为非阻塞。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平触发</span></span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘触发</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>对于监听的sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上</li>
<li>对于读写的connfd，水平触发模式下，阻塞和非阻塞效果都一样</li>
<li>对于读写的connfd，边缘触发模式下，必须使用非阻塞IO，并要一次性全部读写完数据</li>
</ol>
<h2 id="信号-IO"><a href="#信号-IO" class="headerlink" title="信号 IO"></a>信号 IO</h2><p>让内核在描述符就绪时发送 SIGIO 信号通知进程。这种模型为信号驱动式 IO（signal-driven IO），和事件驱动类似，也是一种回调方式。与非阻塞方式不一样的地方是，发起了信号驱动的系统调用，进程没有挂起，可以做的事情，可是实际中，代码逻辑通常还是主循环，主循环里可能还是会阻塞。因此使用这样的 IO 的软件很少。</p>
<p>当信号返回可以读写的时候，因为还需要 cpu 将内核数据 copy 到 app buf，拷贝数据阶段毫无疑问还是阻塞的。</p>
<p><img src="https://i.loli.net/2020/04/17/73r6sTCnzG45HFN.png" alt="信号IO"></p>
<h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><p>异步是指应用与内核存在 CPU 竞争（在同步 IO 中应用都是等 kernel buf 中的数据拷贝到 app buf 后再执行的）。</p>
<p><img src="https://i.loli.net/2020/04/17/lYpgvAdNwyQuCr9.png" alt="异步IO"></p>
<p>无论是第一阶段数据准备还是第二阶段数据拷贝，发起系统调用的进程都不会被阻塞。第二阶段过程中，进程没有阻塞，那么可以抢占 CPU，而 kernel buf copy 数据到 app buf 的时候，也需要 CPU，这就造成了应用和内核进行 CPU 竞争，步调不一致了。某些情况下，其性能反而不如其他 IO 模式。使用的人也很少。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IO 即数据在 app buf、kernel buf、硬件三者之间的流动。</p>
<p>数据等待阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>阻塞：进程挂起</li>
<li>非阻塞：进程不挂起，立即返回，返回EWOULDBLOCK</li>
</ul>
<p>数据拷贝阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>同步：内核拷贝数据占用 CPU</li>
<li>异步：进程可能和内核竞争 CPU</li>
</ul>
<p>同步非阻塞就是十分常见的多路复用结合非阻塞IO实现的方案，也称之为事件驱动。同步有利于逻辑的书写，非阻塞有利于调用率实现并发。因此现实中更多的IO模型是多路复用IO，并且在发展过程中，select，poll和epoll是逐步进化链。epoll实现了内核级数据结构优化，在实际性能上又了很大的提升。</p>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/e62f0ef9629d" target="_blank" rel="noopener">简明网络IO</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结</a></p>
<p><a href="https://blog.csdn.net/cuiyifang/article/details/7957937" target="_blank" rel="noopener">epoll简介及例子</a></p>
<p><a href="https://blog.csdn.net/u011063112/article/details/81771440" target="_blank" rel="noopener">epoll详解</a></p>
<p><a href="https://www.cnblogs.com/yorkyang/p/7688865.html" target="_blank" rel="noopener">epoll的水平触发与边缘触发</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/并发编程-以Go为例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/24/并发编程-以Go为例/" class="post-title-link" itemprop="url">并发编程-以 Go 为例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-24 23:49:51" itemprop="dateCreated datePublished" datetime="2020-03-24T23:49:51+08:00">2020-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 00:10:20" itemprop="dateModified" datetime="2020-04-14T00:10:20+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>所谓<code>并发</code>(concurrency) 是指几段程序在同一时间段内交错执行，当我们无法肯定一个事件一定会会先于另一个事件发生，那么就可以说这几个时间是“并发”的。如果一个函数在并发调用时仍能正确执行，这个函数就是<code>并发安全</code>的；如果一个类型的所有可访问方法和操作都是并发安全的，则它就是一个并发安全的类型。</p>
<p>本文主要介绍了几种并发编程中常见的问题及对策，所有的例子都会用 Go 语言来描述，还会涉及到一些 Go 对并发编程的支持。</p>
<h1 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h1><p>竞态是指多个 goroutine 并发执行时，程序无法给出正确结果。比如多个 goroutine 同时修改了一个包级别变量的值，那么很可能导致某一个 goroutine 的修改对另一个 goroutine 不可见：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">100</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">200</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码执行以后，balance 有几种可能取值：300，200，100。程序中的这种状态称为<code>数据竞态</code>，是竞态的一种。数据竞态发生在多个 goroutine 并发读写同一个变量并且至少一个为写操作的时候。</p>
<p>有三种方法可以避免数据竞态：</p>
<ol>
<li>不对变量做写操作。如果没有 goroutine 对变量的值进行修改，那么数据竞态自然无从说起。</li>
<li>避免多个 goroutine 对一个变量进行访问。简言之就是这个变量的所有操作都在一个<code>监控 goroutine</code> 内执行，由于一个 goroutine 内的结果是<code>串行一致</code>的，也就不会产生修改不可见的问题。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接写 amount</span></span><br><span class="line"><span class="keyword">var</span> balance = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接读 amount</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> monitor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">0</span> <span class="comment">// amount 被限制在 monitor goroutine 中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> count := &lt;- deposit:</span><br><span class="line">                amount += count</span><br><span class="line">            <span class="keyword">case</span> balance &lt;- amount:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    deposit &lt;- count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;- balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使一个变量无法被完全限制在一个 goroutine 内，也可以把对这个变量的操作划分为好几个阶段，只要每个阶段被限制在一个 goroutine 内访问就可以了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(origin <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    book = <span class="built_in">new</span>(Book)</span><br><span class="line">    book.content = <span class="string">"hello world"</span></span><br><span class="line">    origin &lt;- book</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revise</span><span class="params">(origin &lt;- <span class="keyword">chan</span> *Book, corrected <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> book := <span class="keyword">range</span> origin &#123;</span><br><span class="line">        book.content += <span class="string">"!"</span></span><br><span class="line">        corrected &lt;- book</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在一个时刻只允许一个 goroutine 操作这个变量。这种方法称为<code>互斥机制</code>。我们可以使用带一个缓冲的通道来实现：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取信号量</span></span><br><span class="line">    amount += count</span><br><span class="line">    &lt;- sema <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这是一个非常简陋的实现。Go 已经为我们造好了完备的轮子：sync.Mutex。有了互斥锁，代码就可以写成这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，sync.Mutex 是“不可再入”的。</p>
<p>当读操作远多于写操作时，互斥锁会明显拖累系统的速度（最严重时只有单个 goroutine 会被执行）。读写锁 sync.RWMutex 特别适合这种场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    rwmu sync.RWMutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rwmu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    rwmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rwmu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwmu.UnRlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写锁支持四种操作：获得写锁 Lock()，释放写锁 UnLock()，获得读锁 RLock()，释放读锁 UnRLock()。</p>
<p>写锁又称为<code>排它锁（X锁）</code>：若事务 T 对数据 A 加上 X 锁，T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>读锁又称为<code>共享锁（S锁）</code>：若事务 T 对 数据 A 加上 S 锁，则 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对A做任何修改。</p>
<p>写锁最多有一个，而读锁可以有多个。一个 goroutine 获得写锁后，直到这个写锁被释放前，其它 goroutine 不可以获得读锁或者写锁；一个 goroutine 获得读锁后，其它 goroutine 可以获得读锁，但是不能获得写锁。</p>
<p>如果写锁和读锁是平级的，假设当前已经上了读锁，此时一个 goroutine 的 Lock() 操作会被阻塞。而如果不断有 goroutine 获得读锁那么 Lock() 操作就会一直阻塞下去。因此，<code>写锁的优先级高于读锁</code>，即当获得写锁的请求产生以后，直到 Lock() 执行成功前所有 RLock() 操作都会阻塞。</p>
<p>对读操作上读锁，避免读到脏数据的同时又提高了资源访问速度！</p>
<p>要注意的是，go 的读写锁是通过互斥锁加上引用计数器实现的，所以除非读操作确实远远比写操作多，否则读写锁未必就比互斥锁效率高。</p>
<h1 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h1><p>即使是一个只包含单个操作的只读操作，上锁也是必要的。一是为了防止这个操作被插入到对该变量的写入操作中，二是将处理器缓存中的内容刷入内存。</p>
<p>现代计算机一般会有多个处理器，每个处理器都有自己的缓存。对变量的写操作通常不会直接写入内存，而是先记录在处理器缓存中，在操作系统认为必要的时候再刷回内存。而通道通信和互斥锁这样的<code>同步原语</code>都会强制刷回内存，如此一来在这之前的 goroutine 的执行结果就对当前 goroutine 可见了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        fmt.Print(<span class="string">"y="</span>, y, <span class="string">" "</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        fmt.Print(<span class="string">"x="</span>, x, <span class="string">" "</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 A、B 四行语句的交替执行，以上代码的如下输出是可接受的：</p>
<ol>
<li>y=0 x=1</li>
<li>y=2 x=1</li>
<li>x=0 y=2</li>
<li>x=1 y=2</li>
</ol>
<p>但是由于处理器缓存的存在，写操作（A1 &amp;&amp; B1）可能不会立即对其它 goroutine 可见，那么其它 goroutine 就会使用过期值。此外，由于赋值语句和输出语句对应不同变量，编译器可能认为这两个语句的执行顺序是不重要的，于是私自调换了语句的执行顺序。我们可能看到这样的非预期输出：</p>
<ol>
<li>y=0 x=0</li>
<li>y=2 x=0</li>
<li>x=0 y=0</li>
<li>x=1 y=0</li>
</ol>
<p>要解决这样的问题，访问共享变量前利用上文提到的同步原语进行同步就可以了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/也谈进程、线程与协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/02/也谈进程、线程与协程/" class="post-title-link" itemprop="url">也说进程、线程与协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-02 10:05:30" itemprop="dateCreated datePublished" datetime="2020-03-02T10:05:30+08:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-25 23:49:52" itemprop="dateModified" datetime="2020-04-25T23:49:52+08:00">2020-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从-CPU-谈起"><a href="#从-CPU-谈起" class="headerlink" title="从 CPU 谈起"></a>从 CPU 谈起</h1><p>CPU 被誉为“计算机的大脑”，这个比喻可以说是很恰当了。计算机无论是进行 IO 还是计算都要在 CPU 的控制下完成。如此一来，一个强大的“大脑”对于整个系统而言就是非常重要的了，这也是为什么我们总能看到厂家不断地宣传自己 CPU 的主频有多高，核心有多大。</p>
<h2 id="多核-CPU"><a href="#多核-CPU" class="headerlink" title="多核 CPU"></a>多核 CPU</h2><p>要提高 CPU 的性能，最直接的方法当然是不断增强单个处理器的性能，让处理器频率更高。就像要举起一块石头，让自己变得足够强壮就可以了。</p>
<p>但是这种方法很快就受制于物理定律：当前技术条件下无限提高频率是不可能的，而且过高的频率也会导致发热量过大。因此，工程师们只好退而求其次，转而增加一个 CPU 内的处理器数量。还是要举起石头，一个人无论如何也举不起来，那多喊几个小弟帮忙总可以吧？</p>
<p>有了多核 CPU，程序就可以被划分为相对独立的几个部分，每一部分运行在不同的处理器上。当然，这样做也会带来额外的开销。如果操作系统和程序不能很好地协调多处理器，那么执行速度未必就有明显提高（乃至降低也说不定~）。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>下面给出进程的定义：</p>
<blockquote>
<p>进程是具有一定独立功能的程序在一个数据集合上的一次动态执行过程</p>
</blockquote>
<p>进程是操作系统<strong>分配资源</strong>的最小单位，拥有代码文本、被分配的系统资源、独立的虚拟内存地址、堆栈空间：</p>
<p><img src="https://i.loli.net/2020/03/02/qz7MdhlxtQmK8pI.png" alt="进程内存空间"></p>
<p>操作系统为每个进程维护了一个程序控制块（PCB, Process Contral Block），用来保存该进程的状态信息（进程标识、寄存器、系统资源、调度信息等）。PCB 是进程存在的唯一标识。</p>
<p>进程在整个生命周期期间处于以下五个状态之一：</p>
<p><img src="https://i.loli.net/2020/03/02/dY1JoNBIRLCFE4G.png" alt="进程状态"></p>
<ul>
<li>NULL -&gt; 创建：一个新进程被产生出来执行一个程序</li>
<li>创建 -&gt; 就绪：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li>
<li>就绪 -&gt; 运行：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行</li>
<li>运行 -&gt; 结束：当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理</li>
<li>运行 -&gt; 就绪：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li>
<li>运行 -&gt; 等待：当进程请求某资源且必须等待时</li>
<li>等待 -&gt; 就绪：当进程要等待某事件到来时，它从阻塞状态变到就绪状态</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是进程的一部分，描述一段指令流的执行状态，是系统<strong>调度</strong>的基本单位。每个线程拥有自己的线程控制块（TCB, Thread Contral Block），保存了线程标识、从属进程、寄存器状态等信息。</p>
<p><img src="https://i.loli.net/2020/03/02/P6MXJ5WHtQNp4x1.png" alt="线程内存空间"></p>
<p>如前面所言，程序被划分为几部分跑在不同处理器上，这些被划分出来的“部分”就可以看做一个个的线程。</p>
<h1 id="进程与线程的异同"><a href="#进程与线程的异同" class="headerlink" title="进程与线程的异同"></a>进程与线程的异同</h1><p>进程和线程的切换是 OS 通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算。每次 CPU 计算的指令数量和代码跑过的 CPU 时间是相关的，跑满 OS 分配的时间片后就会被强制挂起，开发者无法精确的控制它们。</p>
<ul>
<li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间</li>
<li>资源分配：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的</li>
<li>程序入口：每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。而线程不能够独立执行，必须依存在进程中，由进程对多个线程执行控制。</li>
<li>健壮性：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮</li>
</ul>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>协程是编译器级的，进程是和线程是操作系统级的</strong></p>
<p>协程（Coroutine）是比线程更轻量级的存在，可以说是一种<strong>用户态线程</strong>。它更像是一个函数，只是这个函数可以像线程那样中途让出执行权，满足某种条件后又从等待的地方继续运行。</p>
<p>它比线程拥有更少的资源（必要的寄存器信息，堆栈指针等），<strong>切换策略仅由用户态控制</strong>，对于操作系统是透明的，所以协程间的切换非常快。但这也导致协程无法充分利用多核 CPU，因为协程再多，在操作系统眼里也只有一个线程在运行罢了。</p>
<p><img src="https://i.loli.net/2020/03/02/X3jbaStuZRByIdw.png" alt="协程"></p>
<p>Go 的调度器使用 m:n 调度，其中 m 是 goroutine 数，n 是活跃线程数（由 GOMAXPROCS 决定，默认等于处理器核心数）。当一个 goroutine 陷入休眠或阻塞在一次管道通信上，调度器会把它的状态设为 <code>_Gwaiting</code> 并解除它与线程的绑定（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程；而如果 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并解除线程和处理器的绑定（相当于让出处理器，这样处理器就可以绑定到其它线程上。这个过程触发一次线程切换的系统调用）。</p>
<p>以 go 为例，在一个线程里面开启多个协程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// 开启一个新的协程</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">"%v: Hello World!\n"</span>, n)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程的优点"><a href="#协程的优点" class="headerlink" title="协程的优点"></a>协程的优点</h2><ol>
<li>创建成本低。在 go 里每个协程大约只占用 1k 的内存。</li>
<li>调度成本低。协程属于用户态，不需要经过操作系统管理</li>
<li>减少上锁频率。因为协程都是跑在一个线程里的，所以不用担心指令执行到一半被夺去运行权限的问题。但是如果协程间存在竞争，并不能保证临界区，所以并不是完全不需要锁。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/21/开始你的Go-Module之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/开始你的Go-Module之路/" class="post-title-link" itemprop="url">开始你的Go Module之路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-21 23:07:01" itemprop="dateCreated datePublished" datetime="2020-02-21T23:07:01+08:00">2020-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-26 10:30:29" itemprop="dateModified" datetime="2020-03-26T10:30:29+08:00">2020-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 go 的历史上出现过一大批包管理工具，如 dep，vendor 等。自 go1.12 以来官方引入了 go module 来解决这个乱象。</p>
<h1 id="从-GOPATH-说起"><a href="#从-GOPATH-说起" class="headerlink" title="从 GOPATH 说起"></a>从 GOPATH 说起</h1><p>GOPATH 是最早的 go 包管理方案，安装 golang 之后需要配置两个环境变量 <code>GOROOT</code> 与 <code>GOPATH</code>, 前者是 go 安装目录，后者是开发者自定义的用于存放代码的地方。GOPATH 下存在三个目录：</p>
<ul>
<li>bin: 存放编译后的可执行文件</li>
<li>pkg: 存放 go 的链接文件(suffix = .a)</li>
<li>src: 存放源代码</li>
</ul>
<p>平时我们的项目就放在 src 下，每个项目一个文件夹。每当我们用 import 语句导入包，go 会从 <code>$GOROOT/src</code> 和 <code>$GOPATH/src</code> 查找匹配的目录。举个栗子，假设我的 GOPATH 是 E:\go，在 src 下创建一个项目 service，里面有个 main.go 文件和 test 包：</p>
<p><img src="https://i.loli.net/2020/02/21/B9VCsnjychDQTJ4.png" alt="service"></p>
<p>main.go 文件内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/ramya-rao-a/go-outline"</span></span><br><span class="line">    <span class="string">"./test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>fmt 是 go 自带的包，位于 $GOROOT/src/fmt；github.com/ramya-rao-a/go-outline 是第三方包，位于 $GOPATH/src/github.com/ramya-rao-a/go-outline；test 是自定义包，<code>.</code> 表示 mian.go 所在文件夹，位于 $GOPATH/src/service/test</p>
<h1 id="升级，Go-module！"><a href="#升级，Go-module！" class="headerlink" title="升级，Go module！"></a>升级，Go module！</h1><p>讲了一大堆，是时候进入正题了。前面讲利用 GOPATH 进行包管理这个方法是在是太麻烦了，每个项目都要配一个专属的 GOPATH，不然各个项目的包就会混在一起。</p>
<p>go1.12 后，设置环境变量 <code>GO111MODULE=on</code>，每个软件包都可以声明为一个 module。每个 module 的依赖包都会放在 $GOPATH/pkg/mod 下。如果没有设置 GOPATH 也没关系，go 会在用户的 $home 目录下创建一个 go 文件夹作为默认的 GOPATH</p>
<h2 id="声明-module"><a href="#声明-module" class="headerlink" title="声明 module"></a>声明 module</h2><p>modulename 是任意的。如果想把这个包发布出去，最好还是按 github.com/user/xxxx 的形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init &lt;modulename&gt;</span><br></pre></td></tr></table></figure>
<p>举个栗子，还是那个 service 项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init github.com/yue-qiu/service</span><br></pre></td></tr></table></figure>
<p>现在，在这个项目里，github.com/yue-qiu/service 就是这个项目的根目录。main.go 改写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/ramya-rao-a/go-outline"</span></span><br><span class="line">    <span class="string">"github.com/yue-qiu/service/test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>go mod 命令提供了一系列与 module 相关的用法：</p>
<p><img src="https://i.loli.net/2020/02/22/qk9bN2IMT48OSza.png" alt="module"></p>
<ul>
<li>go mod download: 根据 go.mod 中的内容拉取依赖包到本地</li>
<li>go mod tidy: 根据项目的导入信息往 go.mod 中添加、删除依赖包记录。建议少用，因为它会自动把所有依赖包升级到最新版本</li>
<li>go mod graph: 打印项目的依赖关系图</li>
<li>go mod vendor: 将 go.mod 中记录的依赖包缓存到一个 vendor 目录，这样在没网的情况下也能编译项目了</li>
<li>go mod edit [flag]: [flag] 又分好几种：<ul>
<li>fmt: 格式化 go.mod</li>
<li>require=path@version or droprequire=path@version: 添加依赖 or 删除依赖</li>
<li>replace=oldpath=newpath or droprequire=oldpath: 替换依赖</li>
</ul>
</li>
</ul>
<p>这里重点说下 -replace 选项，因为在生产中经常遇到的一种情况是由于这样那样的原因我们需要 fork 一个私有仓库去改动第三方开源库，例如有个小哥针对 logrus 做了二次开发 github.com/gogap/logrus，这个时候就需要用 github.com/gogap/logrus 替换之前的第三方开源库 github.com/sirupsen/logrus，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit -replace=<span class="string">"github.com/sirupsen/logrus=github.com/gogap/logrus@v0.8.2"</span></span><br><span class="line"></span><br><span class="line">$ cat go.mod</span><br><span class="line"></span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require github.com/sirupsen/logrus v1.4.2</span><br><span class="line"></span><br><span class="line">replace github.com/sirupsen/logrus =&gt; github.com/gogap/logrus v0.8.2</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/16/回车-or-换行？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/16/回车-or-换行？/" class="post-title-link" itemprop="url">回车 or 换行？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-16 20:23:01" itemprop="dateCreated datePublished" datetime="2020-02-16T20:23:01+08:00">2020-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-19 12:25:59" itemprop="dateModified" datetime="2020-02-19T12:25:59+08:00">2020-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以前编程的时候一直没注意回车符与换行符的区别，只是大概知道一个是 \r 一个是 \n。今天心血来潮查了一下，发现这还蛮有趣的~</p>
<h1 id="回车-CR"><a href="#回车-CR" class="headerlink" title="回车 CR"></a>回车 CR</h1><p>原名 Carriage Return，ASCII 码 13。表示光标回到行首。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello\rworld"</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>
<h1 id="换行-LF"><a href="#换行-LF" class="headerlink" title="换行 LF"></a>换行 LF</h1><p>原名 Line Feed，ASCII 码 10。表示光标移动到下一行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello\nworld"</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   hello</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>
<h1 id="渊源"><a href="#渊源" class="headerlink" title="渊源"></a>渊源</h1><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。但是它有一个问题，就是打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p><img src="https://i.loli.net/2020/02/16/kMxhL2pTCwBZASi.png" alt="打字机"></p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。至于为什么回车在前换行在后呢？因为回车需要的时间更长，机器可以利用这个间隙完成换行操作。</p>
<p>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了。于是，就出现了分歧：</p>
<ul>
<li>\r\n: Windows 系统行末结束符</li>
<li>\r: Mac 系统行末结束符</li>
<li>\n: Unix 系统行末结束符</li>
</ul>
<p>一个直接后果是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。</p>
<p>总结：虽然不同操作系统对行末结束符的定义不同，但 \r\n 是历史传统而且被多个标准（如 HTTP，SMTP）所采纳，所以实际使用中还是以 \r\n 居多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/13/URI与URL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/13/URI与URL/" class="post-title-link" itemprop="url">网络那些事之URI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-13 09:29:36" itemprop="dateCreated datePublished" datetime="2020-02-13T09:29:36+08:00">2020-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-19 00:44:42" itemprop="dateModified" datetime="2020-02-19T00:44:42+08:00">2020-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是-URI"><a href="#什么是-URI" class="headerlink" title="什么是 URI"></a>什么是 URI</h1><p>URI(Uniform Resource Identifier)：统一资源标识符，用于<strong>唯一标识一个资源</strong>。</p>
<p>URL(Uniform Resource Locator)：统一资源定位符，表明在一个资源在网络中的访问方式。通常表现为 <code>协议+路径+参数</code></p>
<p>URN(Uniform Resource Name)：统一资源定位名称，通过某个命名空间中的唯一 ID 来标识一个资源</p>
<p><img src="https://i.loli.net/2020/02/13/2XjAU6Phz9ONJQq.png" alt="URI"></p>
<p>举个例子：小红的学号是 123456，这个学号就是 URN，能对应到小红这个人；小红的家庭住址是翻斗大街翻斗花园二号楼一零零一室，这个地址就是 URL，去那里就能找到小红。小红的学号、小红的住址都属于 URI。</p>
<h1 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h1><p>一个标准的 URI 格式为：<code>[scheme:]scheme-specific-part</code>，如：<a href="http://qiuyueqy.com" target="_blank" rel="noopener">http://qiuyueqy.com</a>, mailto:<a href="mailto:qiuyue9971@126.com" target="_blank" rel="noopener">qiuyue9971@126.com</a>, news:comp.go.lang</p>
<p>URI 可以细分为为<code>不透明的(opaque)</code>和<code>分层的(hierarchical)</code>两类：</p>
<ul>
<li>opaque 指 scheme-specific-part 不以 / 开头，是一个整体。呈 [scheme]:opaque[?query][#fragment] 的形式。如：mailto:<a href="mailto:qiuyue9971@126.com" target="_blank" rel="noopener">qiuyue9971@126.com</a>，<a href="http://www.google.com:443" target="_blank" rel="noopener">www.google.com:443</a>, opaque 必须是绝对的。</li>
<li>hierarchical 指 scheme-specific-part 以 / 开头且可以划分为好几部分。呈 [scheme:][//[userinfo@]host[:port]]path[?query][#fragment] 的形式。如：<a href="http://qiuyueqy.com/categories/" target="_blank" rel="noopener">http://qiuyueqy.com/categories/</a>, hierarchical 可以是绝对的，也可以是相对的，如：<a href="https://github.com/yue-qiu/CUG_EmptyClassroom" target="_blank" rel="noopener">https://github.com/yue-qiu/CUG_EmptyClassroom</a>, ../../static/verify.js</li>
</ul>
<h1 id="谈谈-URI-编码"><a href="#谈谈-URI-编码" class="headerlink" title="谈谈 URI 编码"></a>谈谈 URI 编码</h1><p>利用 URI 传参时，如果某些 URI 组件字符（如 /:?@&amp;=+$,#）同时也是参数的一部分会导致 URI 歧义。此外，URI 只支持 ASCII 编码，对于茫茫多的特殊字符（如：广东省）如何表示？</p>
<p>所谓办法总比困难多，为了解决这些问题，URI 编码应运而生。举个栗子，对下面这个未经编码的 URI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>
<p>要表示特殊字符，我们把它按某个字符集（通常是 UTF-8）编码成十六进制的 %hh 形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://qiuyueqy.com?page=2&amp;category=%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>
<p>如果这个 URI 是另一个 URI 的参数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpw://www.google.com?callback=http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>
<p>显然，由于参数中 /、? 等组件字符的存在，上面这个 URI 的解释是有歧义的。这时，我们把整个回调 URI（包括它的组件字符）进行编码，再作为参数就没问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpw://www.google.com?callback=http%3A%2F%2Fqiuyueqy.com%2F%3Fpage%3D2%26category%3D%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>
<h1 id="golang-对-URL-的实现"><a href="#golang-对-URL-的实现" class="headerlink" title="golang 对 URL 的实现"></a>golang 对 URL 的实现</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Scheme   <span class="keyword">string</span>    <span class="comment">//具体指访问服务器上的资源使用的哪种协议</span></span><br><span class="line">    Opaque   <span class="keyword">string</span>    <span class="comment">// 编码后的不透明数据</span></span><br><span class="line">    User     *Userinfo <span class="comment">// 用户名和密码信息,有些协议需要传入明文用户名和密码来获取资源，比如 FTP</span></span><br><span class="line">    Host     <span class="keyword">string</span>    <span class="comment">// host或host:port，服务器地址，可以是 IP 地址，也可以是域名信息</span></span><br><span class="line">    Path     <span class="keyword">string</span>  <span class="comment">//路径，使用"/"分隔</span></span><br><span class="line">    RawQuery <span class="keyword">string</span> <span class="comment">// 编码后的查询字符串，没有'?'</span></span><br><span class="line">    Fragment <span class="keyword">string</span> <span class="comment">// 引用的片段（文档位置），没有'#'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/06/网络那些事之网络安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/06/网络那些事之网络安全/" class="post-title-link" itemprop="url">网络那些事之网络安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-06 15:09:10" itemprop="dateCreated datePublished" datetime="2020-02-06T15:09:10+08:00">2020-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-11 16:47:10" itemprop="dateModified" datetime="2020-02-11T16:47:10+08:00">2020-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络安全的基本属性"><a href="#网络安全的基本属性" class="headerlink" title="网络安全的基本属性"></a>网络安全的基本属性</h1><ul>
<li>机密性：发送方加密，预定接收方解密</li>
<li>身份认证：发送方与预定接收方能确定彼此身份</li>
<li>完整性：信息不会被篡改，即使被篡改了也可以被检测出来</li>
</ul>
<h1 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h1><ul>
<li>映射（Mapping）：利用 ping 确定网络上运行主机的地址，再通过<strong>端口扫描</strong>依次尝试与每个端口建立 TCP 连接，找出主机在运行的服务</li>
<li>嗅探（sniffing）：在共享介质网络中，攻击方接收所有经过它的分组，层层解析后得到数据<br><img src="https://i.loli.net/2020/02/06/s8lqcjTVEtJ4f5M.png" alt="分组嗅探"></li>
<li>IP 欺骗：修改分组的源 IP 地址，冒充发送方</li>
<li>拒绝服务（DoS）：向接收方恶意泛洪分组，淹没接收方（带宽耗尽、资源耗尽）<br><img src="https://i.loli.net/2020/02/06/CearKxmuZjUF1fz.png" alt="DDoS"><br><img src="https://i.loli.net/2020/02/06/TgOkCnZjJm1BEwX.png" alt="反射DDos"></li>
<li>中间人攻击：对源主机伪装成目的主机，对目的主机伪装成源主机</li>
</ul>
<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>明文：没有进过加密的数据</li>
<li>密文：进过加密算法加密的数据</li>
<li>加密、解密密钥：用于辅助加密、解密的参数</li>
</ul>
<p>按加密密钥与解密密钥是否相同，将加密算法分为两大类：<strong>对称加密</strong>（加解密钥相同）与<strong>非对称加密</strong>（每方有公开、私有两个密钥）</p>
<h2 id="传统加密方法"><a href="#传统加密方法" class="headerlink" title="传统加密方法"></a>传统加密方法</h2><ul>
<li>替代密码：用一种东西替代另一种东西（单码替代、多字母替代等）</li>
<li>换位密码：重新排列明文中的字母（置换法等）</li>
</ul>
<h2 id="现代加密方法"><a href="#现代加密方法" class="headerlink" title="现代加密方法"></a>现代加密方法</h2><p>现代技术不再针对字母，而是针对<strong>二进制位</strong>进行操作，其原理既包括替代，又包括换位：</p>
<ul>
<li>对称加密<ul>
<li>流密码：密钥产生密钥流，由密钥流对数据流进行加解密<br><img src="https://i.loli.net/2020/02/07/HOK1XPzD7aq8Ckc.png" alt="流密码"></li>
<li>分组密码：将明文序列划分为若干长为 M 的明文组，各明文组利用长为 i 的密钥组变换得到若干长度为 N 的密文组。通常分组长度取 64 bits<br><img src="https://i.loli.net/2020/02/07/JOH4tvB5z1qgnU8.png" alt="Feistel分组密码"></li>
</ul>
</li>
<li>非对称加密</li>
</ul>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><h4 id="分组密码例子：DES"><a href="#分组密码例子：DES" class="headerlink" title="分组密码例子：DES"></a>分组密码例子：DES</h4><p>DES：数据加密标准（Data Encryption Standand），本质是 16 轮的 Feistel 分组密码，分组长度为 64 bits，密钥长度为 56 bits，每轮产生一个 48 bits 的子密钥：</p>
<p><img src="https://i.loli.net/2020/02/07/KQu1WXrx9wV4Dfj.png" alt="DES加密"></p>
<p><img src="https://i.loli.net/2020/02/07/c9g7j84hTADVRG5.png" alt="子密钥生成"></p>
<p>IP 置换：把输入数据的<strong>排列顺序打乱</strong></p>
<h4 id="分组密码例子：AES"><a href="#分组密码例子：AES" class="headerlink" title="分组密码例子：AES"></a>分组密码例子：AES</h4><p>AES：高级加密标准（Advanced Encryption Standand），分组长度 128/192/256 bits，可提供 128/192/256 bits 密钥，循环次数在一定范围内可变，与 DES 相比安全得多。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥加密算法的需求：</p>
<ul>
<li>公钥加密 K<sub>B</sub><sup>+</sup> 和私钥解密 K<sub>B</sub><sup>-</sup> 要满足：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m</li>
<li>给定公钥 K<sub>B</sub><sup>+</sup>，不可能计算得到 K<sub>B</sub><sup>-</sup></li>
</ul>
<h4 id="非对称加密例子：RSA"><a href="#非对称加密例子：RSA" class="headerlink" title="非对称加密例子：RSA"></a>非对称加密例子：RSA</h4><p>任何信息在计算机中都以比特流的形式表示，每个比特流可以表示为一个唯一的整数，因此<strong>加密一个报文就等于加密一个整数</strong>。</p>
<p>RSA 公钥/私钥生成过程：</p>
<ol>
<li>选择 2 个大质数 p 和 q</li>
<li>计算 n = pq，z = (p-1)(q-1)</li>
<li>选择 e(e &lt; n)，使 e 与 z 互质</li>
<li>选择 d 使 ed mod z = 1</li>
<li>得到公钥 (n,e)，私钥（n,d）</li>
</ol>
<p>给定公钥 (n,e)和私钥(n,d)，RSA 加密过程：</p>
<ol>
<li>加密报文 m 时，计算 c = m<sup>e</sup> mod n</li>
<li>解密报文 c 时，计算 m = c<sup>d</sup> mod n</li>
</ol>
<p>总结：<strong>m = (m<sup>e</sup> mod n)<sup>d</sup> mod n = m<sup>ed</sup> mod n = m<sup>ed mod z</sup> mod n</strong></p>
<p>RSA 的公钥密钥是相对的，即可以用公钥加密私钥解密，也可以用私钥加密公钥解密：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m = K<sub>B</sub><sup>+</sup>(K<sub>B</sub><sup>-</sup>(m))</p>
<p>由于 RSA 运算强度超高，实际应用中几乎不可能用于加密大报文，所以常常与对称加密结合使用。即用 RSA 解决对称加密中密钥分发问题，再利用对称加密算法对数据进行加密。这种方式分发的密钥称为<strong>会话密钥</strong>。</p>
<h1 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h1><p>报文完整性也称为报文认证，目标有：</p>
<ul>
<li>证明报文确实来自<strong>声称的发送方</strong></li>
<li>验证报文<strong>没有被篡改</strong></li>
<li>预防报文的<strong>时间、顺讯、持有期被修改</strong></li>
</ul>
<p>对报文应用散列函数 H 得到一个<strong>固定长度</strong>的散列码。这个散列码称为<strong>报文摘要</strong>，相当于源报文的数字指纹，可以用于报文认证。</p>
<p>散列函数算法例子：</p>
<ul>
<li>MD5：对任意长度的报文输入，计算输出 128 bits 散列值</li>
<li>SHA-1（Secure Hash Algorithm）：要求输入长度 &lt; 2<sup>64</sup>，计算输出 160 bits 散列值。速度较慢但是安全性高于 MD5</li>
</ul>
<p><img src="https://i.loli.net/2020/02/08/5nhQBRmlwc8ApJY.png" alt="报文认证"></p>
<p>这种报文认证方法虽然能验证报文完整性，但是无法解决否认（发送方不承认自己发送过某一报文）、伪造（接收方伪造一份报文并声称来自发送方）、篡改（接收方对收到的信息进行修改）等问题，由此衍生了现实中广泛使用的数字签名（Digital Signatures）技术</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是实现安全电子交易的核心技术之一，特点是：</p>
<ul>
<li>可验证性：可以验证发送方身份、报文是否被篡改</li>
<li>不可伪造性：接收方无法伪造报文</li>
<li>不可抵赖性：发送方无法否认曾经发送过这样一个报文</li>
</ul>
<p>要实现数字签名，必须依赖于加密技术。但是为了确保接收方不可能伪造报文，无法使用对称加密技术。</p>
<p>签名过程举例：Bob 作为发送方给 Alice 发消息</p>
<p><img src="https://i.loli.net/2020/02/08/piZw95RkYKrS8a4.png" alt="签名报文摘要"></p>
<p>经过加密的报文摘要称为<strong>报文认证码（MAC）</strong>，是基于密钥和消息摘要所获得的一个值，可用于数据源认证和完整性校验。</p>
<h1 id="密钥分发中心（KDC）"><a href="#密钥分发中心（KDC）" class="headerlink" title="密钥分发中心（KDC）"></a>密钥分发中心（KDC）</h1><p>解决两个实体在网上共享对称密钥的问题，由此引入“可信任的密钥分发中心（Key Distribution Center）”作为两实体间的中介。</p>
<p>KDC 本质上是一个服务器，每个使用共享密钥服务的用户都要在此注册一个专属密钥。</p>
<p>密钥分发举例：Alice 与 Bob 使用 KDC 为中介共享密钥，R 即是 Alice 与 Bob 间的会话密钥</p>
<p><img src="https://i.loli.net/2020/02/08/nlT748VJQMcCpHW.png" alt="密钥分发"></p>
<h1 id="认证中心（CA）"><a href="#认证中心（CA）" class="headerlink" title="认证中心（CA）"></a>认证中心（CA）</h1><p>CA 负责公钥分发（保证公钥的来源可信），实现特定实体与其公钥的绑定：</p>
<p>假设 Bob 在 CA 注册他的公钥信息：</p>
<ol>
<li>Bob 向 CA 提供身份证明</li>
<li>CA 创建绑定 Bob 身份及其公钥的证书</li>
<li>证书包含 CA 签名的 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/uBWcYDPXKn4Mepv.png" alt="CA认证"></p>
<p>Alice 想要得到 Bob 的公钥：</p>
<ol>
<li>获得 Bob 的公钥证书</li>
<li>应用 CA 的公钥解密，获得 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/SDnVh2NzTKMeAu5.png" alt="CA解密"></p>
<p>一张公钥证书包含的要素有：</p>
<ul>
<li>序列号：唯一发行号</li>
<li>持有人信息：机构名，机构公钥，签名算法</li>
<li>发行者信息</li>
<li>有效期：保证在这个时间内从 CA  获得的公钥是有效的</li>
<li>发行者数字签名</li>
</ul>
<p><img src="https://i.loli.net/2020/02/09/Zv6k1a8u2Oc3SCI.png" alt="公钥证书"></p>
<h1 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h1><p>安全套接字层（SSL）或传输层安全（TLS） 可作为基础协议栈的组成部分，对应用透明。使用 SSL 后，传送 的应用层数据会被加密：</p>
<p><img src="https://i.loli.net/2020/02/09/PpZgjnTwkQEJ5RN.png" alt="SSL/TLS"></p>
<p>所谓 HTTPS 就是套了一层 SSL 的 HTTP 协议，保证信息的机密性和完整性，提供服务器认证功能。</p>
<h2 id="SSL-通信概览"><a href="#SSL-通信概览" class="headerlink" title="SSL 通信概览"></a>SSL 通信概览</h2><p>以 Alice 向 Bob 建立一个 SSL 连接为例：</p>
<p>TCP 连接建立完成后，就要开始<strong>建立 SSL 连接</strong></p>
<ol>
<li>Alice 向 Bob 发送请求</li>
<li>Bob 回应他的公钥证书</li>
<li>Alice 获得 Bob 的公钥，利用这个公钥加密一个随机产生的主密钥 MS 表示为 EMS（加密过的主密钥）</li>
</ol>
<p>不同的加密操作使用不同的密钥会更安全（如：报文认证码 MAC 密钥与数据加密密钥），所以 SSL 会通过主密钥 MS <strong>派生出一组密钥</strong>：</p>
<ul>
<li>K<sub>c</sub>：加密客户端向服务器发送数据的密钥</li>
<li>M<sub>c</sub>：加密客户端向服务器发送数据的 MAC 密钥</li>
<li>K<sub>s</sub>：加密服务器向客户端发送数据的密钥</li>
<li>M<sub>s</sub>：加密服务器向客户端发送数据的 MAC 密钥</li>
</ul>
<p>SSL 将字节流<strong>分割</strong>为一系列记录，每个记录携带自己的 MAC。在 MAC 中有记录的<strong>序列号</strong>和<strong>一次性随机数</strong>，防止攻击者重排或重放记录。同时还要添加<strong>记录类型</strong>，防止攻击者伪造 TCP 断连，type=0 用于数据记录，type=1 用于断连。即：MAC = MAC(key, sequence||type||digest)</p>
<p><img src="https://i.loli.net/2020/02/09/Wp6jCXhdVsRDKr3.png" alt="SSL记录"></p>
<p>一次简化的 SSL 通信过程如下：</p>
<p><img src="https://i.loli.net/2020/02/09/UrEF6ADhgWdI8qj.png" alt="SSL通信过程"></p>
<h2 id="现实中的-SSL-协议栈"><a href="#现实中的-SSL-协议栈" class="headerlink" title="现实中的 SSL 协议栈"></a>现实中的 SSL 协议栈</h2><p>SSL 支持客户与服务器商定各自使用的<strong>密码组</strong>（加密算法及密钥），通常是客户端提供选项，服务器从中挑选。</p>
<p>SSL 不是一个单独的协议，而是两层共四个协议：</p>
<p><img src="https://i.loli.net/2020/02/10/3e8GhFqg5BADw1s.png" alt="SSL四协议"></p>
<ul>
<li>更改密码规格协议：负责更改当前连接的密码组，标志着当前加密策略的改变。ContentType = 20</li>
<li>警告协议：加密出错或握手失败时，为对方发送警告或直接中止当前连接。ContentType = 21</li>
<li>握手协议：确定 SSL 握手过程（商定加密算法，建立密钥，提供服务器证书认证）。ContentType = 22</li>
<li>记录协议：描述 SSL 记录格式，封装数据</li>
</ul>
<p><img src="https://i.loli.net/2020/02/10/slABwdEjWJz3MhL.png" alt="SSL记录"></p>
<h2 id="SSL-握手过程"><a href="#SSL-握手过程" class="headerlink" title="SSL 握手过程"></a>SSL 握手过程</h2><ol>
<li>客户端发送其支持的算法列表及客户端一次性随机数（nonce）</li>
<li>服务器选择算法并发回给客户：选择 + 证书 + 服务器一次性随机数</li>
<li>客户端验证证书提取服务器公钥，生成<strong>预主密钥</strong>，并利用服务器公钥加密预主密钥，发送给服务器</li>
<li>客户端与服务器基于预主密钥和一次性随机数分别独立计算加密密钥和 MAC 密钥（两方使用相同的算法，得到相同的密钥）</li>
<li>客户端发送一个针对所有握手过程的 MAC</li>
<li>服务器发送一个针对所有握手过程的 MAC</li>
</ol>
<p>SSL 完全建立之前所有信息都是明文传输的，这就很容易被有心人篡改其中内容，最后两步可以作为握手信息完整性认证。</p>
<h1 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h1><p>IPsec 负责网络层安全，提供机密性，完整性，源认证，防重放攻击服务。IPsec 在网络层中的传输有两种模式：</p>
<ul>
<li>传输模式：IPsec 数据报的发送与接收都在端系统完成<br><img src="https://i.loli.net/2020/02/10/KcMzgYaHW9FmZnf.png" alt="IPsec传输模式"></li>
<li>隧道模式：边缘路由器是 IPsec 感知的，IPsec 数据报进入局域网前还原为普通 IP 数据报<br><img src="https://i.loli.net/2020/02/10/tKvBjaneT8SxqPi.png" alt="IPsec隧道模式"></li>
</ul>
<p>有两个协议提供 IPsec 服务：</p>
<ul>
<li>数据认证头协议（AH, Authentication Header）：提供源认证，完整性<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/YHNn6CbAxr58pGM.png" alt="传输模式AH记录"><br>下一个头：指向源 IP 数据报载荷中的头部信息，如 TCP 头、UDP 头</li>
<li>隧道模式：<br><img src="https://i.loli.net/2020/02/11/vjBYzwEKF8de9N2.png" alt="隧道模式AH记录"></li>
</ul>
</li>
<li>封装安全协议（ESP, Encapsulation Security Protocol）：提供源认证，完整性，机密性。实际应用中最为广泛，我们常用的 VPN 就是基于这种协议<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/AleEbu4oYGrnH6v.png" alt="传输模式ESP记录"></li>
<li>隧道模式：最重要最常见的 IPsec 实现<br><img src="https://i.loli.net/2020/02/11/HKMmj89w2WpdXG1.png" alt="隧道模式ESP记录"></li>
</ul>
</li>
</ul>
<h2 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h2><p>发送数据前，发送端到接收端之间需要建立安全关联 <strong>SA</strong>(Security Association)以定义对数据报的加密算法与密钥。两方均要维护 SA 的连接状态信息。换言之，IPsec 并不是简单的对 IP 的封装，IP 是无连接的，<strong>IPsec 是面向连接的</strong>：</p>
<p><img src="https://i.loli.net/2020/02/10/3IexuNEcTjdCKpv.png" alt="SA连接"></p>
<h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><p>安全策略 <strong>SP(Security Policy)</strong> 定义了对什么样的数据流应用 IPsec。多条安全策略记录组成了安全策略数据库 SPD。服务器提取数据报关键信息填充到一个称为“选择符”（目标IP，源IP，传输层协议，源端口，目标端口）的结构中，利用选择符去搜索 SPD，检索匹配的 SP。</p>
<h1 id="虚拟专用网（VPN）"><a href="#虚拟专用网（VPN）" class="headerlink" title="虚拟专用网（VPN）"></a>虚拟专用网（VPN）</h1><p>专用网络：基于专属的网络设备、链路或协议建设的专门用途的网络。最大的好处就是安全，但是成本很高。</p>
<p><img src="https://i.loli.net/2020/02/10/SRnjU6oa45tBFWC.png" alt="专用网络"></p>
<p>虚拟专用网络：通过建立在公共网络上的<strong>安全隧道</strong>，实现总部与分部的安全连接，在逻辑上建立一个专用网络，大大降低了费用。由隧道模式 ESP 实现的 IPsec 是 VPN 最常见的实现方法。</p>
<p><img src="https://i.loli.net/2020/02/10/Ay3ohPu6sZIarG2.png" alt="虚拟专用网络"></p>
<p>隧道：通过 Internet 提供安全的端到端的数据传输，本质上是一种加密与封装。数据进入隧道时经 VPN 封装在 Internet 中传输。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p><img src="https://i.loli.net/2020/02/11/cPOTpuCNy6EUd4F.png" alt="VPN实例"></p>
<ol>
<li>R1 将 IP 数据报转换为 IPsec 数据报<ul>
<li>检索 SPD，确定 SP</li>
<li>检索 SAD，确定 SA</li>
<li>在源 IP 数据报后面附加 ESP 尾部</li>
<li>利用 SA 的加密算法与密钥加密数据报</li>
<li>在加密结果前面附加 ESP 头</li>
<li>利用 SA 的加密算法与密钥创建报文认证码 MAC</li>
<li>构造新 IP 头，发到 R2 去</li>
</ul>
</li>
<li>R2 解封 IPsec 数据报<ul>
<li>提取 SPI 去检索 SAD，确定 SA</li>
<li>利用共享密钥解出原始 IP 数据报</li>
</ul>
</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>防火墙是隔离内网与公共互联网，阻止某些分组进入 or 离开内网的软硬件设施。可分为三类：</p>
<ul>
<li>无状态分组过滤：位于网络边缘路由器，根据 IP 地址、端口号、协议类型等信息逐个过滤分组决定是否转发。</li>
<li>有状态组过滤：跟踪每个 TCP 连接，根据 SYN、FIN 等状态决定是否放行分组。</li>
<li>应用网关：基于应用层数据过滤分组<br><img src="https://i.loli.net/2020/02/11/i87WYut32LzXHVG.png" alt="应用网关"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/网络那些事之链路层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/30/网络那些事之链路层/" class="post-title-link" itemprop="url">网络那些事之链路层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-30 16:51:35" itemprop="dateCreated datePublished" datetime="2020-01-30T16:51:35+08:00">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-06 15:07:54" itemprop="dateModified" datetime="2020-02-06T15:07:54+08:00">2020-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul>
<li>结点（node）：主机和路由器</li>
<li>链路（link）：相邻结点的连接通道</li>
<li>帧（frame）：链路层数据分组</li>
</ul>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p>链路层负责通过一条链路在相邻结点之间传送数据报：</p>
<ul>
<li>组帧：封装数据报构成数据帧，加首部和尾部，帧同步（将物理层比特流转换为帧）</li>
<li>链路接入：如果链路是共享的，需要解决<code>链路接入</code>问题。帧首部 MAC 地址用于标识帧的源和目的地</li>
<li>相邻结点间的可靠交付（不一定实现）</li>
<li>流量控制：协调相邻的发送和接收结点</li>
<li>差错检测与纠正：应对信号衰减和噪声</li>
</ul>
<h1 id="差错编码"><a href="#差错编码" class="headerlink" title="差错编码"></a>差错编码</h1><p>D -&gt; DR，R 为差错检测与纠正比特（冗余比特）：</p>
<p><img src="https://i.loli.net/2020/01/31/OQePn1hbz65NMXG.png" alt="线性分组码"></p>
<p><strong>差错编码不保证 100% 可靠</strong>，分为<strong>检错码</strong>与<strong>纠错码</strong>。</p>
<h2 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h2><p>设 C<sub>i</sub>、C<sub>j</sub> 为编码集中任意两个码字，C’ 为错出错码字：</p>
<p>对于检错码，如果编码集的汉明距离 d = r + 1，则该差错编码可以检测 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/Z2LgfdqeOl64Nku.png" alt="检错码"></p>
<p>对于纠错码，若编码集的汉明距离 D = 2r + 1，则该差错编码可以纠错 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/wfSurjoh4TsUFCg.png" alt="纠错码"></p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>给一串比特增加一个校验位，使得该串中所有 “1” 的个数之和为奇数称奇校验，为偶数称偶校验。</p>
<p><img src="https://i.loli.net/2020/02/02/Sb13soanWqRtAyV.png" alt="奇校验"></p>
<p><img src="https://i.loli.net/2020/02/02/gz5fEopJ2X7Zjw4.png" alt="偶校验"></p>
<p>数据和校验位发送给接受方后，接收方再次对数据中1的个数进行计算，如果为奇数则校验通过，表示此次传输过程未发生错误。如果不是奇数，则表示有错误发生，此时接收方可以向发送方发送请求，要求重新发送一遍数据。</p>
<p>优点：</p>
<ul>
<li>容易实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>奇偶校验的检错率只有50%，因为只有奇数个数据位发生变化能检测到，如果偶数个数据位发生变化则无能为力了</li>
<li>每传输一个字节都需要加一位校验位，对传输效率影响很大</li>
<li>奇偶校验只能发现错误，但不能纠正错误，也就是说它只能告诉你出错了，但不能告诉你怎么出错了，一旦发现错误，只好重发</li>
</ul>
<h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>发送端：</p>
<ol>
<li>将数据按 16 bits 一组划分为的二进制数序列（此时数据中校验和字段为 0）</li>
<li>求和（Sum）：对这些二进制数求和（最高进位的 “1” 返回最低位继续相加）</li>
<li>校验和（CheckSum）：Sum 的反码</li>
</ol>
<p>接收端：</p>
<ol>
<li>重新计算数据的 CheckSum’（此时数据中校验和字段不为 0）</li>
<li>16 位 CheckSum’ 全为 0，无错</li>
</ol>
<h1 id="MAC-协议"><a href="#MAC-协议" class="headerlink" title="MAC 协议"></a>MAC 协议</h1><p>功能：多结点共享传输信道过程中，避免信号互相干扰。</p>
<p>有三类 MAC 协议：</p>
<ul>
<li>信道划分 MAC 协议：利用多路复用（时分、频分）支持多结点，每个结点只使用自己那部分</li>
<li>随机访问 MAC 协议：信道不划分，允许冲突。采用“冲突恢复”机制</li>
<li>轮转 MAX 协议：结点轮流使用信道，使用时占用全部带宽</li>
</ul>
<h2 id="随机访问-MAC-协议"><a href="#随机访问-MAC-协议" class="headerlink" title="随机访问 MAC 协议"></a>随机访问 MAC 协议</h2><p>结点发送分组时：</p>
<ul>
<li>利用信道全部带宽 R 发送分组</li>
<li>没有事先的结点间协调</li>
</ul>
<p>当两个或多个结点同时传输，会发生“<strong>冲突</strong>”。</p>
<h3 id="典型：时隙-ALOHA-协议"><a href="#典型：时隙-ALOHA-协议" class="headerlink" title="典型：时隙 ALOHA 协议"></a>典型：时隙 ALOHA 协议</h3><p>假定：</p>
<ul>
<li>所有帧大小相同</li>
<li>时间被划分为等长时隙（每个时隙刚好可以传输 1 个帧）</li>
<li>结点只在时隙开始时发送帧</li>
<li>结点能检测到冲突</li>
<li>所有结点的时钟同步</li>
</ul>
<p>运行：</p>
<ul>
<li>当结点有新帧，在下一时隙发送：<ul>
<li>无冲突：该结点可以在下一时隙继续发新帧</li>
<li>冲突：该结点在下一时隙以概率 <strong>P</strong> 重传帧</li>
</ul>
</li>
</ul>
<p>设 C 冲突时隙，E 空闲时隙，S 成功时隙：</p>
<p><img src="https://i.loli.net/2020/02/03/M2hT9UxicJ5mapt.png" alt="时隙ALOHA"></p>
<h3 id="典型：纯-ALOHA-协议"><a href="#典型：纯-ALOHA-协议" class="headerlink" title="典型：纯 ALOHA 协议"></a>典型：纯 ALOHA 协议</h3><p>不划分时隙的 ALOHA 协议，<strong>无需同步</strong>。</p>
<p>当有新的帧生成：</p>
<ul>
<li>立即发送</li>
<li>冲突可能性增大</li>
</ul>
<p>在 t<sub>0</sub> 时刻发送的帧，会与在 (t<sub>0</sub>-1, t<sub>0</sub>+1) 时间发送的帧冲突：<br><img src="https://i.loli.net/2020/02/03/HqX1ytmhi8RJxnD.png" alt="纯ALOHA"></p>
<h3 id="典型：CSMA-协议"><a href="#典型：CSMA-协议" class="headerlink" title="典型：CSMA 协议"></a>典型：CSMA 协议</h3><p>ALOHA 协议经常做些损人不利己的事，不考虑其它结点的感受去占用信道。<strong>载波监听多路访问协议 CSMA</strong>(carrier sense multiple access) 与之相比最大的改进在于<strong>发送帧之前，先监听信道（载波）</strong>：</p>
<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持 CSMA：以概率 P=1 <strong>一直监听</strong>信道，一旦信道空闲立刻发送这个帧</li>
<li>非坚持 CSMA：<strong>随机监听</strong>信道</li>
<li>P-坚持 CSMA以 概率 P 坚持监听信道，以 概率 1-p 随机监听信道</li>
</ul>
</li>
</ul>
<p>由于信号在信道上的传输延迟，冲突仍然可能发生：</p>
<p><img src="https://i.loli.net/2020/02/03/hZRAYIUpXG9q6c3.png" alt="CSDM冲突"></p>
<h3 id="典型：CSMA-CD-协议"><a href="#典型：CSMA-CD-协议" class="headerlink" title="典型：CSMA/CD 协议"></a>典型：CSMA/CD 协议</h3><p>CSMA/CD 协议是带有冲突检测的 CSMA 协议：</p>
<ul>
<li>短时间内可以检测到冲突</li>
<li>冲突后传输中止，减少信道浪费</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/OiRWNLvsruQg4a5.png" alt="CSDM/CD冲突检测"></p>
<p>最大特点：<strong>边发边听，不发不听！</strong></p>
<p>设网络带宽 R(bps)，数据帧最小长度 L<sub>min(bits)，信号传播速度 V(m/s)：</sub></p>
<p><img src="https://i.loli.net/2020/02/03/1q5hVjXolUWLFsA.png" alt="最小发送时间"></p>
<p>A 如果要检测到 B 的冲突，必须保证 L<sub>min</sub>/R &gt;= 2d<sub>max</sub>/V，如果算上路由器等耗时则是 <strong>L<sub>min</sub>/R &gt;= RTT</strong>。</p>
<h2 id="信道划分与随机访问对比"><a href="#信道划分与随机访问对比" class="headerlink" title="信道划分与随机访问对比"></a>信道划分与随机访问对比</h2><p>信道划分 MAC 协议：</p>
<ul>
<li>网络负载重时，共享信道<strong>效率高</strong>且<strong>公平</strong></li>
<li>网络负载轻时，共享信道<strong>效率低</strong></li>
</ul>
<p>随机访问 MAC 协议：</p>
<ul>
<li>网络负载轻时，共享信道<strong>效率高</strong>，单个结点可以利用全部带宽</li>
<li>网络负载重时，产生冲突开销</li>
</ul>
<h1 id="ARP-与-MAC"><a href="#ARP-与-MAC" class="headerlink" title="ARP 与 MAC"></a>ARP 与 MAC</h1><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>共 48bits，用 16 进制形式表示。用于标识局域网内一个帧从哪个接口发出，到达哪个物理相连的其他接口。每块网卡都有自己独有的 MAC 地址，如：1A-2F-BB-76-09-AD</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>地址解析协议（ARP）负责网络层 IP 地址与链路层 MAC 地址的转换。</p>
<p><strong>ARP 表</strong>：LAN 中每个 IP 结点维护一个表，存储某些 LAN 结点的 IP/Mac 地址映射关系：(IP 地址，MAC 地址，TTL)</p>
<p>例1：A 想要给<strong>同一局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中）：</p>
<ol>
<li>A <strong>广播</strong> ARP 查询分组，其中包含 B 的 IP 地址</li>
<li>B 接收 ARP 查询分组，IP 地址匹配成功，向 A 应答 B 的 MAC 地址</li>
<li>A 在自己的 ARP 表中缓存 B 的 IP-MAC 映射直至超时（超时后再次刷新）</li>
</ol>
<p>例2：A 想要给<strong>不同局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中，A 知道第一跳路由器接口的 MAC 地址）：</p>
<p><img src="https://i.loli.net/2020/02/03/6ISrl85JXjqokQC.png" alt="LAN间ARP"></p>
<ol>
<li>A 构造 IP 数据报，源 IP 地址为 A 的，目的 IP 地址为 B 的</li>
<li>A 构造链路层帧，源 MAC 地址为 A 的，目的 MAC 地址为第一跳路由器的</li>
<li>R 接收帧，提取 IP 数据报传递给上层 IP 协议，利用转发表转发 IP 数据报</li>
<li>R 创建链路层帧，源 MAC 地址为 R 出口的，目的 MAC 地址为 B 的</li>
</ol>
<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>交换机是典型的<strong>链路层设备</strong>，交换可以在多个主机间<strong>同时</strong>进行。特点有：</p>
<ul>
<li>存储、转发以太网帧</li>
<li>检验到达帧的 MAC 地址，选择性向一个或多个输出链路转发</li>
<li>利用 CSMA/CD 协议访问链路</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/TIbQX3Sf5Uc9nvB.png" alt="交换机"></p>
<p>每个交换机维护一张<strong>交换表</strong>，每个表项存放（主机 MAC 地址，到达主机的接口，时间戳）。</p>
<p>交换机通过<strong>自学习</strong>，获知到达主机的接口信息。当一个帧到达交换机时：</p>
<ol>
<li>收帧，交换机提取到帧的源 MAC 地址，将源主机的 MAC 地址与接口信息记录到交换表中</li>
<li>利用目的 MAC 地址检索交换表<ul>
<li>检索成功：如果目的主机与源主机处于同一网段（有相同的交换机接口）则丢弃帧；否则将帧转发到相应接口</li>
<li>检索失败：洪泛（向除了接收接口之外所有接口转发）</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/02/03/gPpzCavur2m91bk.png" alt="组织机构网络"></p>
<h2 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h2><p>两者均为存储、转发设备：</p>
<ul>
<li>路由器：网络层设备（检测网络层分组首部）</li>
<li>交换机：链路层设备（检测链路层帧首部）</li>
</ul>
<p>两者均使用转发表：</p>
<ul>
<li>路由器：利用路由算法</li>
<li>交换机：利用自学习</li>
</ul>
<h2 id="虚拟局域网（VLAN）"><a href="#虚拟局域网（VLAN）" class="headerlink" title="虚拟局域网（VLAN）"></a>虚拟局域网（VLAN）</h2><p>通过对交换机接口或 MAC 地址进行分组，在一个物理局域网上配置多个虚拟局域网。这样就避免了广播报文（DHCP、ARP 等）在不必要的机器组中传播（<strong>流量隔离</strong>）：</p>
<p><img src="https://i.loli.net/2020/02/05/cZXOdiAoawHnWI7.png" alt="接口分组"></p>
<p><img src="https://i.loli.net/2020/02/05/OJNQRrKyuDflYqm.png" alt="MAC分组"></p>
<p><strong>通过路由器在 VLAN 间转发</strong>（像独立的交换机之间）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/25/网络那些事之网络层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/25/网络那些事之网络层/" class="post-title-link" itemprop="url">网络那些事之网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-25 16:18:13" itemprop="dateCreated datePublished" datetime="2020-01-25T16:18:13+08:00">2020-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-03 14:17:28" itemprop="dateModified" datetime="2020-02-03T14:17:28+08:00">2020-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><ul>
<li>路由：确定分组从源到目的经过的路径。由<strong>路由算法</strong>确定转发表</li>
<li>转发：数据报由路由器的输入端口转移到合适的输出端口。每个路由器维护一个<strong>转发表</strong></li>
</ul>
<h1 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h1><p>在发送方主机与接收方主机之间传输数据报。属于<code>尽力而为</code>服务。</p>
<ul>
<li>无连接服务：不事先为系列分组的传输确定路径，每个分组独立确定路径。由路由器根据当前网络状态选择路径（数据报网络）</li>
<li>连接服务：首先为系列分组的传输确定路径，建立网络层逻辑连接（虚电路网络）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/28/UXhmizIdVLYHj94.png" alt="网络层服务"></p>
<h2 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h2><p>虚电路：一条从源主机到目的主机，类似于实体电路的虚拟连接路径。与实际电路最大的区别在于<strong>分组交换</strong>。</p>
<p>路径上每一个网络设备都要维护虚电路连接状态。</p>
<h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><ol>
<li>呼叫建立</li>
<li>数据传输</li>
<li>拆除呼叫</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>每条虚电路包括：</p>
<ul>
<li>源主机到目的主机的<strong>一条路径</strong></li>
<li><strong>虚电路号（VCID）</strong>，沿路每段链路一个编号</li>
<li>网络层设备（如路由器）<strong>用转发表记录经过的每条虚电路</strong></li>
</ul>
<p>沿某条虚电路传输的分组，携带对应虚电路的 VCID 而不是目的地址。</p>
<p><img src="https://i.loli.net/2020/01/25/79sQjzEGxgWF3oy.png" alt="虚电路号"></p>
<h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>特点：</p>
<ul>
<li>网络层无连接</li>
<li>每个分组携带目的地址</li>
<li>路由器根据分组目的地址转发分组（构建转发表、检索转发表、独立选路）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/kMumZIhvYcxjQod.png" alt="数据报网络"></p>
<p>路由器按照<strong>最长匹配前缀原则</strong>选择转发接口。</p>
<p>Internet 就属于数据报网络。<br>（Ipv4报文第一个字节45）</p>
<h1 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h1><p><img src="https://i.loli.net/2020/01/28/YEol4CqfpZMPDck.png" alt="IP数据报"></p>
<ul>
<li>版本号：4bits。</li>
<li>首部长度：4bits。首部字节数 = 4 * 首部长度</li>
<li>服务类型：8bits。区别不同类型 IP 数据报，只有在网络提供区分服务才有用</li>
<li>总长度：16bits。IP 分组的总字节数（20 B - 65535 B）</li>
<li>生存时间（TTL）：8bits。IP 分组在网络中可以通过的路由器数。路由器每转发一次这个值 -1</li>
<li>协议：8bits。指示 IP 分组封装的是哪个传输层协议（TCP/UDP）的数据报</li>
<li>首部校验和：16bits。对 IP 分组<strong>首部</strong>的差错检测，每次路由器转发都要重新计算</li>
<li>源 IP、目的 IP：32bits。</li>
<li>选项字段：1-40 bytes。IPv4 中<strong>通常不存在</strong>这个字段。</li>
<li>填充：0-3 bytes。补齐长度，保证首部长度是 4bytes 的倍数。</li>
</ul>
<p>IPv4 数据报首部长度通常为 20 bytes（5 行，每行 4bytes），第一个字节典型值为 45（版本号 4，首部长度 5）。</p>
<h2 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h2><p>最大传输单元（MTU）：<strong>链路层</strong>数据帧可封装的字节数的上限。不同链路的 MTU 可能不同。</p>
<p>为了解决不同链路之间 MTU 不同问题，IP 分组需要进行<strong>分片</strong>。IP 分片到达<strong>目的主机</strong>后进行<strong>重组</strong>。如果传输过程中个别分组丢失导致重组失败，目的主机直接<strong>丢弃</strong>已接收分组。</p>
<p>IP 首部相关字段参与标识分片与确定分片顺序：总长度、标识、标志位、片偏移。</p>
<ul>
<li>标识：16bits。标识一个 IP 分组。IP 协议利用一个计数器，每产生一个 IP 分组计数器 +1，作为该分组的表示。</li>
<li>标志位：3bits。保留 + DF(Don’t Fragment) + MF(More Fragment)<br><img src="https://i.loli.net/2020/01/28/JDLmZTzw6kbp3tq.png" alt="标志位格式"></li>
<li>片偏移：13bits。一个分片封装源 IP 分组数据的相对偏移量。偏移字节数 = 8 * 片偏移</li>
</ul>
<p>假设 IP 分组总长度 L，链路 MTU 为 M。若 L &gt; M 且 DF = 0，则需要分片。分片时每个分片的标识复制原 IP 分组的标识。除最后一个分片，其余分片均为 MTU 允许的最大分片且数据大小为 8 的倍数。</p>
<h2 id="IP-编址"><a href="#IP-编址" class="headerlink" title="IP 编址"></a>IP 编址</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>一共 32 bits，标识主机、路由器的<strong>接口</strong>。</p>
<h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p>IP 地址 = 网络号（高比特位） + 主机号（低比特位）。相同网络号组成的网络称为<strong>IP 子网</strong>。转发表只记录<strong>子网地址</strong>。</p>
<p>IP 子网中的设备可以不跨越路由器彼此物理联通。</p>
<p><img src="https://i.loli.net/2020/01/29/wbMGcL2HjV3qKTO.png" alt="IP 子网"></p>
<h4 id="有类-IP-地址"><a href="#有类-IP-地址" class="headerlink" title="有类 IP 地址"></a>有类 IP 地址</h4><p><img src="https://i.loli.net/2020/01/29/hGEr5QJgxKwjLTb.png" alt="有类编址"></p>
<p>A 类网络数少，每个网络内主机数多；C 类网络数多，每个网络内主机数少。</p>
<p>D 类、E 类不划分网络号和主机号，D 类用于多播，E 类暂不使用。</p>
<h4 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h4><p>私有地址只用于子网内部，在公共 Internet 上无效。</p>
<p><img src="https://i.loli.net/2020/01/29/o5EFlHrysNKYw4X.png" alt="私有地址"></p>
<h4 id="特殊-IP-地址"><a href="#特殊-IP-地址" class="headerlink" title="特殊 IP 地址"></a>特殊 IP 地址</h4><p><img src="https://i.loli.net/2020/01/29/PktSwAIXfhDiHGd.png" alt="特殊 IP"></p>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>IP 地址 = 网络号（高比特位） + 子网号（部分原主机号高比特位） + 主机号（低比特位）</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>用途：表明一个 IP 地址所处子网的子网号。</p>
<p>取值： 32 bits。IP 地址的网络号、子网号全取 1，主机号全取 0。</p>
<p>例：A 网默认子网掩码 255.0.0.0；B 类默认子网掩码 255.255.0.0；C 类默认子网掩码 255.255.255.0；3 位子网号的 B 类子网掩码 255.255.224.0。</p>
<p><strong>“子网地址 + 子网掩码”确定子网大小！</strong></p>
<p>将 IP 分组目的 IP 地址与子网掩码<strong>按位与</strong>运算，得到<strong>子网地址</strong>。</p>
<h4 id="CIDR-Classless-InterDomain-Routing"><a href="#CIDR-Classless-InterDomain-Routing" class="headerlink" title="CIDR(Classless InterDomain Routing)"></a>CIDR(Classless InterDomain Routing)</h4><p>消除传统 A、B、C 类地址界限。网络号与主机号组成网络前缀，前缀可以任意长度。</p>
<p>融合子网地址与子网掩码，方便子网划分。无类地址格式：a.b.c.d/x，x 为前缀长度。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6 数据报格式：</p>
<ul>
<li>固定长度为 40bytes 的<strong>基本首部</strong></li>
<li>不允许分片</li>
</ul>
<p><img src="https://i.loli.net/2020/01/30/b1QmZhWnNd94vFs.png" alt="IPv6格式"></p>
<ul>
<li>流标签：24bits。表示同一“流”中的数据报。流：源主机到目的主机的所有 IPv6 数据报</li>
<li>载荷长度：16 bits。</li>
<li>下一首部：8bits。指向第一个扩展首部，如果扩展首部不存在则指向传输层报文首部</li>
<li>跳步限制：8bits。报文生存时间</li>
</ul>
<h4 id="IPv6-地址形式"><a href="#IPv6-地址形式" class="headerlink" title="IPv6 地址形式"></a>IPv6 地址形式</h4><p>一共 128 bits。划分为 8 组，每组 12 bits，以 16 进制表示。如：<code>1080:0:0:0:8:800:200C:417A</code>，当中间出现多个连续的 0，可以使用压缩形式：<code>1080::8:800:200C:417A</code>。</p>
<p><strong>IPv6 不再使用掩码！</strong>，统一以 CIDR 形式表示网络大小。</p>
<h4 id="相比-IPv4-的改变"><a href="#相比-IPv4-的改变" class="headerlink" title="相比 IPv4 的改变"></a>相比 IPv4 的改变</h4><ul>
<li><strong>检验和</strong>：彻底移除，每跳处理时间大大减少。</li>
<li><strong>选项</strong>：从基本首部移出变为可选，路由器转发时间减少。</li>
</ul>
<h2 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h2><p>主机从 DHCP 服务器动态获取 IP 地址、子网掩码、默认网关、DNS 服务器名称与地址等信息。</p>
<p><img src="https://i.loli.net/2020/01/29/Y1FasAxPQzDW8Id.png" alt="DHCP"></p>
<p>DHCP 协议在<strong>应用层</strong>实现：</p>
<ul>
<li>请求报文封装到 <strong>UDP</strong> 数据报中</li>
<li>IP 广播</li>
<li>链路层广播</li>
</ul>
<h2 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h2><p>多个私有 IP 地址组成的内网通过 NAT 转换成统一的公有 IP 地址与外网通信。</p>
<p>优势：</p>
<ul>
<li>只向 ISP 申请一个 IP 地址</li>
<li>本地设备变更 IP 地址对外网是透明的</li>
<li>变更 ISP 时，无需修改内网设备的 IP 地址</li>
<li>内网设备对外网不可见（安全）</li>
</ul>
<p>实现：</p>
<ul>
<li>替换：利用（NAT IP 地址，新端口号）替换每个<strong>外出 IP 数据报</strong>的（源 IP 地址，源端口号）</li>
<li>记录：将每对（NAT IP 地址，新端口号）与（源 IP 地址，源端口号）的替换信息存储到 <strong>NAT 转换表</strong> 中</li>
<li>替换：根据 NAT 转换表，利用（源 IP 地址，源端口号）替换每个<strong>进入内网 IP 数据报</strong>的（目的 IP 地址，目的端口号），即（NAT IP 地址，新端口号）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/29/ZU9wXMSGixCm1Kf.png" alt="NAT过程"></p>
<h3 id="NAT-穿透"><a href="#NAT-穿透" class="headerlink" title="NAT 穿透"></a>NAT 穿透</h3><ul>
<li>端口转发：配置路由器，将外部客户对特定端口的请求转发给特定内部服务器</li>
<li>中继：内、外部客户分别与中继服务器建立连接。中继服务器桥接两个连接的分组（skype、frp 等应用都基于此）<br><img src="https://i.loli.net/2020/01/30/7BtAgQ8hsUYOklC.png" alt="中继"></li>
</ul>
<h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p>当 IP 数据报传输出错<strong>被丢弃</strong>时，路由器向源主机发送 ICMP 报文。</p>
<p>功能：</p>
<ul>
<li>异常报告</li>
<li>网络探询</li>
</ul>
<p>两类 ICMP 报文：</p>
<ul>
<li>差错报告报文（5 种）：<ul>
<li>目的不可达</li>
<li>源抑制：路由器发现网络拥塞，提示要降低发送速率</li>
<li>超时：TTL 超时</li>
<li>参数错误：路由器发现分组某些字段有问题</li>
<li>重定向：路由器发现这个分组不应该由它转发</li>
</ul>
</li>
<li>网络探询报文（2 种）：<ul>
<li>回声请求与应答报文。ping 基于此</li>
<li>时间戳请求与应答报文：请求获得时间戳</li>
</ul>
</li>
</ul>
<p>ICMP 报文封装到 IP 数据报中传输：<br><img src="https://i.loli.net/2020/01/30/32BVGCpILAkHbdU.png" alt="ICMP格式"></p>
<p>ICMP 报文封装了被丢弃的差错 IP 数据报的首部和前 8bytes 数据（这 8 bytes 通常为 UDP 首部或 TCP 部分首部）：<br><img src="https://i.loli.net/2020/01/30/rIVjqRGvF5Hc1N8.png" alt="ICMP数据部分"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">路边的土豆</p>
  <div class="site-description" itemprop="description">高山仰止，景行行止。虽不能至，心向往之。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">路边的土豆</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
