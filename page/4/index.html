<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    精神的壳</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="alternate" href="/atom.xml" title="精神的壳" type="application/atom+xml">
</head></html>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">精神的壳</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="精神的壳"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-Java程序设计——继承与多态" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/15/Java程序设计——继承与多态/">Java基础—继承与多态</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/15/Java程序设计——继承与多态/" class="article-date">
  <time datetime="2018-06-15T08:23:40.000Z" itemprop="datePublished">2018-06-15</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>修饰符<code>extends</code>表示继承，子类会继承超类的域和方法。例如子类Manager继承超类Employee：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加新的域或方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h1><p>想要访问超类的私域，需要使用修饰符<code>super</code>，用 <code>super</code> 代表超类。如：<code>重写</code>Manager的getsalary方法为基本工资+奖金。而salsry是private的，只有Employee类的方法才能访问。要获得基本工资必须通过调用超类getsalary方法。为了区别这两个方法，超类的方法表示为<code>super.funcname([args])</code>的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = bonus + <span class="keyword">super</span>.getsalary();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型</strong>。<br><strong>覆盖方法时，子类方法可见性不能低于超类。如果超类方法是public，那么覆盖方法也是public</strong></p>
<h1 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h1><p>由于子类不能访问超类的私有域，所以必须在子类构造器中利用超类的构造器对超类私有域进行初始化。通过关键字<code>super</code>实现对超类构造器的调用。</p>
<p><strong><code>super</code>调用构造器语句必须是子类构造器的第一条语句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bonus;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String aName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aName);</span><br><span class="line">        <span class="keyword">this</span>.bonus = <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法调用与多态"><a href="#方法调用与多态" class="headerlink" title="方法调用与多态"></a>方法调用与多态</h1><p><strong>一个被定义为指向超类的变量可以指向子类，反之行不通</strong>。一个变量对象可以指向多种实际类型的现象被称为<code>多态</code>，在运行时能自动选择调用哪个方法的现象称为<code>动态绑定</code>。对于private、static、final方法，编译器可以准确地知道应该调用哪个方法，称为<code>静态绑定</code></p>
<h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>假设要调用x.f(args)。其中x为隐式参数，声明为类C的一个对象，下面是调用过程描述：</p>
<ol>
<li>编译器查看对象的声明类型和方法名。可能存在多个名字为f，但参数类型不一样的方法。编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。<em>至此编译器已获得所有可能被调用的候选方法</em></li>
<li>编译器查看调用方法是提供的参数类型。如果所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<code>重载解析</code>。由于存在类型转换，所以该过程也遵循“相似原则”，形参类型与实参匹配度最高的优先。<em>至此编译器已获得需要调用的方法名字和参数类型，即方法签名</em></li>
<li>在jvm创建的<code>方法表</code>中搜索相应的方法。每次调用都要进行搜索，开销太大。jvm创建了一张方法表，里面存放着方法签名与实际调用方法的映射关系。</li>
</ol>
<h1 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h1><p>不允许扩展的类被称为<code>final类</code>。如果定义类的时候用了<code>final</code>修饰符就表明这个类是final类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类中的方法也可以被声明为<code>final</code>。如果这样做子类就不能覆盖这个方法（final类的所有方法默认为final方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将方法或类定义为<code>final</code>最大的好处是防止其在子类中被改变含义。</p>
<h1 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h1><p>最好将类中的域标记为<code>private</code>，任何声明为<code>private</code>的内容对其他类都是不可见的，即使是子类也一样。如果希望子类能够访问超类的私有域或方法，可以用修饰符：<code>protected</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> salary;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getsalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java的4种可见性修饰符"><a href="#Java的4种可见性修饰符" class="headerlink" title="Java的4种可见性修饰符"></a>Java的4种可见性修饰符</h1><p>下面是Java用于控制可见性的4种修饰符：  </p>
<ol>
<li>仅对本类可见——private</li>
<li>对所有类可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>仅对本包可见——默认，不需要修饰符</li>
</ol>
<h1 id="对象包装器"><a href="#对象包装器" class="headerlink" title="对象包装器"></a>对象包装器</h1><p>Java不是完全的面向对象语言，其基本类型：boolean、char、short、int、long、float、double的值都不是对象。而这些基本类型都有与之对应的类。如int对应Integer，char对应Character，void对应Void…对象包装类包装的值都是不变的。</p>
<p>要定义一个整形数组列表，只要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>此时，调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>编译器将会将其视为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>这种行为称为<code>自动装箱</code>，与之对应的还有<code>自动拆箱</code>。手动拆箱的方法为<code>Integer.parseInt(Integer obj)</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/15/Java程序设计——继承与多态/" data-id="ckoqt9nsf0007b0upt2y77tuc" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Java程序设计——包" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/15/Java程序设计——包/">Java基础—包</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/15/Java程序设计——包/" class="article-date">
  <time datetime="2018-06-15T01:46:18.000Z" itemprop="datePublished">2018-06-15</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>Java 允许使用包（package）将类组织起来，使用包的主要原因是确保类名的唯一性。如果有两个名字相同的类，只要把它们放在不同的包中就不会有影响。</p>
<p>从编译器（compiler）的角度看，嵌套的包之间没有任何关系。例如java.util包与 java.util 包毫无关系，每一个都拥有独立的类集合。</p>
<p>当编译一个 .java 文件（即一个编译单元）时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与 .java 文件中每个类的名称相同，只是多了一个后缀名 .class。因此在编译少量 .java 文件之后，会得到大量的 .class 文件。每一个 .java 文件编译以后都会有一个 public 类，以及任意数量的非 public 类。因此每个 .java 文件都是一个构件，如果希望许许多多的这样的构件从属于同一个群组，就可以在每一个 .java 文件中使用关键字 package。而这个群组就是一个类库。</p>
<p>就表示你在声明该编译单元是名为 fruit 的类库的一部分，或者换句话说，你正在声明该编译单元中的 public 类名称是位于 fruit 名称的保护伞下，由 fruit 名称罩着。任何想要使用该 public 类名称的人都必须指定全名或者与 fruit 结合使用关键字 import。</p>
<h1 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h1><p>一个类、方法或变量如果没有指定 <code>private</code> 或 <code>public</code>，则可以被同一个包中的所有方法访问（如非公）。</p>
<h1 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h1><p>要想将类放入包中，就必须将包的名字放在源文件的开头。包中定义类的代码之前。使用关键字 <code>package</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名为Employee.java，位于目录com/qiuyueqy/learnjava下</span></span><br><span class="line"><span class="keyword">package</span> com.qiuyueqy.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表明编译单元位于 com.qiuyueqy.learnjava 的保护伞下，任何想要使用该 public 类的人必须指定全名或使用修饰符 <code>import</code></p>
<p>如果没有在源文件中放置 package 语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包</p>
<p><strong>编译器对文件（以 .java 为扩展名）进行操作，而java解释器加载类（以. class 为扩展名）</strong></p>
<h2 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h2><p>一个类可以使用所属包中所有的类，一起其他包的公有类。可以用两种方式访问其他包的公有类：</p>
<ul>
<li>在类名前加上完整的包名<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.time.LocalDate date = <span class="keyword">new</span> java.time.LoalcDate.now();</span><br><span class="line">``` </span><br><span class="line">- 通过关键字`<span class="keyword">import</span>`导入，**`<span class="keyword">import</span>`必须在`<span class="keyword">package</span>`之后**</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.qiuyueqy.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p><code>import</code>语句不仅可以导入类，还可以导入类的静态方法和静态域：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入System类的静态方法和静态域</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Systme.*;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以使用System类的静态方法和域，而不用加前缀：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out.println(<span class="string">"Hello World!"</span>); <span class="comment">// System.out.println()</span></span><br><span class="line">exit(<span class="number">0</span>); <span class="comment">// System.exit()</span></span><br></pre></td></tr></table></figure></p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>javac 编译器要查询一个编译单元，会先从当前包开始，然后查询所有 <code>import</code> 语句，确定<code>import</code>语句导入的包中是否包含所需要的类。</p>
<p>java 虚拟机（jvm）查询类文件时，它首先在 jre/lib 和 jre/lib/ext 目录下的归档文件中所存放的系统类文件里找，如果找不到再从环境变量 CLASSPATH（可以通过操作系统来设置）里面找。CLASSPATH包含一个或多个目录，用作查找 .class 文件的根目录。从根目录开始，解释器获取包名称并将每个句点替换成反斜杠，以从 CLASSPATH 根中产生一个路径（例如，package fruit.Apple 就变成为 fruit/Apple 或 fruit/Apple 或其他，这将取决于操作系统）。得到的路径会与 CLASSPATH 中的各个不同的根目录路径相连接以获得一个完整的目录路径，解释器就在这些目录中查找与你所需要的类名称相同的 .class 文件。</p>
<p>类文件默认与 java 文件处于同一位置，但也可以存储在 jar（java 归档）文件中。jar 文件是多个压缩形式的类文件和子目录的集合。通过使用 jar 文件可以使类被多个程序共享。为了达到这个目的，需要做到以下几点：</p>
<ol>
<li>把类放到一个目录中。这个目录是一个树状结构的基目录。例如：<strong>如果希望将com.qiuyueqy.learnjava类添加到其中，这个 learnjava.class 类文件就必须位于子目录 /home/user/classdir/com/qiuyueqy中</strong></li>
<li>将jar文件放在非类路径中，如：/home/user/archives</li>
<li>设置类路径（class path）。<strong>类路径是所有包含类文件的路径的集合</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/user/classdir:.:/home/user/archives/archives.jar // Linux下</span><br><span class="line"></span><br><span class="line">C:\classdir;.;C:\archives\archives.jar // windows下</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>类路径包括：</p>
<ul>
<li>基目录: 如 /home/user/classdir和C:\classdir</li>
<li>当前目录: .</li>
<li>jar文件： 如 /home/user/archives/archives.jar 或 C:\archives\archives.jar</li>
</ul>
<h2 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h2><p>最好通过<code>-classpath</code>或<code>-cp</code>选项指定类路径，例如要执行Employee.class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath /home/user/classdir:.:/home/user/archives/archives.jar Employee</span><br></pre></td></tr></table></figure></p>
<p>也可以通过设置环境变量<code>CLASSPAHT</code>。默认CLASSPATH为<code>.</code>，改为我们需要的路径集合:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set CLASSPATH=C:\classdir;.;C:\archives\archives.jar //windows下</span><br><span class="line"></span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/home/user/archives/archives.jar // Linux下</span><br></pre></td></tr></table></figure></p>
<p>这样在shell退出前CLASSPATH变量都有效</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/15/Java程序设计——包/" data-id="ckoqt9nse0006b0upbnllx6em" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Java程序设计接口与类" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/13/Java程序设计接口与类/">Java基础—类与接口</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/13/Java程序设计接口与类/" class="article-date">
  <time datetime="2018-06-13T12:14:15.000Z" itemprop="datePublished">2018-06-13</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h1><p><strong>Java中，只有基本类型(primitive types)不是对象，例如number，string和boolean</strong>。</p>
<p>首先要清楚：对象与对象变量是不一样的。对象变量只是对对象的一个引用。</p>
<p>想使用对象变量，首先要构造对象并指定其初始状态。<br>在定义类时，使用<code>构造器</code>指出如何初始化这个类，在构造一个新实例时，构造器会运行，将实例域初始化为所希望的状态。<strong>构造器是一种特殊的方法，没有返回值</strong>。构造器的名字与类名相同。<strong>一个类有一个或多个构造器方法</strong>。不要在构造器中定义与实例域重名的局部变量，否则编译器会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String colour;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个就是构造器，方法名与类名相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String c, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colour = c;</span><br><span class="line">        <span class="keyword">this</span>.sex = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要构造一个对象，需要在构造器前面加上<code>new</code>操作符：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">"绿色"</span>, <span class="number">0</span>) <span class="comment">// 这里的Bird应该理解为调用Bird类的构造器，构造器前加上new操作符</span></span><br></pre></td></tr></table></figure></p>
<p>bird是一个对象变量，并没有实际包含一个对象，而仅仅引用一个对象。<strong>任何对象变量的值都是对存储在另一个地方的一个对象的引用</strong></p>
<h1 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h1><p>对于每个特定的类实例，都有一组特定的实例域值，这些值的集合就是这个对象的<code>当前状态</code>。<br>实现封装的关键是绝不能让类中的方法直接地访问其他类的实例域。程序仅能通过对象的方法与对象的实例域进行交互。对象的方法会改变原对象的状态，称之为更改器方法。只访问实例域而不改变原对象状态的方法，称之为访问器方法。</p>
<p>访问器方法不要返回可变对象，否则获取这个对象后通过调用可变对象的更改器方法会破坏封装性！</p>
<h1 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h1><p>关键字<code>public</code>修饰的类称为共有类。<strong>在一个.java源文件（编译单元）中，只能有一个共有类，类名与文件名相同</strong>。可以有多个非公有类。包之外的世界是无法看见这些非公有类的，因为它们不是public类，而且它们主要用来为公有类提供支持。</p>
<p>关键字<code>public</code>修饰的方法、字段意味着任何类的任何方法都可以通过点操作调用这些方法和字段，而<code>private</code>确保只有自身类可以访问这些实例域或方法。（<strong>同属一个类的实例可以互相访问访问私有域</strong>）</p>
<p>可以把实例域定义为<code>final</code>。构造对象时必须要初始化这样的域（构造器之前<br>），并且在后面的操作中不能再对它进行改变。</p>
<h1 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h1><p>如果将域定义为<code>static</code>，每个类中只有一个这样的域。而每个对象对于所有的实例域却都有自己的一份拷贝。这样就把实例域与静态域区分开来：每个实例有自己的实例域，而各个实例共享一个静态域。</p>
<h1 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h1><p>例如，在Math类中定义圆周率：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265758</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中，可以使用<code>Math.PI</code>获取这个常量。<br>如果关键字<code>static</code>被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math对象都有他自己的一份PI拷贝<br>每个类对象都可以对公有域进行修改，所以最好不要把域设计成<code>public</code>。然而共有常量（即final域）却没有这个问题，因为PI被声明为<code>final</code>，不允许再修改它的值。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法封装了一系列语句所描述的运算。方法需要参数（某种数据类型的值）并根据参数计算出某种数据类型的返回值（例如数学函数的结果）或者产生某种副作用（例如main函数）</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有<code>this</code>参数的方法。静态方法不能访问实例域，因为它不能操作对象，但是静态方法可以访问自身类的静态域。一下两种情况适合用静态方法：</p>
<ol>
<li>一个方法不需要访问对象状态，其所需要的参数都是通过显示参数提供</li>
<li>一个方法只需要访问类的静态域</li>
</ol>
<p>静态方法还有一种常见用途就是用静态工厂方法构造对象，而不是使用<code>new</code>构造符。</p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p>调用静态方法不需要使用对象，同理，main方法也是静态方法。<br>main方法不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象<br>每个类可以有一个main方法，这是常用于类的单元测试的技巧，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">int</span> a, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">        <span class="keyword">this</span>.salary = s;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">"Mike"</span>, <span class="number">21</span>, <span class="number">2354</span>);</span><br><span class="line">        e.raiseSalary(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想独立测试Employee类，只需执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Employee</span><br></pre></td></tr></table></figure></p>
<p>如果Employee类是一个Application的一部分，可以用如下命令执行程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Application</span><br></pre></td></tr></table></figure></p>
<p>此时Employee中的main方法不会被执行</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>java的对象引用是<code>按值传递</code>而不是<code>引用调用</code>。<strong>方法得到的是所有参数值得一个拷贝，而不是指针</strong>。方法不能修改传递给它的任何参数变量的内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> Salary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Salary = Salary * <span class="number">3</span>; <span class="comment">// 这不会对Salary对应的实参造成任何影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，改变对象参数状态不是一件难事。<strong>由于java得到的是对象引用的拷贝，而对象引用及其拷贝都会指向同一个对象</strong>，所以可以通过改变对象引用拷贝达到修改对象参数的目的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(Employee e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">3</span>; <span class="comment">// 这会修改Employee实例的Salary域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下：</p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象（即无法改变实参的引用对象，这点也是由按值传递决定的）</li>
</ol>
<h1 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h1><p>Java提供了多种编写构造器的机制</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法（这个过程称为重载解析）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String aName, <span class="keyword">int</span> aid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = aName;</span><br><span class="line">        <span class="keyword">this</span>.id = aid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> aid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Employee"</span>;</span><br><span class="line">        <span class="keyword">this</span>.id = aid;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java允许重载任何方法，而不仅仅是构造器方法。因此，要完整地表述一个方法，需要指出方法名以及参数类型。这叫做方法的<strong>签名（signature）</strong>。例如：String类有4个称为<code>indexOf</code>的公有方法，它们的签名是：</p>
<ul>
<li>indexOf(int)</li>
<li>indexOf(int, int)</li>
<li>indexOf(String)</li>
<li>indexOf(String, int)</li>
</ul>
<p>返回类型不是方法签名的一部分。也就是说：<strong>不能有两个名字相同，参数类型相同，返回值类型却不同的方法</strong></p>
<h2 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h2><p>如果在构造器中没有显式地给域赋初值，那么就会自动地赋为默认值：数值为0，布尔值为false，对象引用为null。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，而不一定要明确初始化域。</p>
<h2 id="无参数构造器"><a href="#无参数构造器" class="headerlink" title="无参数构造器"></a>无参数构造器</h2><p>很多类都包含一个无参数的构造函数，对象由无参数的构造函数创建时，其状态会设置为适当的默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary = <span class="number">5000</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在编写一个类时没有编写构造器，那么系统会提供一个无参数构造器，该构造器将所有实例域设置为默认值：数值为0，布尔值为false，引用对象为null</p>
<h2 id="显示域初始化"><a href="#显示域初始化" class="headerlink" title="显示域初始化"></a>显示域初始化</h2><p>通过重载类的构造器方法啊，可以采用多种形式设置类的实例域的初始化方法，确保无论怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。</p>
<p>可以在类定义中直接将一个值赋给任何域。<strong>在执行构造器之前，先执行赋值操作</strong>。初始值不一定是常量值，也可以调用方法对域进行初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h2><p>关键字<code>this</code>引用方法的隐式参数。然而，这个关键字还有另一个含义：<br>如果构造器的第一个语句形如：<code>this(...)</code>，这个构造器将调用同一个类的另一个构造器，这样对公共的构造器代码部分只编写一次即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用另一构造器 Employee(String aName, double aSalary)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Employee #"</span> + nextId, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对象初始化块"><a href="#对象初始化块" class="headerlink" title="对象初始化块"></a>对象初始化块</h2><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器。</p>
<p><strong>下面是调用构造器的具体处理步骤：</strong></p>
<ol>
<li>所有数据域初始化为默认值（0，false，null）</li>
<li>按照在类声明中出现的次序，依次执行所有的初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行构造器主体</li>
</ol>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的内部还可以定义内部类，内部类又分为静态内部类和非静态内部类：</p>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>非静态内部类可以访问外部类的私有属性。非静态内部类实例必须依赖于外部类实例而存在，语法为：<code>new outerclass().new innerclass()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Item item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>关键字<code>static</code>修饰的内部类为静态内部类，可以没有外部类实例。语法为；<code>new outerclass.innerclass()</code></p>
<p>静态内部类不可以访问外部类的私有属性和方法，可以访问外部类私有静态成员:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BattleWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"战斗胜利！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakTower</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hp = <span class="number">50000</span>;</span><br><span class="line">        <span class="keyword">if</span> (hp &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            Hero.BattleWin();</span><br><span class="line">            <span class="comment">// 静态内部类无法访问外部类实例属性。方法</span></span><br><span class="line">            System.out.println(name + <span class="string">"胜利！"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><p>最常见的关系有：</p>
<ol>
<li>依赖(deependence)。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应尽可能减少将相互依赖的类，如果类A不依赖于B，那么B的任何改变对A没有影响。这称为<code>让类之间的耦合度最小</code></li>
<li>聚合(aggregation)。意味着一个类的对象包含另一个类的对象。如订单类对象包含商品类对象</li>
<li>继承(inheritance)。继承是对象的一种扩展，子类拥有父类的全部方法和属性</li>
</ol>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object类时Java中所有类的始祖，Java中每个类都是由它扩展而来的。如果没有明确指出超类，Object类就是这个类的超类。</p>
<p>可以使用Object类型的变量引用任何类型的变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Employee(<span class="string">"David"</span>, <span class="number">4500</span>);</span><br></pre></td></tr></table></figure></p>
<p>不过，Object类型变量只是各种值的持有者，想要对其中的内容进行操作需要进行类型转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e = (Employee) obj;</span><br></pre></td></tr></table></figure></p>
<p>所有数组，不管是基本类型数组还是对象数组，都扩展了Object类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">Emplpyee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">obj = staff; <span class="comment">// OK</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类中的equals方法用于检测一个对象是否等于另一个对象。两个对象是否相等是通过所属类及实例域状态决定的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查两个类是否引用同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果形参为null返回false</span></span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个类所属类不相等，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想在我们知道otherObject是一个Employee类</span></span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        <span class="comment">// 检查实例域是否相等</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, other.name)</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.salary == other.salary</span><br><span class="line">        <span class="comment">// 可以使用this.name.equals(other.name)，为了防止this.name为null最好使用Objects.equals()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域相等，就需要比较子类中的域：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// super.equals检测otherObject与超类是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manager other = (Manager) otherObject;</span><br><span class="line">        <span class="comment">// 比较子类中的域</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bonus == other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出编写完美equals方法的步骤：</p>
<ol>
<li>显示参数命名为otherObject，稍后将它转化成一个叫做other的变量</li>
<li><p>检测this与otherObject是否引用同一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测otherObject是否为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较this与otherObject是否属于同一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将otherObject转化为相应类型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName other = (ClassName) otherObject</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较实例域，用<code>==</code>比较基本类型域，<code>Objects.equals()</code>比较对象域(对于数组类型的域使用<code>Arrays.equals</code>方法判断是否相等)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1</span><br><span class="line">    &amp;&amp; Objects.equals(<span class="keyword">this</span>.field2, other.field2)</span><br><span class="line">    &amp;&amp; Arrays.equals(<span class="keyword">this</span>.field3, other.field3)</span><br><span class="line">    &amp;&amp; ...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><p>Object中的hashCode返回由对象导出的整型值。<em>在定义类时如果没有覆盖hashCode方法，会根据对象的内存地址产生一个散列码。如果定义了hashCode，则由对象内容导出一个散列码</em>。</p>
<p>获得一个对象的散列码可以用<code>Objects.hashCode</code>方法，获得基本类型的散列码可以打包后调用hashCode方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double.hashCode(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>Object类的toString方法返回表示对象值的字符串。一般表示形式为<code>类名[域值]</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Point[x=<span class="number">10</span>,y=<span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<p>当对象与字符串通过<code>+</code>操作符连接起来，Java编译器就会自动地调用toString方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">String message = <span class="string">"当前位置为"</span> + p;</span><br></pre></td></tr></table></figure></p>
<p>如果x是一个对象，调用System.out.println(x)，println方法会自动调用x.toString()。<br>Object类定义了toString方法用来打印对象所属的类名和散列码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.out) <span class="comment">// 输入java.io.PrintStream@2f6684</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为PrintStream类没有覆盖toString方法。数组继承了这一特性，打印数组中的元素使用<code>Arrays.toString</code>方法</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（interface）主要用来描述类具有什么功能，而不给出每个功能的具体实现。这种做法有利于实现类的扩展，因为Java不支持多继承。接口还在有利于多态，因为虽然接口无法构造对象，却能声明接口的变量，且这个变量能引用所有实现了该接口的类对象。</p>
<h2 id="构造一个接口"><a href="#构造一个接口" class="headerlink" title="构造一个接口"></a>构造一个接口</h2><p>构造接口与构造类相似，只是将<code>class</code>改为<code>interface</code>，此外，还可以将接口定义为泛型，接受类型参数，这样会提高接口的可用性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compareable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compareable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口内声明了一些方法，绝不应含有实例域，而实现方法和提供实例域的任务都由实现接口的那个类完成。接口中的方法自动是<code>public</code>，在类中定义这些方法时也应使用<code>public</code></p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>为了让类实现接口，有两个步骤：</p>
<ol>
<li>让类声明为实现给定的接口</li>
<li>对接口中所有方法进行定义</li>
</ol>
<p>将类声明为实现某些接口，使用关键字<code>implement</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">implement</span> <span class="title">Compareable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">implement</span> <span class="title">Compareable</span>&lt;<span class="title">Employee</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口也可以继承，子接口有父接口中声明的方法和常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">runable</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">speed</span><span class="params">()</span></span>; <span class="comment">// 实现runable的类必须实现time()和speed()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p>用<code>default</code>关键字可以在接口中声明方法时进行简单的定义，但不能涉及实例域因为接口没有实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MouseListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">mouseClcked</span><span class="params">(MouseEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鼠标点击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此一来，实现这个接口的类可以不覆盖这个默认方法而具有默认方法提供的功能。</p>
<h3 id="默认方法冲突"><a href="#默认方法冲突" class="headerlink" title="默认方法冲突"></a>默认方法冲突</h3><ol>
<li>如果接口的默认方法名与超类的方法名冲突了，遵循<code>超类优先</code>原则，即接口提供的默认方法会被忽略。</li>
<li><p>如果多个接口提供的默认方法名冲突，由类决定使用哪个接口的默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person和Named都有默认方法getName()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implement</span> <span class="title">Person</span>, <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果多个接口都没有提供默认方法，那么要么在类中覆盖这个方法，要么这是一个抽象类，把这个方法定义为抽象方法由子类去实现  </p>
</li>
</ol>
<h2 id="接口Comparable与Comparator"><a href="#接口Comparable与Comparator" class="headerlink" title="接口Comparable与Comparator"></a>接口Comparable与Comparator</h2><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口是函数式接口，此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个类若实现了Comparable接口，意味着这个类支持排序。实现了Comparable接口的类的对象的数组或列表可以使用<code>Arrays.sort</code>或<code>Collections.sort</code>进行自动排序。</p>
<h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p>实现了Comparator接口的类是一个比较器。对某些没有实现Comparable接口的类进行排序，只要提供一个比较器告诉排序方法按照什么规则进行排序就可以了，该接口的定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>实现Comparator接口的类一定要实现compare方法，而不一定要实现equals方法。<br>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p>
<h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p>
<p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p>
<p>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。<br>（二者的使用实例见：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html" target="_blank" rel="noopener">参考博客</a>）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/13/Java程序设计接口与类/" data-id="ckoqt9nwb002tb0up61bap7m3" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-网络那些事应用层" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/07/网络那些事应用层/">网络那些事之应用层</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/07/网络那些事应用层/" class="article-date">
  <time datetime="2018-06-07T13:53:17.000Z" itemprop="datePublished">2018-06-07</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="网络应用结构"><a href="#网络应用结构" class="headerlink" title="网络应用结构"></a>网络应用结构</h1><ul>
<li>客户机/服务器结构（C/S）</li>
<li>点对点结构（P2P）</li>
<li>混合结构（综合 C/S 与 P2P）</li>
</ul>
<p>应用层是程序员最常接触的层次，应当非常熟悉。</p>
<h2 id="端系统间的进程通信"><a href="#端系统间的进程通信" class="headerlink" title="端系统间的进程通信"></a>端系统间的进程通信</h2><p>一个进程可以理解为运行在端系统中的的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。而在不同的端系统上，通过跨越计算机网络交换<code>报文</code>实现进程间的通信。</p>
<p>多数应用程序由通信进程对组成，每对中的两个进程互相发送报文，从一个进程向另一个进程发送报文就必须经过下面的计算机网络。进程通过一个被称为<code>套接字</code>的软件接口向网络发送报文和接受报文。<code>套接字</code>类似于一栋屋子的门，无论是要进入屋子还是离开屋子，都要进过门。<code>套接字</code>是应用层与运输层的接口。在运输层，开发者对于<code>套接字</code>几乎没有控制权，只能</p>
<ol>
<li>选择运输层协议</li>
<li>设定几个参数，如最大缓存、最大报文段长度等</li>
</ol>
<h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>套接字是一种应用编程接口（API），不同主机的应用进程间通信的抽象机制。应用进程通过套接字将数据控制权转移给操作系统，以实现信息从应用层到传输层的转换。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>每个应用进程都可能对应一个或多个套接字。为了区分不同套接字，操作系统给每个套接字绑定一个 16 位整数（0——65535），称之为<strong>端口号（port）</strong>。</p>
<p>对外标识通信端点：IP Address + port。</p>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>为了与另一个端系统通信，必须知道：</p>
<ol>
<li>另一端系统的地址</li>
<li>定义在目的端系统中的接收进程的标志符</li>
</ol>
<p>端系统地址由<code>IP地址</code>确定，而接收进程标志符由<code>端口</code>确定。</p>
<p>操作系统对内标识套接字：<strong>套接字描述符（socket descriptor）</strong>，非常类似于文件的抽象机制。每个进程有一个套接字描述符表，进程每创建一个套接字都会在表里增加一个条目，每个条目对应一个套接字数据结构指针。</p>
<p><img src="https://i.loli.net/2019/12/21/LEHvFzdNowkq6Bc.png" alt="套接字描述符表"></p>
<p>地址族（family）：不同传输协议下主机的端点形式不同，用地址族区分不同的传输协议。</p>
<p>类型（service）：区分某一传输协议下的不同协议。</p>
<p><img src="https://i.loli.net/2019/12/21/4vTABxRFnmIgh9Q.png" alt="协议类型"></p>
<h2 id="几种常见的应用层协议"><a href="#几种常见的应用层协议" class="headerlink" title="几种常见的应用层协议"></a>几种常见的应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（超文本传输协议）是 Web 的核心。在 Web 应用中，客户与服务器之间是通过 HTTP 报文进行会话的。而HTTP协议定义了报文格式与交换方式。Web 服务器实现了 HTTP 的服务器端，用于存储 Web 对象，每个对象由 url 寻址。</p>
<p><img src="https://i.loli.net/2020/01/20/9MTnkYv5yfxOL1u.png" alt="HTTP请求格式"></p>
<p><img src="https://i.loli.net/2020/01/20/StgFZXMs5GIbwYc.png" alt="HTTP响应格式"></p>
<p>HTTP 使用<code>TCP</code>作为它的支撑运输协议，默认采用<code>带流水机制的持久性连接</code>。 一次完整的<code>请求——响应</code>流程是这样的：</p>
<ol>
<li>HTTP客户端首先发起一个与服务器的 TCP 连接，一旦连接建立，该客户端进程与服务器进程就可以通过套接字接口通信。</li>
<li>客户端向它的<code>套接字</code>接口发送 HTTP 请求报文。</li>
<li>服务器收到 HTTP 请求报文并生成相应的响应报文，通过服务器的<code>套接字</code>发送响应报文。</li>
<li>客户端从<code>套接字</code>接受响应报文。</li>
<li>所有报文传输结束，关闭 TCP 连接。</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 是无状态协议，不记录客户端的历史行为，换言之对服务器而言每个 HTTP 请求都是独立的，不和历史请求有任何关系。为了辨别用户身份，维持 session，cookie 应运而生，它是一小段储存在客户端且通常经过加密的数据。</p>
<p>Cookie 在 HTTP 协议中以头部行的形式传输，由服务器设置，被客户端（通常是浏览器）保存在本地。</p>
<p><img src="https://i.loli.net/2020/01/20/wvu6zqyA9rKFDib.png" alt="Cookie原理"></p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>通过 SMTP（简单邮件传输协议）实现发送邮件。因特网电子邮件系统由 3 部分组成：</p>
<ul>
<li>用户代理。常见的邮件客户端如 Outlook 等都是用户代理，如果是通过 Web 端发送邮件，那么浏览器是用户代理。用户代理负责读写邮件、与邮件服务器交互</li>
<li>邮件服务器。通常由企业提供，如 QQ 邮箱的服务器<code>smtp.qq.com</code>，126 邮箱服务器<code>smtp.126.com</code></li>
<li>SMTP。负责在邮件服务器之间发送邮件</li>
</ul>
<p>一个典型的发送邮件的过程是：</p>
<ol>
<li>从发送方的用户代理开始，传输到发送方的邮件服务器</li>
<li>从发送方的邮件服务器发到接收方的邮件服务器，然后被分发到接收方的邮箱中</li>
<li>接收方通过用户代理从邮箱获取邮件</li>
</ol>
<p>SMTP 是因特网电子协议中的主要应用层协议，它用 TCP 提供可靠数据传输服务。</p>
<p>SMTP 规定邮件报文首部必须包含关键字<code>From:</code>与<code>To:</code>，可以包含关键字<code>Subject:</code>。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>如果把客户向服务器发送报文比作打电话，那么服务器的IP地址是电话号码，域名是号码主人的姓名，而 DNS（Domain Name System 域名系统）就是电话簿，把姓名和电话号码联系起来。</p>
<p>DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>DNS提供的服务有：</p>
<ul>
<li>域名解析服务</li>
<li>主机别名服务</li>
<li>邮件服务器别名服务</li>
<li>负载均衡。将一个域名与多个IP地址对应起来，当客户对域名发出一个DNS请求时，每次响应都循环<br>这些IP地址的次序。由于客户总是向排在最前面的IP地址发送HTTP请求，由此实现了负载均衡。</li>
</ul>
<p>获得一个域名的 IP 地址的过程如下：</p>
<ol>
<li>浏览器把域名发送到用户主机上的DNS客户端 </li>
<li>DNS 客户端向 DNS 服务器发送一个包含主机名的请求</li>
<li>DNS 服务器通过查询相应的域名——&gt; I 地址间的映射关系，生成一个响应报文并返回</li>
<li>DNS 客户端收到响应报文，把报文中的IP地址传给浏览器</li>
</ol>
<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>多层命名服务器构成的<strong>分布式</strong>数据库。属于应用层协议，负责域名解析功能。  </p>
<h4 id="分层式层次式数据库"><a href="#分层式层次式数据库" class="headerlink" title="分层式层次式数据库"></a>分层式层次式数据库</h4><p>第一层：根域名服务器（root）</p>
<p>第二层：顶级域名服务器（top-level domain，TLD），负责 com，org，cn，jp 等</p>
<p>第三层：权威域名服务器（authoritative），负责组织域名解析，如 alibaba，baidu 等</p>
<p><img src="https://i.loli.net/2019/12/21/gXAveHhuimtyWl5.png" alt="分层结构"></p>
<p>举个例子：客户端访问 <a href="www.baidu.com">www.baidu.com</a>。</p>
<ol>
<li>向根域名服务器发送查询请求。根域名服务器返回 com 域名服务器地址。</li>
<li>向 com 域名服务器发送查询请求。com 域名服务器返回 baidu.com 域名服务器地址。</li>
<li>向 baidu.com 域名服务器发送查询请求。baidu.com 域名服务器返回 w<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 地址。</li>
</ol>
<p><strong>本地域名服务器：</strong> 不严格属于层级体系，每个 ISP 有一个本地域名服务器，是该 ISP 用户的默认域名解析服务器。作为代理将该 ISP 用户的查询转发给域名解析服务器系统。</p>
<h4 id="为什么不用采用集中式架构"><a href="#为什么不用采用集中式架构" class="headerlink" title="为什么不用采用集中式架构"></a>为什么不用采用集中式架构</h4><ul>
<li>单点失败问题</li>
<li>流量问题</li>
<li>距离问题</li>
<li>维护性问题</li>
</ul>
<p>不可伸缩！</p>
<h4 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h4><ul>
<li><p>迭代查询。用户的查询被转发到本地域名服务器上，本地域名服务器依次访问 3 层域名解析服务器系统。</p>
</li>
<li><p>递归查询。用户的查询被转发到本地域名服务器上，本地域名服务器访问根域名服务器，根域名服务器访问顶级域名服务器，顶级域名服务器访问权威域名服务器。最后的查询结果依次返回给上一层。</p>
</li>
</ul>
<h4 id="DNS-缓存与更新"><a href="#DNS-缓存与更新" class="headerlink" title="DNS 缓存与更新"></a>DNS 缓存与更新</h4><p>一段时间后，缓存条目会失效。本地域名服务器一般会缓存顶级域名服务器地址，所以根域名服务器较少被访问。</p>
<h4 id="DNS-记录与格式"><a href="#DNS-记录与格式" class="headerlink" title="DNS 记录与格式"></a>DNS 记录与格式</h4><p>DNS 记录又称资源记录（RR，Resource Record）。是一个四元组：<strong>（name，value，type，ttl）</strong>。</p>
<ul>
<li>type=A：name=主机域名，value=IP 地址。</li>
<li>type=NS：name=域（edu.cn、qiuyueqy.com），value=该域的权威域名解析服务器的主机域名。</li>
<li>type=CNAME：name=某真实域名的别名，value=真实域名。</li>
<li>type=MX：name=域（126.com，163.com）,value=与name对应的邮件服务器.</li>
</ul>
<h4 id="为什么在应用层实现"><a href="#为什么在应用层实现" class="headerlink" title="为什么在应用层实现"></a>为什么在应用层实现</h4><p>我们希望把复杂的东西尽量放在端系统实现。在应用层实现 DNS 协议有利于降低网络核心的复杂度。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>由上可知，为了获取一个DNS地址进行了很多次请求，这就影响了速度。为了加快响应速度，DNS服务器有缓存机制：在一个请求链中，当某DNS服务器接收到一个DNS回答，它能将该回答中的信息缓存到本地存储器中，类似于Web缓存器。在一段时间（默认为两天）后将缓存信息丢弃。</p>
<h4 id="DNS劫持与污染"><a href="#DNS劫持与污染" class="headerlink" title="DNS劫持与污染"></a>DNS劫持与污染</h4><p>DNS 污染是指服务器检测到用户访问特定的主机时，伪装成 DNS 服务器向用户返回错误IP地址。国内用户访问 youtube 等网站时就会遇到这种情况</p>
<p>DNS 劫持是通过劫持特定的DNS服务器，在 DNS 服务器里存放错误的缓存信息，这样 DNS 服务器就会向用户返回错误的 IP 地址</p>
<p>对于 DNS 劫持，可用采用更换默认 DNS 服务器的方式解决。而 DNS 污染只能通过修改 hosts 文件、VPN 等方式绕过服务器</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>P2P（Peer to Peer）应用的几个特点：</p>
<ul>
<li>没有服务器</li>
<li>任意端系统之间直接互联</li>
<li>节点阶段性接入Intent</li>
<li>节点可能更换IP地址</li>
</ul>
<h3 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关(gateway)"></a>网关(gateway)</h3><p>在一个局域网内互相通信是不需要用到网关的，而局域网内的接口要访问外网时，则需要把请求发送到网关上，由网关负责向外发送流量。同理，外网的信息也是通过网关再传达给内网接口</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/07/网络那些事应用层/" data-id="ckoqt9nv1001ib0up0p2qhagb" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/应用层/">应用层</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-网络那些事基本概念" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/04/网络那些事基本概念/">网络那些事之基本概念</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/04/网络那些事基本概念/" class="article-date">
  <time datetime="2018-06-04T11:31:43.000Z" itemprop="datePublished">2018-06-04</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>计算机网络是一个自治的、互联的计算机集合。</p>
<h1 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h1><p>因特网是一个世界范围的计算机网络，是“网络的网络”。由十多个第一层<code>ISP(因特网服务提供商)</code>和数十万个底层 ISP 组成。ISP 覆盖区域有所不同，有些跨越多个大洲和大洋，有些限于很小的地理区域。低层 ISP 与高层 ISP 互联，高层ISP彼此互联。</p>
<h2 id="端系统"><a href="#端系统" class="headerlink" title="端系统"></a>端系统</h2><p>所有连接到因特网的设备都称为<code>主机</code>或<code>端系统</code>。</p>
<p>端系统通过<code>通信链路</code>和<code>分组交换机</code>连接到一起。通俗的讲通信链路就是一条条光缆、网线等物理线路，不同的链路能以不同的速率传输数据，链路的传输速率单位为<code>bit/s或bps</code>，即<code>比特/秒</code>。端系统通过 ISP 接入因特网。</p>
<p>当一台端系统向另一台端系统发送数据时，发送端系统将数据将数据分段，并为每段加上首部字节。由此形成的信息包称为<code>分组</code>。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。目前最出名的两种分组交换机类型是<code>路由器</code>和<code>链路层交换机</code>。这两种类型的交换机朝着最终的目的地转发分组。链路层交换机常用于接入网中，而路由器常用于网络核心中。从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<code>路径</code>。</p>
<p>与因特网相连的端系统提供了<code>应用程序编程接口(API)</code>,该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合。类似于我们在寄信的时候需要遵邮局的规定贴上邮票、写上邮政编码等，这些规定就是 API。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>常把与因特网相连的设备称为端系统，因为它们位于网络的边缘。将端系统连接到其<code>边缘路由器</code>的物理链路称为<code>接入网</code>。<code>边缘路由器</code>是端系统到任何其他远程系统的路径上的第一台路由器。<br>除了端系统外，<code>网络应用</code>也处于网络边缘。网络应用通常有两种结构：</p>
<ul>
<li>客户——服务器结构（Client-Server）。常见的 Web 应用都是这种结构。这种应用的特点是客户只与服务器进行交互，只有客户可以主动发起连接。<strong>客户与客户之间是互不可见的</strong></li>
<li>P2P 结构（点对点结构）。这种结构是对等的，不存在客户和服务器的概念。各个端点之间可以直接互相访问。例子有文件共享服务如bt下载，所以才会有<strong>越多人下载速度越快</strong>的说法</li>
</ul>
<h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><p>当前宽带住宅接入有两种流行类型：</p>
<ul>
<li>数字用户线(Digital Subscriber Line，DSL)。即常说的拨号上网。利用DSL调制解调器将到达家庭的数据信号和电话信号分隔开（ADSL是非对称接入，即上行与下行速率是不同的，通常下行更快）</li>
<li>电缆（HFC,混合光纤同轴电缆网）。通过有线电视网络进行传输，用cable modem（即“猫”）将电视信号与网络信号分开。这也是非对称的，下行通常到30Mbts，上行为2Mbps</li>
<li>光纤到户。本地中心局直接提供了一条光纤线路到家庭。</li>
<li>LAN 无限局域网。在公司、大学和越来越多的家庭环境中，通常是用局域网(LAN)将端系统连接到边缘路由器。尽管有多种不同的局域网技术，但<code>以太网</code>是目前最流行的接入技术。在无线LAN环境中，无线用户从一个接入点发送/接受分租，接入点与企业网连接，该企业网再与有线因特网相连，这就是 wifi。可达 54Mbps</li>
<li>蜂窝网。蜂窝网也属于无线接入。所谓3G网4G网都属于蜂窝网。</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p><code>网络核心</code>即互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<p>网络核心的关键功能是<code>路由</code>+<code>转发</code>。<code>路由</code>即确定分组从源到目的地的路径。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端用<code>存储转发传输机制</code>：交换机能够在开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。由此存在<code>存储转发延时</code>：如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R bit/s，则分组在这条链路上的传输时间为 L/R 秒。</p>
<h3 id="排队延时和丢包"><a href="#排队延时和丢包" class="headerlink" title="排队延时和丢包"></a>排队延时和丢包</h3><p>每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个<code>输出缓存</code>用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某天链路但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，由此分组又存在<code>排队延时</code>。缓存空间是有限的，一个到达的分组可能发现该缓存已满，此时会发生<code>丢包(分组丢失)</code>：到达的分组或正排队的分组之一会被丢弃。</p>
<h3 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个被称为<code>IP地址</code>的地址。当源主机要向目的地端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个<code>转发表</code>，用于将目的地址映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发行适当的出链路。路由器则将分组导向该出链路。</p>
<h2 id="分组交换时延"><a href="#分组交换时延" class="headerlink" title="分组交换时延"></a>分组交换时延</h2><p>分组从一个主机出发通过一系列路由器传输，在另一台主机中结束它的历程。这个过程是存在时延的。其中最为重要的几种时延是<code>节点处理时延</code>、<code>排队时延</code>、<code>传输时延</code>、<code>传播时延</code>。这些延时加起来称为<code>节点总时延</code></p>
<ul>
<li>节点处理时延（nodal processing delay）。造成这部分时延的原因主要是检查分组首部（差错检测）和决定将该分组导向何处（确定输出链路）</li>
<li>排队时延（queueing delay）。链路繁忙时新到达交换机的分组会进入排队状态。</li>
<li>传输时延（transmission delay）。仅当所有先到达的分组传输完毕后才能传输刚到达的分组。传输时延是将该分组的所有比特推向链路所需要的时间。L 为分组长度，R 为链路带宽，则传输时延为 L/R</li>
<li>传播时延（propagation delay）。分组在链路上传播的时间称为传播时延。d 为链路长度，v 为传播速率，则传播时延为 d/v</li>
</ul>
<p>传输时延与传播时延不同之处在于传输时延是分组从交换机到链路的时间，与分组的大小有关，与两台路由器之间的距离无关。而传播时延是分组在链接上传播消耗的时间，与分组大小无关，与距离有关。</p>
<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><p>每层完成一类特定功能，底层为上层提供服务，相邻的两层通过<code>接口</code>进行交互，任一层实体提供的服务是<code>垂直的</code>。</p>
<p>计算机网络体系结构是计算机网络各层及其协议的集合。<strong>协议是控制两个对等实体进行通信的规则</strong>的集合，协议是<code>水平的</code>。</p>
<p><img src="https://i.loli.net/2020/01/19/JHuDU5ys3oX84IC.png" alt="OSI模型通信过程"></p>
<p>中间系统只实现网络层、链路层和物理层，这三层合称“非端到端层(non-end-end)”。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>数据在每一层都会被打上一个该层的附加信息（所谓运输首部信息），称为 PDU(Protocol Data Unit)。而这些信息会在下一层被使用。</p>
<p><img src="https://i.loli.net/2020/01/19/zK7oIaJw41ncGgY.png" alt="OSI模型封装过程"></p>
<h3 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h3><ul>
<li>增加控制信息：地址信息（表示发送、接受端），差错检测编码，优先级设置等</li>
</ul>
<h3 id="非端到端层"><a href="#非端到端层" class="headerlink" title="非端到端层"></a>非端到端层</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>规范接口特性：机械特性（形状，大小）、电气特性（电压、电频），功能特性（引脚）等</li>
<li>比特编码：如何表示 0 和 1</li>
<li>数据率：数据传输速率</li>
<li>传输模式：单工通信（单向），半双工通信（交替单向，发和收不同时），全双工通信（同时收发）</li>
</ul>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul>
<li>两个直接相连的结点间的数据帧传输。</li>
<li>物理寻址。在帧头增加收发端物理地址标识信息（通常为 MAC 地址）。</li>
<li>流量控制。匹配发送和接收速度，避免淹没接收端。</li>
<li>差错控制。判断丢失帧与重复帧。</li>
<li>访问控制。决定哪个设备拥有物理链路使用权。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>跨越多个网络的数据分组传输</li>
<li>逻辑寻址，全局唯一（通常为 IP 地址）。</li>
<li>路由：路径选择及分组转发。</li>
</ul>
<p><img src="https://i.loli.net/2020/01/19/Xjb7cGfD285kEev.png" alt="分组转发"></p>
<p>网络层地址不变，链路层地址随传输过程不断更新。</p>
<h3 id="端到端层"><a href="#端到端层" class="headerlink" title="端到端层"></a>端到端层</h3><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>源到目的端进程间报文传输。</p>
<ul>
<li>报文分段与重组</li>
<li>端口号寻址：确保将报文提交给正确进程。</li>
<li>连接控制：作为自下而上第一个端到端层次，建立或拆除端到端间的逻辑连接。</li>
<li>流量控制</li>
<li>差错控制（如 TCP）</li>
</ul>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>不对数据进行分段，只插入一些信息。</p>
<ul>
<li>对话控制：建立、维护进程间对话</li>
<li>同步：在数据流中插入同步点，便于恢复对话</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>处理两个系统间交换信息的语法语义问题（如大小端机器对数据的表示方式不同）。</p>
<ul>
<li>数据表示转化：发送端把信息转化为主机独立的编码，接收端转化为主机相关编码</li>
<li>加密解密</li>
<li>压缩解压缩</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>向用户提供网络服务接口（如浏览器），根据不同应用场景处理用户数据。</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="https://i.loli.net/2020/01/19/OMNn6oqPg4f9G7d.png" alt="TCP/IP模型"></p>
<h2 id="Internet五层协议"><a href="#Internet五层协议" class="headerlink" title="Internet五层协议"></a>Internet五层协议</h2><p>综合 OSI 与 TCP/IP</p>
<ol>
<li>应用层。应用层是网络应用程序及他们的应用层协议存留的地方。HTTP、SMTP、FTP、DNS等都属于应用层协议。分组在应用层中称为<code>报文</code></li>
<li>运输层。<strong>进程之间</strong>传送报文。在因特网中有两个运输协议<code>TCP</code>和<code>UDP</code>。分组在运输层中称为<code>报文段</code></li>
<li>网络层。<strong>主机之间</strong>数据分组与转发。网络层接受运输层递交的报文段和目的地址，类似于寄信时要向邮局提供目标地址。著名的<code>IP协议</code>就在网络层。该协议定义了数据报中的各个字段及端系统和路由器如何作用于这些字段，以达到<code>逻辑寻址</code>的目的。分组在网络层称为<code>数据报</code></li>
<li>链路层。将网络层的IP数据包组装成帧（帧包含数据和必要的控制信息，例如信道编码，卷积码，turbo码），在<strong>相邻网络元素</strong>之间传输。</li>
<li>物理层。物理层负责将帧一个比特一个比特地从一个节点移动到下一个节点。进一步与链路实体（如双通铜线、单模光缆）相关。传输数据为比特流，物理层需要定义比特传输的电气特性（多少电压代表1多少代表0）、机械特性（接口形状尺寸等），如USB、Bluetooth等。而传输物理介质如光纤、双绞线等并不处于物理层的范畴</li>
</ol>
<p><img src="https://i.loli.net/2020/01/19/i1bsCztfQAxcIyK.png" alt="五层模型数据封装"></p>
<p>下面是知乎一个有趣的例子：</p>
<blockquote>
<p>为了实现跨越互联网的，主机 A 的进程 P1，和主机 B 的进程 P2 之间的通信，我们逐层把这个任务交给 TCP/IP 协议栈。<br>运输层：“如果有人能帮我把数据从某个网络中的机器 A 搬到另一个网络中的机器 B，我就可以搞定这个任务，因为我知道不同的数据应该交给机器上的哪个进程。”<br>网络层：“如果有人能帮我把数据从局域网中直接相连的一台机器搬到另一台机器，我就可以把数据从一个网络搬到另一个网络，因为我知道路线怎么走，要经过哪些节点。”<br>链路层：“我知道怎样在局域网中搬数据，还能用 CSMA/CD 协议协调工作，还能用 CRC32 校验发送的数据和接收的数据是一致的，blabla… But，我只是说说，我不干苦力活。”<br>物理层：“楼上的大爷们发话了，兄弟们上。”</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/04/网络那些事基本概念/" data-id="ckoqt9nuz001eb0upczl9y61w" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂谈/">杂谈</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-《MySQL从入门到精通》之备份与恢复" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/03/《MySQL从入门到精通》之备份与恢复/">MySQL之备份与恢复</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/03/《MySQL从入门到精通》之备份与恢复/" class="article-date">
  <time datetime="2018-06-03T11:35:59.000Z" itemprop="datePublished">2018-06-03</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/数据库/">数据库</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="使用mysqldump命令备份"><a href="#使用mysqldump命令备份" class="headerlink" title="使用mysqldump命令备份"></a>使用mysqldump命令备份</h1><p><code>mysqldump</code> 命令可以将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。</p>
<p>mysqldump的工作原理就是查出需要备份的数据库和表的结构，然后在文本文件中生成相应的 <code>create</code> 和 <code>insert</code> 语句。需要导入数据库文件时 MySQL 通过使用文本文件中记录的语句生成相应的数据库和表就可以了。</p>
<p>使用 <code>mysqldump</code> 命令进行数据备份时，经常分为以下3种形式：</p>
<ol>
<li>备份一个数据库</li>
<li>备份多个数据库</li>
<li>备份所有数据库</li>
</ol>
<p>下面分别介绍：</p>
<h2 id="备份一个数据库"><a href="#备份一个数据库" class="headerlink" title="备份一个数据库"></a>备份一个数据库</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -p dbname [table1 table2 ...] &gt; filename</span><br></pre></td></tr></table></figure>
<p>dbname 为数据库名。table1、table2 为表名，没有指定 table 时将备份整个数据库。filename为文本文件名称，通常使用<code>.sql</code>作为后缀。</p>
<p>例：备份数据库 users 中的 studnets 表到 D 盘的 sql 文件夹下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p users  students &gt; D:\sql\students.sql</span><br></pre></td></tr></table></figure>
<h2 id="备份多个数据库"><a href="#备份多个数据库" class="headerlink" title="备份多个数据库"></a>备份多个数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -p <span class="comment">--databeses dbname1 dbname2 &gt; filename</span></span><br></pre></td></tr></table></figure>
<p>加上 <code>databases</code> 选项，后面跟多个数据库名称</p>
<p>例：备份数据库 users、customers 到 D 盘：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--databeses users customers &gt; data.sql</span></span><br></pre></td></tr></table></figure>
<h2 id="备份所有数据库"><a href="#备份所有数据库" class="headerlink" title="备份所有数据库"></a>备份所有数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--all --databases &gt; filename</span></span><br></pre></td></tr></table></figure>
<h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p>使用 <code>mysql</code> 命令进行还原：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p [dbname] &lt; filename</span><br></pre></td></tr></table></figure>
<p>dbname 表示数据库名称，该参数是可选的。指定数据库名称时，表示还原该数据库下的表，不指定时表示还原数据库。</p>
<p>也可以在进入相应数据库后用 <code>source</code> 命令恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; source filename;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/03/《MySQL从入门到精通》之备份与恢复/" data-id="ckoqt9nsw000gb0uppj19lum8" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-《MySQL从入门到精通》之事件与优化" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/06/03/《MySQL从入门到精通》之事件与优化/">MySQL之事务与优化</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/03/《MySQL从入门到精通》之事件与优化/" class="article-date">
  <time datetime="2018-06-03T07:03:41.000Z" itemprop="datePublished">2018-06-03</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/数据库/">数据库</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>在 MySQL 中，事务由一条或多条 SQL 语句组成，在这个事务中，每条 MySQL 语句是相互依赖的。而整个事务作为一个不可分割的整体，一旦某条 MySQL 语句执行失败或产生错误，整个事务将会回滚。</p>
<p>只有 <code>InnoDB</code> 类型的表支持事务。MySQL默认表类型为 <code>InnoDB</code>。</p>
<h2 id="事务的基本要素-ACID"><a href="#事务的基本要素-ACID" class="headerlink" title="事务的基本要素(ACID)"></a>事务的基本要素(ACID)</h2><ol>
<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。</li>
<li>隔离性（Isolation）：每个事务在自己的空间内执行，与其他事务隔离，而且事务的结果只有在它被完全执行时才能看到。这样即使一个系统同时发生多个事物，孤立性也可以保证特定的事务在完成之前其结果不被公布。</li>
<li>持久性（Durability）：事务提交之后，就一定是在硬盘永久的存储，而不会丢失。</li>
</ol>
<h2 id="事务的创建与存在周期"><a href="#事务的创建与存在周期" class="headerlink" title="事务的创建与存在周期"></a>事务的创建与存在周期</h2><p>创建事务的一般过程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化事务 ————&gt; 创建事务 ————&gt; 提交或回滚</span><br></pre></td></tr></table></figure>
<p><strong>无论最后是提交还是回滚，都会关闭这个事务</strong>。  </p>
<ul>
<li>初始化事务：<code>start transaction;</code> 或 <code>begin;</code>，MySQL默认是<strong>自动提交</strong>的，所以需要用命令改为手动模式</li>
<li>创建事务：执行 SQ L语句</li>
<li>提交或回滚： 提交 <code>commit;</code>，回滚 <code>rollback;</code></li>
</ul>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ol>
<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时结果不一致。</li>
<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h2 id="事务的隔离性等级"><a href="#事务的隔离性等级" class="headerlink" title="事务的隔离性等级"></a>事务的隔离性等级</h2><p>事务具有隔离的空间。在 MySQL 服务器中，用户通过不同的会话执行不同的事务，在多用户环境中，许多 RDBMS（关系型数据库管理系统）会话在任意时刻都是活动的。为了使这些事务互不影响，保证数据库性能不受影响，采用事务的孤立等级是很重要的。</p>
<p>如果没有孤立性，不同的查询操作会在同一事务的环境中检索到不同的结果，这将导致数据的不一致性。</p>
<ol>
<li>序列化(serializable)：以序列的形式对事务进行处理。该孤立级的特定是只有当事务提交后，用户才能从数据库上查看数据的变化。</li>
<li>可重读(repeatale read)：事务在孤立级上不会被看成一个序列，不过在当前执行的事务过程中，用户依然看不到事务的过程。直到事务提交为止，用户才能看到事务的变化结果。（客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前是看不到改变的）。<strong>是 MySQL 的默认隔离级别</strong>。  </li>
<li>读已提交(read committed)：该孤立级的安全性比可重读低。在这一级事务用户可以看到其他事务添加到新纪录。在事务处理时如果存在其他用户同时对事务的相应表进行修改那么在同一事务的不同时间内，查询操作可能返回不同的结果(客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前可以看到改变)</li>
<li>读未提交(read uncommitted)：该孤立级提供事务之间最小程度间隔，该孤立级容易产生幻读。其他用户可以在该孤立级上看到未提交的事务。(客户端 A、B 同时开启事务，B 向表中插入数据行且未提交，A 也可以看到改变)</li>
</ol>
<table>
<thead>
<tr>
<th>孤立等级</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>序列化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>可重读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>读已提交</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了</p>
<p>幻读的重点在于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样</p>
<p>从存储引擎的角度看，解决不可重复读只需锁住对应行，而解决幻读需要保存数据库在事务开始前的快照。</p>
<p>设置事务的隔离等级：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> &#123;<span class="keyword">serializable</span> | repeatable <span class="keyword">read</span> | <span class="keyword">read</span> committed | <span class="keyword">read</span> uncommitted&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事务的性能"><a href="#事务的性能" class="headerlink" title="事务的性能"></a>事务的性能</h2><h3 id="应用小事务"><a href="#应用小事务" class="headerlink" title="应用小事务"></a>应用小事务</h3><p>应用小事务的意义在于保证每个事务不会在执行前等待很长时间，从而避免各个事务因为互相等待而导致系统性能大幅度下降。应尽量缩短 <code>insert</code>、<code>update</code> 等操作与 <code>commit</code> 之间的间隔时间。</p>
<h3 id="合适的孤立级"><a href="#合适的孤立级" class="headerlink" title="合适的孤立级"></a>合适的孤立级</h3><p>事务的性能与其对服务器产生的负载成反比，即事务孤立级越高，其性能越低。例如序列化虽然很稳定，但是会大大影响 MySQL 的性能，生产中比较少用，而用乐观锁悲观锁解决幻读等问题</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当两个或多个处于不同序列的用户打算同时更新某相同数据库时，因互相等待对方释放权限而导致双方一直处于等待状态。两个不同序列的客户端同时对数据执行操作极有可能产生死锁。更通俗地讲，当两个事物相互等待操作对方释放所持有的资源而导致两个事务都无法操作对方持有的资源，这样无限期的等待称为死锁。</p>
<p>InnoDB具有检查死锁的功能。如果发现产生了死锁，InnoDB会立刻撤销其中一个任务以便死锁消失。这样就可以使另一个事务获取对方所占有的资源而执行操作逻辑。</p>
<h2 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h2><ul>
<li>使用索引.<strong>对于新表可以先不创建索引，等数据导入后在创建，这样可以提高数据导入效率</strong>。一般来说，索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</li>
<li>尽量少用 <code>like</code> 语句与通配符 <code>%</code></li>
<li>选取最合适的字段大小。表越小，速度越快。所以能用 <code>char</code> 就不要用 <code>varchar</code> ，能用 <code>mediumint</code> 就不用 <code>bigint</code>。<strong>尽量使用 <code>not null</code> 这样在查询时数据库不用去比较null值。</strong></li>
<li>用 <code>join</code> 代替子查询。这样 MySQL 不需要在内存中创建临时表来完成逻辑上的需要两个步骤的查询工作。。</li>
<li>优化 insert 语句。一次插入多条数据比每次插入一条数据快。能用 <code>union</code> 将多条 <code>select</code> 结合就不要单独用多次 <code>select</code></li>
<li>使用事务。我们可以使用子查询、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。这时候就要用到事务。</li>
<li>用外键分解表中低频字段。有些字段的使用频率很低，当表的数据量很大时查询速度会很慢。用外键将这些字段拆分成一个单独的表可以提高效率。</li>
<li>在相同类型的字段间进行比较的操作</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/03/《MySQL从入门到精通》之事件与优化/" data-id="ckoqt9nst000fb0upncl9daoc" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-mysql定义完整性约束" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/05/30/mysql定义完整性约束/">MySQL之完整性约束</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/30/mysql定义完整性约束/" class="article-date">
  <time datetime="2018-05-30T12:19:42.000Z" itemprop="datePublished">2018-05-30</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/数据库/">数据库</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>MySQL提供了多种完整性约束，作为数据库关系模式定义的一部分，可以通过<code>create table</code>或<code>alter table</code>语句来定义。一旦定义了完整性约束，MySQL服务器会随时检测处于更新状态的数据库内容是否符合相关的完整性约束，从而保证数据的一致性与正确性。</p>
<p>在关系模型中，提供了实体完整性、参照完整性和用户完整性3项规则。</p>
<h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p><code>实体</code>是一个数据对象，是指客观存在并可以相互区分的事物，如一个教师、一个学生等。一个实体在数据库中表现为一条记录。</p>
<p>实体完整性是指关系的主属性及主键的组成不能为空。也就是主键不能使空值null。关系对应于现实世界的实体集，而现实世界的实体是可以区分的，即说明每个实例具有唯一性标识。在关系模型中，是使用主键作为唯一性标识的。</p>
<p>先来认识一下关系型数据库中重要的三个键：</p>
<ul>
<li>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 </li>
<li>候选键(candidate key):不含有多余属性的超键称为候选键 </li>
<li>主键(primary key):用户选作元组标识的一个候选键程序主键</li>
</ul>
<p>在MySQL中，实体完整性是通过<em>主键约束</em>和<em>候选键约束</em>实现的。</p>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中多个列组合而成的主键也被称为复合主键。在MySQL中，主键必须遵循如下规则：</p>
<ol>
<li>每个表只能定义一个主键</li>
<li>主键必须能唯一标识表中的每一行记录并且不能为null</li>
<li>复合主键不能包含不必要的多余列</li>
<li>一个列名在复合主键的列表中只能出现一次</li>
</ol>
<h3 id="作为列的主键约束"><a href="#作为列的主键约束" class="headerlink" title="作为列的主键约束"></a>作为列的主键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="作为表的主键约束"><a href="#作为表的主键约束" class="headerlink" title="作为表的主键约束"></a>作为表的主键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>如果主键仅由表中的某一列构成，以上两种方法均可以定义主键。如果主键由表中多个列组成，那么只能有第二种方法定义主键约束。</strong></p>
<h2 id="候选键约束"><a href="#候选键约束" class="headerlink" title="候选键约束"></a>候选键约束</h2><p>如果一个属性集能<strong>唯一标识元组</strong>而又<strong>不含有多余的属性</strong>，那么这个属性集称为关系的候选键，用关键字<code>unique</code>来定义。</p>
<p>候选键可以是表中的某一列，也可以是表中多个列所构成的一个组合。<strong>任何时候，候选键的值必须是唯一的且不能为空</strong>。定义方法类似于主键：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    <span class="keyword">unique</span> (<span class="keyword">name</span>,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>候选键与主键的区别在于：</p>
<ol>
<li>一个表只能创建一个主键，但是可以有多个候选键</li>
<li>定义主键约束时，系统会自动创建<code>primary key</code>索引，定义候选键约束时，系统会自动创建<code>unique</code>索引</li>
</ol>
<h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p>现实世界的实体之间往往存在着某种联系，在关系模型中，实体及实体间的联系都是用关系来描述的，那么自然就存在关系与关系间的引用。</p>
<p><strong>参照完整性就是定义外键与主键之间的引用关系</strong>的。参照完整性的定义为：</p>
<blockquote>
<p>若属性（或属性组）F是基本关系R的外键，它与基本关系S的主键K对应，则对于R中的每个元组在F上的值只允许两种可能：要么取空值，要么等于S中某个元组的主键值，其中R与S可以是不同的关系，也可以是同一是关系，而F和K定义在同一个域中。</p>
</blockquote>
<p>声明外键的基本语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[constraint [symbol]] foreign key (index_col_name,...) reference_defination</span><br></pre></td></tr></table></figure></p>
<p><code>reference_defination</code>主要用于定义外键所参照的表、列，它的基本语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">references tbl_name [(index_col_name,...)]</span><br><span class="line">[match full | match pratial | match simple]</span><br><span class="line">[on <span class="keyword">delete</span> reference_options]</span><br><span class="line">[<span class="keyword">on</span> <span class="keyword">update</span> reference_options]</span><br></pre></td></tr></table></figure></p>
<p><code>tbl_name</code>指定外键所参照的表名，这个表称为<code>被参照表</code>或<code>父表</code>，外键所在的表被称为<code>参照表</code>或<code>子表</code>。 </p>
<p><code>index_col_name</code>指定被参照表中与外键相关联的列，<strong>必须是父表的主键或候选键</strong>，格式语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col_name [(length)] [ASC|DESC]</span><br></pre></td></tr></table></figure></p>
<p><code>reference_options</code>指定参照完整性约束的实现策略，默认为<code>restrict</code>。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restrict | cascade | <span class="keyword">set</span> <span class="literal">null</span> | <span class="keyword">no</span> <span class="keyword">action</span></span><br></pre></td></tr></table></figure></p>
<p>cascade：瀑布、级联</p>
<ul>
<li>restrict 限制策略：当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除和更新</li>
<li>no action 不采取措施策略：一个相关的外键值在被参照表中时，删除或更新被参照表中的键值动作不被允许。类似于restrict</li>
<li>cascade 级联策略：从被参照表中删除或更新纪录行时，自动删除或更新参照表匹配的记录行</li>
<li>set null 制空策略：从被参照表中删除或更新纪录行时，设置参照表中与之对应的外键列的值为null。这个策略需要被参照表中的外键没有声明限定词not null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    class_id <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> <span class="keyword">class</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (class_id) <span class="keyword">references</span> <span class="keyword">class</span>(<span class="keyword">id</span>)</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>当父子表是同一张表时，MySQL不允许指定<code>on update cascade</code>与<code>on update set null</code></strong>，相关联的两个字段类型必须一致。</p>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><p>用户定义完整性是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求，关系模型提供定义和检查这类完整性规则的机制。</p>
<p>MySQL提供了<strong>非空约束</strong>，<strong>check约束</strong>和<strong>触发器</strong>3种用户自定义完整性约束。</p>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>通过<code>create table</code>或<code>alter table</code>语句将某个列加上关键字<code>not null</code>可以实现非空约束。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">modify</span> age <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h2><p>可以对列或表使用<code>check</code>约束，语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span> (expr)</span><br></pre></td></tr></table></figure></p>
<p><code>expr</code>是一个SQL表达式，用于指定需要检查的限定条件。更新数据时MySQL会检查更新后的数据行是否满足<code>check</code>约束中的限定条件。该条件可以是表达式，也可以是子查询。</p>
<h3 id="对列使用check约束"><a href="#对列使用check约束" class="headerlink" title="对列使用check约束"></a>对列使用check约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span> <span class="keyword">check</span>(age&gt;<span class="number">6</span> <span class="keyword">and</span> age&lt;<span class="number">19</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="对表使用check约束"><a href="#对表使用check约束" class="headerlink" title="对表使用check约束"></a>对表使用check约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> students))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="触发器约束"><a href="#触发器约束" class="headerlink" title="触发器约束"></a>触发器约束</h2><p>触发器由MySQL的基本命令事件来触发的某种特定操作，这些基本的命令有<code>insert</code>、<code>update</code>、<code>delete</code>等事件来触发某些特定的操作。满足触发器的触发条件时，数据库系统会自动执行触发器中定义的程序语句。</p>
<h3 id="创建单行触发器"><a href="#创建单行触发器" class="headerlink" title="创建单行触发器"></a>创建单行触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span>|<span class="keyword">after</span> 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> 执行语句;</span><br></pre></td></tr></table></figure>
<ul>
<li>before|after 指定触发器执行时间是在触发事件之前还是之后</li>
<li>触发事件 <code>insert</code>、<code>delete</code>、<code>update</code>等都是触发事件</li>
<li>执行语句 当满足条件时执行的触发器语句</li>
</ul>
<p>创建一个触发器，自动在用户向users表插入数据行之前向日志插入当前时间：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> userstime <span class="keyword">before</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">users</span> <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> userslog <span class="keyword">values</span> (<span class="literal">null</span>, <span class="keyword">now</span>());</span><br></pre></td></tr></table></figure></p>
<h3 id="创建多行触发器"><a href="#创建多行触发器" class="headerlink" title="创建多行触发器"></a>创建多行触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称 <span class="keyword">before</span>|<span class="keyword">after</span> 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">执行语句列表</span><br><span class="line"><span class="keyword">end</span>\g</span><br></pre></td></tr></table></figure>
<p>要执行的多条语句放入<code>begin</code>和<code>end</code>中，用<code>;</code>分隔。</p>
<h3 id="查看触发器："><a href="#查看触发器：" class="headerlink" title="查看触发器："></a>查看触发器：</h3><p>查看所有触发器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据名字查看触发器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> infomation_schema.triggers <span class="keyword">where</span> trigger_name=触发器名;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 触发器名称;</span><br></pre></td></tr></table></figure>
<h1 id="命名完整性约束"><a href="#命名完整性约束" class="headerlink" title="命名完整性约束"></a>命名完整性约束</h1><p>可以对完整性使用添加，删除和修改等操作。为了删除和修改完整性约束，需要在定义约束的同时对其进行命名。命名完整性约束是在各种完整性约束的定义说明之前加上<code>constraint</code>字句实现的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint &lt;symbol&gt; [primary key | foreign key | check]</span><br></pre></td></tr></table></figure></p>
<p>对users表添加外键约束并命名为class：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="keyword">class</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (class_id)</span><br><span class="line"><span class="keyword">references</span> <span class="keyword">class</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="更新完整性约束"><a href="#更新完整性约束" class="headerlink" title="更新完整性约束"></a>更新完整性约束</h1><p>对各种约束命名后就可以用<code>alter table</code>语句来更新或删除。</p>
<h2 id="删除完整性约束"><a href="#删除完整性约束" class="headerlink" title="删除完整性约束"></a>删除完整性约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">foreign</span> <span class="keyword">key</span> | <span class="keyword">index</span> | &lt;symbol&gt;] | primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>
<p>在删除主键时，必须在创建一个主键否则不会成功。</p>
<p>删除users表的名为class的外键：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">class</span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/30/mysql定义完整性约束/" data-id="ckoqt9num0012b0up71r8l90w" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-《MySQL从入门到精通》之索引与视图" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/05/30/《MySQL从入门到精通》之索引与视图/">MySQL之索引与范式</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/30/《MySQL从入门到精通》之索引与视图/" class="article-date">
  <time datetime="2018-05-30T10:33:48.000Z" itemprop="datePublished">2018-05-30</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/数据库/">数据库</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种特殊的数据结构，类似于字典里的 key。通过索引查询数据库中的内容时，不需要遍历所有数据而是直接指向数据所在的位置，这样就可以快速查询到想要的内容。</p>
<p>索引是把双刃剑，虽然索引可以提高检索数据的速度，提高整体的性能，但是也会带来一些副作用：  </p>
<ol>
<li>额外的物理空间（单列索引至少占原表5%到15%）</li>
<li>额外的创建和维护时间（create、insert、update、delete等）</li>
</ol>
<p>MySQL 支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则：</p>
<ol>
<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>
<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>
<li>尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</li>
</ol>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>常见的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引等</p>
<ol>
<li>普通索引：即不应用任何限制条件的索引，该索引可以在任何数据类型中创建。字段本身的约束条件可以判断其值是否为空或唯一。</li>
<li>唯一性索引：使用 <code>unique</code> 参数可以设置唯一索引。创建该索引时索引的值必须唯一。通过唯一索引，用户可以快速定位某条数据。<strong>主键是一种特殊的唯一索引</strong>。</li>
<li>全文索引：<code>fulltext</code> 参数可以设置索引为全文索引。全文索引只能创建在 <code>char</code>、<code>varchar</code>、<code>text</code> 类型字段上。查询数据量较大的字符串型字段时，使用全文索引可以提高查询速度。<strong>只有 MyISAM 支持 <code>fulltext</code> 索引</strong></li>
<li>单列索引：就是只对应一个字段的索引，可以包括以上三种索引方式。</li>
<li>多列索引：在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段。可用通过这几个字段进行查询但是<strong>这几个字段必须包含多列索引的第一个字段，只有这样多列索引才会发挥作用</strong></li>
</ol>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="在建立数据表时创建索引"><a href="#在建立数据表时创建索引" class="headerlink" title="在建立数据表时创建索引"></a>在建立数据表时创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name (</span><br><span class="line">    create_defination</span><br><span class="line">    [<span class="keyword">unique</span> | fulltext] <span class="keyword">index</span></span><br><span class="line">    [别名](属性名<span class="number">1</span>[(长度)[,属性名<span class="number">2</span>(长度)...]] [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>])</span><br><span class="line">)[table_options];</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    sex <span class="built_in">tinyint</span>(<span class="number">1</span>),</span><br><span class="line">    fulltext <span class="keyword">index</span> username(<span class="keyword">name</span>)</span><br><span class="line">)<span class="keyword">engine</span>=MyISAM;</span><br></pre></td></tr></table></figure>
<h3 id="在已建立的数据表中创建索引"><a href="#在已建立的数据表中创建索引" class="headerlink" title="在已建立的数据表中创建索引"></a>在已建立的数据表中创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> | fulltext] <span class="keyword">index</span> index_name </span><br><span class="line"><span class="keyword">on</span> table_name(属性[(长度) [AES|<span class="keyword">DESC</span>]])</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> username <span class="keyword">on</span> <span class="keyword">users</span>(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p>也可以通过修改表结构的方式创建索引，参见《MySQL从入门到精通》之基本语句。</p>
<h1 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h1><p>关系型数据库的规范化理论为：关系数据库中的每一个关系都要满足一定的规范。根据满足规范的条件不同，可以分为5个等级，一般只要把数据库规范到第三等级就足够了。</p>
<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h2><p>第一范式包括下列指导原则：</p>
<ol>
<li>数据组中的每个属性只可以包含一个值</li>
<li>关系中的每个数组必须包含相同数量的值</li>
<li>关系中的每个数组一定不能相同</li>
</ol>
<p>在任何一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。  </p>
<p><strong>如果数据表中的每一个列都是不可再分割的基本数据项，即同一列中不能有多个值，那么就称此数据表符合第一范式</strong>，由此可见第一范式具有不可再分割的原子特性。</p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h2><p>第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。<strong>第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分</strong>。 为了实现区分各记录行通常需要为表设置一个“区分列”，用以存储各个实体的唯一标识。这个唯一属性列被称为<strong>主关键字或主键。</strong></p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h2><p>第三范式是在第二范式的基础上建立起来的。<strong>第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖</strong>，也就是说，第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。<br>所谓传递函数依赖，就是指如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖与关键字段A。参考下面的例子：  </p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (员工姓名、年龄、部门编码、部门经理)  </p>
</blockquote>
<p>上面这个关系表是符合第二范式的，但是不符合第三范式，因为该关系表内部隐含着如下关系：</p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (部门编码) ——&gt; (决定) (部门经理)  </p>
</blockquote>
<p>上面的关系表纯真非关键字段“部门经理”对关键字段“员工编码”的函数传递依赖，对于上面这种关系，可以把这个关系表改为如下两个关系表：  </p>
<blockquote>
<p>员工信息表：(员工编码，员工姓名，年龄好部门编码)<br>部门信息表：(部门编码和部门经理)  </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/30/《MySQL从入门到精通》之索引与视图/" data-id="ckoqt9nsz000hb0up1vo804fb" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-字符串编码" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/05/23/字符串编码/">也谈 Unicode</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/23/字符串编码/" class="article-date">
  <time datetime="2018-05-23T14:47:56.000Z" itemprop="datePublished">2018-05-23</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h2 id="不同的编码方式"><a href="#不同的编码方式" class="headerlink" title="不同的编码方式"></a>不同的编码方式</h2><p>由于计算机是美国人发明的，所以最早的时候只收录了 127 个字符，包括阿拉伯数字、英文字母大小写和一些常用符号，称为 <code>ASCII</code>。后来计算机越来越普及，127 个字符显然不够。于是各国又制定了自己国家的字符编码。为了避免不同国家之间通信出现乱码的问题，一种统一字符集 <code>Unicode</code> 诞生了。<code>ASCII</code> 用 1 个字节来储存一个字符，而 <code>Unicode</code> 用 4 个字节来储存字符。理论上所有的文字、符号都可以用 Unicode 编码表示。换言之，Unicode 是一种表示所有字符的方式`。</p>
<p>有了 Unicode，就解决了从字符到二进制的表示问题。接下来问题就是计算机内如何编码这套字符集了。</p>
<p>所有 Unicode 字符长度都是 4 字节，理论上计算机只需要每次读取 4 个字节就可以得到一个字符，这就是所谓的 <code>UTF-32 编码</code>。由于常用字符数目不到 65535 个，用 2 个字节就能容纳，那就意味着 4 个字节中有 2 个是经常被浪费掉的。所谓浪费就是犯罪，既然如此，系统可以老老实实每次读取 2 字节，遇到特殊符号时再往后多读 2 字节 就可以了。这就是 Java 默认的 <code>UTF-16 编码</code>。可是问题依然没有完全解决，英语是最常用的语言，前面说过，只需要 1 个字节就可以表示英文字母了，UTF-16 把每个字母也按照 2 字节 的方式编码，这无疑还是浪费了很多存储空间。另一种编码方式 <code>UTF-8 编码</code> 则解决了这个问题。UTF-8 编码通常只占 1 字节，但是会用几位冗余信息告诉系统，当前字符有没有结束，还需要继续往下读下一个字节。UTF-8 编码对英文只会占用 1 字节 的空间，而一些特殊字符如中文，则会智能地多占用一点空间进行存储，这样就大大节约了空间，特别适合用于本地存储和网络传输。在计算机内存中，统一使用 Unicode 字符集，而在网络传输和硬盘保存时，推荐使用 UTF-8 作为编码方式。</p>
<p>占用不同字节数的 UTF-8 编码表示形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx    // 0-127，ASCII 字符</span><br><span class="line">110xxxxx 10xxxxxx   // 128-2047</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx  // 2048-65535</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx // 65536-0x10ffff</span><br></pre></td></tr></table></figure>
<p>通常按 UTF-8 编码的中文字符占 3 字节。这种变长编码导致字符串无法按字节下标直接读取一个字符，但由于其与 ASCII 完全兼容、非常节约存储空间、算法高效等特性，在实际中获得了广泛的应用。以下 3 种字符串常量均表示长度为 6 字节的相同串：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"世界"</span>  <span class="comment">// 中文字符</span></span><br><span class="line"><span class="string">"\xe4\xb8\x96\xe7\x95\x8c"</span>  <span class="comment">// UTF-8</span></span><br><span class="line"><span class="string">"\u4e16\u754c"</span>  <span class="comment">// Unicode</span></span><br></pre></td></tr></table></figure>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>在 python3中，字符默认按 Unicode 编码，而在进行网络传输和硬盘保存时，常常将 Unicode 字符按 UTF-8 的方式编码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(s.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>当我们从网络上获取数据时，常常也是获取到以 UTF-8 形式编码的字节，为了方便我们对数据进行处理，需要解码成普通的 Unicode：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line">print(b.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 输出：'中文'</span></span><br></pre></td></tr></table></figure>
<p><strong>为了避免乱码，应该始终坚持以 UTF-8 的形式进行字符和字节之间的转换</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/23/字符串编码/" data-id="ckoqt9nt4000lb0upejm45oja" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>精神的壳 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="精神的壳"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/copybtn.js"></script>




<script src="/js/ocean.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>