<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    java基础-使用集合类 |
    
    精神的壳</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="alternate" href="/atom.xml" title="精神的壳" type="application/atom+xml">
</head></html>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-java程序设计-集合" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  java基础-使用集合类
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/06/28/java程序设计-集合/" class="article-date">
  <time datetime="2018-06-28T12:12:12.000Z" itemprop="datePublished">2018-06-28</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h1><p>Java集合类库将<code>接口（interface）</code>与<code>实现（implementation）</code>分离。在使用集合类时，一旦构建了集合就不需要知道究竟使用了哪种实现，因此只有在构建集合对象时使用具体的类才有意义。可以使用<code>接口类型</code>存放集合的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"David"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这样做有利于随时更改实现类型，当发现有更合适的实现类时，只需要修改调用构造器处的代码就可以了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CirculArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>集合类的基本接口是<code>Collection接口</code>,这个接口有两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>add方法用于向集合中添加元素。如果添加成功返回true，否则false。<br>iterator方法返回一个实现了Iterator接口的对象，这个对象又称为<code>迭代器</code>，可以用这个迭代器依次访问集合中的元素</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator接口包含4个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java迭代器的查找与位置变更是紧密相连的，查找一个元素的唯一方法是调用<code>next()</code>，而在执行查找操作时，迭代器的位置随之向前移动。当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。而<code>remove()</code>会从迭代器中删除上次调用<code>next()</code>方法时返回的元素。</p>
<p>迭代器应理解为处于两个元素之间，当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>Java中所有链表都是双向的。对于链表，尽量不使用随机访问而使用遍历操作，否则效率很低。Java提供了LinkedList类，可以很简单实现列表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// LinkedList类实现了List接口</span></span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">staff.add(<span class="string">"Mike"</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = staff.iterator();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure></p>
<p>通过<code>add</code>方法可以向链表尾部添加元素。想要在链表中间插入元素，由于迭代器是表述集合中位置的，所以要借助迭代器实现，而只有在有序集合中这样做才有意义，Iterator是使用与所有集合的，所以对于有序集合，Java提供了Iterator的子类ListIterator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.ListIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">"Mike"</span>); <span class="comment">// 在Susan之后，David之前添加Mike</span></span><br><span class="line">String first = iter.previous();  <span class="comment">// 反向遍历链表</span></span><br><span class="line">iter.remove(); <span class="comment">// 删除被previous越过的元素Mike</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>方法用于替换被next或previous越过的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">staff.next();</span><br><span class="line">staff.set(<span class="string">"Mike"</span>); <span class="comment">// Susan被替换为Mike</span></span><br></pre></td></tr></table></figure></p>
<h1 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h1><p>在Java中，可以用变量来确定数组的大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee staff[] = <span class="keyword">new</span> Employee[num];</span><br></pre></td></tr></table></figure></p>
<p>为了达到数组动态变长/缩短的效果，使用泛型数组列表<code>ArrayList</code>。<em>泛型</em>即“参数化类型”、将类型参数化，类似于方法中的变量参数，只是此时类型也定义成参数形式（又称为类型参数）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure></p>
<p>用<code>add([int index,]obj)</code>方法往数组列表添加元素，不指定索引则默认加到末尾。<code>remove(int index)</code>删除元素，<code>get(int index)</code>按索引获取元素，<code>set(int index, obj)</code>重置对应索引的元素（不能用于添加元素），<code>size()</code>方法获取ArrayList长度。</p>
<h2 id="将数组列表拷贝到数组"><a href="#将数组列表拷贝到数组" class="headerlink" title="将数组列表拷贝到数组"></a>将数组列表拷贝到数组</h2><p>用<code>toArray()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[] a = <span class="keyword">new</span> X[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型化与原始数组列表之间的兼容性"><a href="#泛型化与原始数组列表之间的兼容性" class="headerlink" title="泛型化与原始数组列表之间的兼容性"></a>泛型化与原始数组列表之间的兼容性</h2><p>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型ArrayList。</p>
<h1 id="散列集与树集"><a href="#散列集与树集" class="headerlink" title="散列集与树集"></a>散列集与树集</h1><p>散列集的查找性能比数组和链表都要高。散列表为每个对象计算一个数，称为<code>散列码</code>，散列码由对象的实例域产生一个整数，具有不同数据域的对象产生不同的散列码。java提供了<code>set</code>接口，由<code>HashSet</code>类实现。散列迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。</p>
<p>树集<code>TreeSet</code>类与HashSet十分相似，不过在遍历树集中的元素时默认按添加顺序排序。也可以在构造树集时提供一个Comparator改变排序规则。TreeSet类实现了<code>SortedSet</code>接口和<code>NavigableSet</code>接口。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列可以在尾部添加一个元素，在头部删除一个元素。有两个端头的队列称为<code>双端队列</code>，可以在头部和尾部同时添加或删除元素。不支持在队列中间插入元素。java提供了<code>Deque</code>接口并由<code>ArrayDeque</code>和<code>LinkedList</code>类实现，这两个类都提供了双端队列。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/28/java程序设计-集合/" data-id="ckoqstma1000cgkupe9k2mcdh" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2018/11/15/Flask学习/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      Flask——启动吧，Flask！
      
    </div>
  </a>
  
  
  <a href="/2018/06/24/Java程序设计—-处理异常/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">Java基础—处理异常</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>精神的壳 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="精神的壳"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/copybtn.js"></script>



<script src="/js/tocbot.min.js"></script>
<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>


<script src="/js/ocean.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>