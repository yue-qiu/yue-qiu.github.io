<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    精神的壳</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="alternate" href="/atom.xml" title="精神的壳" type="application/atom+xml">
</head></html>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">精神的壳</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="精神的壳"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-unittest单元测试" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/05/23/unittest单元测试/">unittest简介</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/23/unittest单元测试/" class="article-date">
  <time datetime="2018-05-23T09:08:42.000Z" itemprop="datePublished">2018-05-23</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>有个词叫TDD(Tset Driven Development)，测试驱动开发。一个好的开发人员不仅要懂开发，还要懂得一定的测试技巧。python自带了很多的测试库，比如unittest，coverage….介绍一下unittest的使用。</p>
<h1 id="unittests四个重要的概念"><a href="#unittests四个重要的概念" class="headerlink" title="unittests四个重要的概念"></a>unittests四个重要的概念</h1><p>unittest有四个重要的面向对象概念：</p>
<ol>
<li>test fixture。这个概念主要处理测试环境的搭建和清理。很多时候我们在进行测试的时候需要搭建合适的环境，例如创建目录、创建数据库等，而在测试完毕后这些环境又不再需要了。test fixturn可以帮我们很好的处理这些事情。</li>
<li>test case。 既然要进行测试，测试用例当然是最重要的。每一项测试内容都是一个test case。</li>
<li>test suite。我们当然不希望只能一项项的进行测试，最好是将要测试的项目放在一起。test suite相当于test case的集合，当然test suite也能嵌套在test suite中。</li>
<li>test runner。顾名思义，这个概念负责执行测试并控制结果输出。</li>
</ol>
<h1 id="创建testcase"><a href="#创建testcase" class="headerlink" title="创建testcase"></a>创建testcase</h1><p>unittest提供了TastCase类，要创建一个testcase只需要继承这个父类就好了。</p>
<p>先在<code>mathfunc.py</code>编写三个函数用于测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>在<code>test_math.py</code>中创建测试用例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试add函数"""</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试minus函数"""</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span><span class="number">-1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试string函数"""</span></span><br><span class="line">        self.assertIn(<span class="string">'h'</span> <span class="keyword">in</span> string(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure>
<p>这就创建了一个testcase，包含三个测试。<strong>testcase中所有的测试必须以<code>test</code>开头</strong>。<code>self.assert*()</code>是由TestCase提供的测试函数。每一个测试里的文档会在输出测试报告时显示。不用python内置的assert()是因为uniittest在遇到<code>self.assert*()</code>发生错误时会把这个测试标记为failure，然后继续执行其他测试。</p>
<h1 id="创建testsuite"><a href="#创建testsuite" class="headerlink" title="创建testsuite"></a>创建testsuite</h1><p>有了testcase，自然想把它加入到suite中。unittest提供了<code>TestSuite</code>类来表示一个suite。默认情况下，unittest按测试函数的函数名进行排序，然后按这个排序执行测试。如果我们想控制测试执行顺序，就要在向suite添加case时做点文章：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line"><span class="comment"># 传入列表，这样就会按照元素顺序执行测试</span></span><br><span class="line">suite.addTests([TestMath(<span class="string">'test_add'</span>), TestMath(<span class="string">'test_minus'</span>), TestMath(<span class="string">'test_string'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure></p>
<p>还可以通过unittest提供的TestLoader类来添加testcase，<strong>TestLoader会返回一个suite</strong>。不过<strong>TestLoader无法保证按照顺序执行测试</strong>。TestLoader类提供了一下常用方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test_math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三种方法都可以</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(<span class="string">'test_math.TestMath'</span>))</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromNanes([<span class="string">'test_math.TestMath'</span>])</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromTestCase(TestMath))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果test_math在/usr/test/目录下</span></span><br><span class="line">suite.addTests(unittest.TestLoader().discover(<span class="string">r'/usr/test/'</span>))</span><br><span class="line"><span class="comment"># 可用添加单个testcase</span></span><br><span class="line">suite.addTest(TestMath(<span class="string">'test_add'</span>))</span><br></pre></td></tr></table></figure></p>
<ul>
<li>loadTestsFromName(模块名.testcase名)</li>
<li>loadTestsFromTestCase(testcase名)</li>
<li>discover(start_dir, pattern=’test*.py’, top_level_dir=None)。start_dir是目标文件夹路径，unittest会查找指定目录及子目录下的全部符合pattern的模块并执行里面的TestCase。<strong>电脑中不能有同名的目标文件夹，否则unittest可能无法找到正确的位置</strong>。patter默认是’test*.py’。</li>
</ul>
<h1 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h1><p>TaseCase父类提供了<code>setUp()</code>，<code>tearDown()</code>，<code>setUpClass()</code>，<code>tearDownClass()</code>。我们在自己的测试用例中重写就可以了。</p>
<p>setUp()与tearDown()会在每个测试之前执行。setUp()负责搭建测试环境，tearDown()负责清理环境。如果setUp()执行失败那么这次测试不会进行，如果setUp()成功执行那么不管测试是否成功tearDown()都会执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.app = create_app(<span class="string">'TESTING'</span>)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        self.client = self.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>如果想要在所以case之前执行一次环境准备，所有case之后清理环境，可用<code>setUpClass()</code>和<code>tearDownClass()</code>。不过要带上<code>@classmethod</code>装饰器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.app = create_app(<span class="string">'TESTING'</span>)</span><br><span class="line">        cls.app_context = cls.app.app_context()</span><br><span class="line">        cls.app_context.push()</span><br><span class="line">        cls.client = cls.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(cls)</span>:</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        cls.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h1 id="执行测试及控制输出"><a href="#执行测试及控制输出" class="headerlink" title="执行测试及控制输出"></a>执行测试及控制输出</h1><p>通常我们使用<code>unittest.main()</code>就会调用Test Runner开始测试。当然也可以手动执行Runner。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></p>
<p>verbosity设定了测试报告的详细程度，有0，1，2三种。默认值是1，数字越大越详细。</p>
<p>也可以把输出写到文件里,将文件指针传给Runner()里的<code>stream</code>参数就可以了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/usr/test/report'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>, stream=f)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></p>
<h1 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h1><p>unittest提供3种跳过测试的装饰器：skip([reason])、skipIf(condtion[,reason])，skipUnless(conditon[,reason])。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @unittest.skip('跳过add函数')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span><span class="number">-1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertIn(<span class="string">'h'</span> <span class="keyword">in</span> string(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/23/unittest单元测试/" data-id="ckoqt9nsr000eb0upswuqqq9f" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-git常见用法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/05/23/git常见用法/">git常见用法</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/23/git常见用法/" class="article-date">
  <time datetime="2018-05-22T22:45:34.000Z" itemprop="datePublished">2018-05-23</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>使用git也有一段时间了，一直没有做总结，在这里记录一下方便以后查看。</p>
<p><strong>配置git：</strong></p>
<p>windows下直接从<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a>下载就可以了，安装过程是傻瓜式的，一路点确定就OK。安装完成后发现多了个叫<code>git bash</code>的程序，打开程序会弹出一个命令行窗口就可以了。</p>
<p>linux下安装git很简单，直接在终端输入 <code>git</code>，系统会告诉你是否已经安装。如果没有安装还会告诉你安装方法。Debian 和 Ubantu 下通过 <code>sudo apt-get install git</code> 就可以进行安装。</p>
<p>由于git是分布式版本控制系统，所以必须指出每台机器的身份。这就要配置git相关变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.username <span class="string">"name"</span></span><br><span class="line">git config --global user.email <span class="string">"email"</span></span><br></pre></td></tr></table></figure>
<p>有时候我们发现自己的账户和邮箱配置错了，重设我们的账户和邮箱：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --replace-all user.username <span class="string">"new name"</span></span><br><span class="line">git config --global --replace-all user.email <span class="string">"new email"</span></span><br></pre></td></tr></table></figure>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>目标文件夹下，打开终端输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>这就为这个文件夹创建了一个版本库，有了版本库就可以开始使用 git 的各项功能了。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>git 有分区的概念，平时我们新建、删除、修改文件都是在<code>工作区</code>，通过 <code>git add</code> 命令把工作区的变动提交到<code>暂存区</code>（stage），再用 <code>git commit</code> 把stage的内容提交到<code>分支</code>（branch）。</p>
<p>每次我们对文件进行修改，都会改变 git 的状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment">#查看当前仓库的状态（是否有文件被修改，有文件没有commit等）</span></span><br><span class="line">git diff file <span class="comment">#比较工作区与缓存区的不同</span></span><br><span class="line">git diff head  <span class="comment"># 比较工作区与分支的不同</span></span><br></pre></td></tr></table></figure>
<h3 id="显示过往提交记录"><a href="#显示过往提交记录" class="headerlink" title="显示过往提交记录"></a>显示过往提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改，<strong>相当于 git add 的反向命令，即把暂存区最新版本转移到工作区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>
<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的，<strong>相当于 git commit 的反向命令，即把分支最新版本转移到暂存区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h3 id="显示提交记录"><a href="#显示提交记录" class="headerlink" title="显示提交记录"></a>显示提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改-1"><a href="#管理修改-1" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>
<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>要先在 Github 中添加这台机器的 ssh 密钥以允许你把本地文件传到 Github 上。执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email"</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在当前文件夹下生成 <code>.ssh</code> 文件夹，里面有两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。带 pub 的是公钥，把 <code>id_rsa.pub</code> 里的内容添加到 Github 上。</p>
<p>想把 Github 中的仓库和本地仓库关联起来，通过这条命令可以实现，xxxxx 是远程仓库的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxxxx</span><br></pre></td></tr></table></figure>
<p>origin 是这个 git 本地仓库对远程仓库的称呼，也可以用别的名字如 dev、test 等，但是通常都用origin。</p>
<p>删除本地仓库与远程仓库的关联也很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>有时候我们在 Github 上可能看到一些很有意思的库，可以用这个命令把它下载到本地，其中 xxxxx 是这个仓库的网址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxxxx</span><br></pre></td></tr></table></figure>
<h3 id="把本地库内容推送到远程"><a href="#把本地库内容推送到远程" class="headerlink" title="把本地库内容推送到远程"></a>把本地库内容推送到远程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如果是第一次推送，可以为push加上 <code>-u</code> 参数，这样以后推送的时候就不用再输入 Github 的账号和密码了。master 代表远程仓库的主分支，如果要推送到其他分支就换成其他分支名。</p>
<h3 id="抓取远程库内容"><a href="#抓取远程库内容" class="headerlink" title="抓取远程库内容"></a>抓取远程库内容</h3><p>抓取远程仓库内容并 merge 到本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 默认抓取 origin 中和当前分支关联的远程分支</span></span><br></pre></td></tr></table></figure>
<h3 id="删除远程仓库中的文件"><a href="#删除远程仓库中的文件" class="headerlink" title="删除远程仓库中的文件"></a>删除远程仓库中的文件</h3><p>很多时候随着项目的进行，远程仓库中一些文件不再被使用，或者干脆就是不小心提交了没啥用的文件。当然，可以在 Github 点击删除按钮进行删除，但是目前 Github 只提供了单个文件的删除，如果想要删除一个文件夹及其下的所有文件那工作量简直令人崩溃 orz。</p>
<p>其实，我们可以通过从版本库中删除这个文件再推送到 Github 的方式删除远程仓库中的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached file</span><br><span class="line">git commit -m <span class="string">"delete file"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><code>-r</code> 表示递归删除，这在 file 表示文件夹时尤其有用。<code>--cached</code> 表示对版本库中的缓存进行操作，这样就不会把本地文件给删除了~</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建新分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure>
<p>移动到一个分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>
<p>创建并移动到一个新分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure>
<p>创建并移动到一个和远程分支对应的分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名 origin/远程分支</span><br></pre></td></tr></table></figure>
<p>建立本地分支对远程分支的关联：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream 本地分支 origin/远程分支</span><br></pre></td></tr></table></figure>
<p>将当前分支与另一分支合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure>
<h3 id="处理分支冲突"><a href="#处理分支冲突" class="headerlink" title="处理分支冲突"></a>处理分支冲突</h3><p>合并分支时，可能会遇到因两个分支的内容有冲突而导致合并失败的现象（这在执行 pull 操作时尤其常见，特别是当你在 Github 上在线修改了一个文件，而本地没有修改时）。git 会在冲突文件中用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同内容的分支。我们需要将文件进行修改后再执行 commit：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到，本地 HEAD 和远程分支冲突了</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">git is good</span><br><span class="line">=======</span><br><span class="line">git is very good</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件修改一下</span></span><br><span class="line">git is very good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git add test.txt</span><br><span class="line">git commit -m "解决冲突"</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>当项目开发到一定阶段，我们会给它打上一个<code>标签</code>（tag）表示达到了某种程度。就像很多软件经常会说：我们升级到 v7.0.1 版本啦，快来升级哟~ 这里的 v7.0.1 就是一个标签。</p>
<p>查看当前版本库中所有标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>给某次 commit 打上标签很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名 版本号</span><br></pre></td></tr></table></figure>
<p>像 commit 那样给标签添加说明，<code>-a</code> 表示创建一个带附注的标签，<code>-m</code> 表示附注：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名 版本号 -a -m <span class="string">"add an annotation"</span></span><br></pre></td></tr></table></figure>
<p>查看一个标签的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 标签名</span><br></pre></td></tr></table></figure>
<p>签出一个标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 标签名</span><br></pre></td></tr></table></figure>
<p>删除本地标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签名</span><br></pre></td></tr></table></figure>
<p>推送本地标签到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<p>删除远程仓库中的标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/标签名</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/23/git常见用法/" data-id="ckoqt9nul0011b0upypuw2apr" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-《MySQL从入门到精通》之基本语句" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/03/31/《MySQL从入门到精通》之基本语句/">MySQL之基础语法</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/03/31/《MySQL从入门到精通》之基本语句/" class="article-date">
  <time datetime="2018-03-31T13:15:37.000Z" itemprop="datePublished">2018-03-31</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/数据库/">数据库</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>在 MySQL 中，表、视图、存储过程和索引等具体存储数据或对数据进行操作的实体都被称为数据库对象。</p>
<ul>
<li>表：是包含数据库中所有数据的数据库对象，由行和列组成，用于组织和存储数据类型</li>
<li>字段：表中每列被称为一个字段，字段具有自己的属性，如字段类型、字段大小等。其中，字段类型是字段最重要的属性，它决定了字段能存储哪种数据。</li>
<li>索引：是一个单独的、物理的数据结构。它是依赖于表建立的，在数据库中索引使用数据库程序无需对整个表进行扫描就可以在其中找到所需的数据。索引可以比作是一本书的目录</li>
<li>视图：视图是从一张或多张表中导出的表（也称虚拟表），是用户查看数据的一种方式，表中包括几个被定义的数据列与数据行，其结构和数据建立在对表的查询基础之上。</li>
<li>存储过程：一组为了完成特定功能的 SQL 语句集合（包括查询、插入、删除、更新等操作），经编译后以名称的形式存储在 SQL Server 服务端的数据库中，由用户通过指定存储过程的名字来执行对应的存储操作。</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎其实就是如何在存储数据，如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 支持很多表，每种类型都有自己的特定作用、优点和缺点。MySQL 还相应提供了很多不同的存储引擎，可以以最适合于应用需求的方式存储数据。</p>
<p>MySQL中的数据用各种不同的技术存储在文件或内存中，这些技术采用不同的存储机制、索引技巧、锁定水平并最终提供广泛的、不同的功能和能力。通过选择不同的技术，能够获取额外的速度或者功能，从而改善应用的整体功能。</p>
<p>查询当前数据库的引擎：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB 支持自动增长列：<code>AUTO_INCREMENT</code>。自动增长列的值不能为空，且值必须唯一。<strong>MySQL中规定自动增长列必须为主键</strong>，在插入值时，如果自动增长列不输入值或插入的值为0、null，则插入的值为自动增长后的值。</p>
<p>InnoDB支持外键（foreign key）。外键所在表为子表，外键所依赖的表为父表。<strong>父表中被子表外键关联的字段必须为主键</strong>。当修改父表的某天信息时，子表也必须有相应的改变。</p>
<p>InnoDB是如下情况的理想引擎：  </p>
<ol>
<li>更新密集的表。InnnoDB特别适合处理多重并发的更新请求</li>
<li>事务。InnoDB是唯一支持事务的标志MySQL存储引擎。在管理敏感数据（如用户注册）时特别有用</li>
<li>自动灾难修复。与其他引擎不同，InnoDB能自动从灾难中恢复，虽然MyISAM也能做到但是其过程要长得多</li>
</ol>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><p>MyISAM 引擎的优点在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MySQL支持5中基本字段类型：数值型，字符型，文本型，逻辑型和日期时间型。</p>
<ul>
<li>数值型：MySQL 支持所有标准 SQL 数值数据类型。这些数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/1.png" alt="整数型"></p>
<p><img src="http://ke.dajiangtai.com/content/411/2.png" alt="浮点型"></p>
<ul>
<li>时间日期型：表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR。每个时间类型有一个有效值范围和一个零值，当指定非法值时使用”零”值。</li>
</ul>
<p><strong>TIMESTAMP 类型有专有的自动更新特性。</strong></p>
<p><img src="http://ke.dajiangtai.com/content/411/3.png" alt="时间日期类型"></p>
<ul>
<li>字符串型：字符串类型指 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/4.png" alt="字符串类型"></p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>创建表时，使用字符串类型时应遵循以下原则：  </p>
<ol>
<li>从速度方面考虑，要选择固定长度的列，可以使用 CHAR 类型</li>
<li>要节省空间，使用动态长度的列，可以使用 VARCHAR 类型</li>
<li>要将列中的内容限制在一种选择，可以用 ENUM 类型</li>
<li>允许一个列中有多于一个的条目，可以用 SET 类型</li>
</ol>
<ul>
<li>布尔型：其实 MySQL 里根本没有布尔型，虽然可以用 <code>boolean</code> 但实际上 MySQL 会把它替换成 <code>tinyint(1)</code>。用 1 或 True 表示真，0 或 False 表示假。</li>
</ul>
<h2 id="SQL-语句入门"><a href="#SQL-语句入门" class="headerlink" title="SQL 语句入门"></a>SQL 语句入门</h2><p>使用数据库，首先要会 SQL 语句。下列 SQL 语句中，带 <code>{}</code> 的是必选项，<code>[]</code> 是可选项，<code>[default]</code> 表示可选并有默认值的选项，<code>|</code> 表示或。SQL 语句以 <code>;</code> 结尾，也可以用 <code>\g</code> 或 <code>\G</code>，<code>\g</code> 与 <code>;</code> 是相同的，而 <code>\G</code> 可以让结果显示更美观。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名</span><br><span class="line">[<span class="keyword">default</span>]<span class="built_in">character</span> <span class="keyword">set</span> [=] 字符集名;</span><br></pre></td></tr></table></figure>
<p><code>character set</code> 默认情况下是 MySQL 服务器配置文件里的字符集。可以是GB2312 或 GBK（简体中文）、UTF8、BIG5（繁体中文）、Latin1（拉丁文）等，最常见的就是 GBK 和 UTF8。</p>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> [<span class="keyword">like</span> <span class="string">'模式'</span>];</span><br></pre></td></tr></table></figure>
<p>查看所有数据库，谓词 <code>like</code> 用于指定匹配模式（支持正则）。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> <span class="keyword">like</span> <span class="string">'db%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure>
<p>使用 <code>use</code> 语句将数据库指定为当前数据库后，当前数据库在当前工作会话关闭（即断开与该数据库的连接）或再次使用 <code>use</code> 语句指定数据库时结束工作状态。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure>
<p><code>if exists</code> 在删除数据库前先判断数据库是否已经存在，只有已经存在是才会执行删除操作，这样可以避免删除不存在的数据库时产生异常。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">temporary</span>] <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名</span><br><span class="line">(&#123;create_defination[,create_defination]&#125;) [table_options] [select_statement];</span><br></pre></td></tr></table></figure>
<p>说明：  </p>
<ol>
<li>temporary：创建一个临时表</li>
<li>if not exists：避免表存在时出错</li>
<li>create_defination：定义表的列属性</li>
<li>table_options：表的一些特性参数，涉及表数据如何存储。如engine选项：engine=MyISAM。</li>
<li>select_statement：select语句描述部分，用它可以快速创建表</li>
</ol>
<p>create_defination格式：</p>
<blockquote>
<p>col_name type [not null | null] [default default_value] [auto_increment] [primary key] [reference_defination]</p>
</blockquote>
<p>下面是例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> 数据表名 [列名];</span><br></pre></td></tr></table></figure>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>修改表结构指增加或删除字段、修改字段名称或字段类型、设置取消主键外键、设置取消索引等</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据表名 alter_spec[,alter_spec] | table_options</span><br></pre></td></tr></table></figure>
<p>alter_spec:  </p>
<ul>
<li>add create_defination[first | after column_name] //添加新字段</li>
<li>add index [index_name] (index_col_name) //添加索引名称</li>
<li>add primary key (index_col_name) //添加主键名称</li>
<li>add unique [index_name] (index_col_name) //添加唯一索引</li>
<li>alter col_name {set default 默认值 | drop default} //修改字段默认值</li>
<li>change old_col_name create_defination //修改字段名、类型</li>
<li>modify col_name create_defination //修改字段定义</li>
<li>drop col_name //删除字段</li>
<li>drop index index_name //删除索引</li>
<li>rename as new_tab_name //修改表名</li>
</ul>
<p><strong><code>alter table</code> 语句允许指定多个动作，其动作间用逗号分隔，每个动作表示一个修改。</strong></p>
<ul>
<li>添加新字段及修改字段定义：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">add</span> email <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">after</span> location,</span><br><span class="line"><span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改字段名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">change</span> <span class="keyword">user</span> username varhcar(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除字段：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">drop</span> email;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改表名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">rename</span> the_users;</span><br></pre></td></tr></table></figure>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><p>在一张已存在的数据表的基础上创建一份该表的备份，也就是复制表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名 <span class="keyword">like</span> 源数据表名;</span><br></pre></td></tr></table></figure>
<p>使用该语法复制数据表时，将创建一个与源数据表相同结构的新表，该数据表的别名、数据类型和索引都将被复制，但是表的内容是不会被复制的。因此，创建的表是一张<strong>空表</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">like</span> the_users;</span><br></pre></td></tr></table></figure>
<p>如果在复制表格式的同时也想复制表中的内容，可以使用<code>as</code>（查询表达式）字句实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> the_users;</span><br></pre></td></tr></table></figure>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据表名;</span><br></pre></td></tr></table></figure>
<p>可同时删除多张表，多个表之间用逗号<code>,</code>连接。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> [<span class="keyword">low_priority</span> | <span class="keyword">delayed</span> | <span class="keyword">high_priority</span>] [<span class="keyword">ignore</span>]</span><br><span class="line">[<span class="keyword">into</span>] 数据表名 [(字段名)] <span class="keyword">values</span> (&#123;值 | <span class="keyword">default</span>&#125;),(...),...</span><br></pre></td></tr></table></figure>
<ul>
<li>[low_priority | delayed | high_priority]：<code>low_priority</code> 是 <code>insert</code>、<code>delete</code>、<code>update</code> 都可选的操作，降低 <code>insert</code>、<code>delete</code>、<code>update</code> 的优先级。<code>delayed</code> 是 <code>insert</code> 语句支持的一种可选修饰符，用于指定MySQL服务器把待插入的行数据放在一个缓冲器中，直到待插数据的表空闲时，才真正的在表中插入数据行。<code>high_priority</code> 是 <code>insert</code>和 <code>select</code> 语句支持的一种可选修饰符，用于指定 <code>insert</code> 和 <code>select</code> 操作优先执行。</li>
<li>[ignore]： 在执行 <code>insert</code> 语句时，所出现的错误都会被当做警告</li>
<li>[into]： 指定被操作的数据表</li>
<li>[(字段名,…)]： 当不指定该选项时，表示要向表中所有列插入数据，否则表示向数据表的指定列插入数据。</li>
<li><p>({值 | default}),(…),…：用于指定需要插入的数据清单，其<strong>顺序必须与字段的顺序相对应</strong>。其中的每一列的数据可以是一个变量、常量、表达式或者null。但是其<strong>数据类型要与对应的字段类型相匹配</strong>；也可以使用 <code>default</code> 关键字，表示为该列插入默认值，但是前提是已经明确指定了默认值，否则会出错。</p>
</li>
<li><p>插入完整数据：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'qiuyue'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>插入数据记录的一部分：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">'qiuyue'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>插入查询结果：MySQL 支持将查询结果插入到数据表中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 数据表名[(字段名,...)] <span class="keyword">select</span> ...;</span><br></pre></td></tr></table></figure>
<p><strong>select 字句返回的结果集中的字段数量、字段类型必须与目标数据表完全一致。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (username,age) <span class="keyword">select</span> username,age <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 数据表名</span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span>=值<span class="number">1</span>[,字段<span class="number">2</span>=值<span class="number">2</span> ...]</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [<span class="keyword">limit</span> 行数]</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> username = <span class="string">'qiuyue'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 数据表名</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [<span class="keyword">limit</span> 行数];</span><br></pre></td></tr></table></figure>
<p><strong>如果没有指定 <code>where</code> 条件，将删除所有记录</strong>。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果要删除所有行，还可以使用 <code>truncate table</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> [<span class="keyword">table</span>] 数据表名</span><br></pre></td></tr></table></figure>
<p><code>truncate</code> 会<strong>删除数据表中所有数据且无法恢复</strong>。<br><code>delete</code> 与 <code>truncate</code> 区别如下：</p>
<ol>
<li>使用 <code>truncate</code> 语句会重新设置 <code>auto_increment</code> 计数器的初始值</li>
<li>对于参与了索引和视图的表不能使用 <code>truncate</code> 语句</li>
<li><code>truncate</code> 比 <code>delete</code> 使用的系统和事物资源少。每删除一条记录 <code>delete</code> 语句都会添加一条日志，而 <code>truncate</code> 只在事物日志中记录页的释放。</li>
</ol>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> selection_list</span><br><span class="line"><span class="keyword">from</span> 数据表名</span><br><span class="line"><span class="keyword">where</span> primary_constraint</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sroting_cloumns </span><br><span class="line"><span class="keyword">having</span> secondary_constraint</span><br><span class="line"><span class="keyword">limit</span> <span class="keyword">count</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询一张表的一列或多列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>; //查询users表所有内容</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,age <span class="keyword">from</span> <span class="keyword">users</span>; //查询users表id列和age列所有内容</span><br></pre></td></tr></table></figure>
<ul>
<li>从多个表中获取数据：</li>
</ul>
<p>使用 <code>select</code> 语句进行多表查询，需要确定所查询的数据在哪个表中，多个表之间用 <code>,</code>分隔：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> users.id, users.name, student.id, student.name</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>, student;</span><br></pre></td></tr></table></figure>
<p>还可以在 <code>where</code> 子句中用连接符 <code>=</code> 来确定表之间的联系。然后根据这个条件返回查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> users.name,student.location <span class="keyword">from</span> <span class="keyword">users</span>,studnet <span class="keyword">where</span> users.id=student.id <span class="keyword">and</span> users.id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>users.id=student.id</code> 表示将 users 和 student 两张表根据 <code>users.id=stduent.id</code> 的条件连接起来，叫做等同连接。如果不使用 <code>users.id=stduent.id</code> 那么产生的结果是两张表的笛卡尔积，叫全连接。</p>
<ul>
<li>带关键字 in 的查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 [<span class="keyword">not</span>] <span class="keyword">in</span> (元素<span class="number">1</span>，元素<span class="number">2</span> ...);</span><br></pre></td></tr></table></figure>
<p>关键字 <code>in</code> 可以判断某个字段的值是否在指定的集合中，如果在该记录会被查询出来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'Mike'</span>, <span class="string">'David'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>带关键字between…and…的范围查询：between…and… 是<strong>前闭后闭</strong>的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>带like的字符匹配查询：通过 <code>like</code> 可以实现模糊查询，它有两种通配符 <code>%</code> 和 <code>_</code>:<ul>
<li>% 可以匹配 0 个或多个字符，可以代表任意长度的字符串。如 “Mi%ke” 可以匹配Mike，Miosfke等</li>
<li>_ 最多只能匹配一个字符。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">"Jack_a"</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> studnet <span class="keyword">where</span> location <span class="keyword">like</span> <span class="string">"China\_%"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>group by 分组查询</li>
</ul>
<p>通过关键字 <code>group by</code> 可以将数据划分到不同的组中，实现对记录的分组查询。常搭配 count(), sum(), avg(), max(), min() 等聚合函数使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br><span class="line"><span class="keyword">select</span> class_id, <span class="keyword">count</span>(*) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br></pre></td></tr></table></figure>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接是把不同表的记录连接在一起的最普遍的方法。</p>
<ul>
<li>内连接查询：把不符合连接条件的行从视图中删除，最常见的例子是相等查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,s.age,s.class_id,c.name <span class="keyword">as</span> class_name </span><br><span class="line"><span class="keyword">from</span> students <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">join</span> classes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">on</span> s.class_id = c.id <span class="keyword">and</span> s.id &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>左外连接：返回结果除了内连接的数据外，还包括左表中不符合条件的数据，并在右表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>
<ul>
<li>右外连接：返回结果除了内连接的数据外，还包括右表中不符合条件的数据，并在左表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>
<h1 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h1><p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。  </p>
<p><img src="https://i.loli.net/2019/02/24/5c720eb160e17.jpg" alt="执行顺序">  </p>
<p>下面来分析一下这些语句：  </p>
<ol>
<li>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li>ON: 对虚表VT1进行ON筛选，只有那些符合 <join-condition> 的行才会被记录在虚表VT2中。</join-condition></li>
<li>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3,如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合 <where-condition> 的记录才会被插入到虚拟表VT4中。</where-condition></li>
<li>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li>HAVING： 对虚拟表VT6应用having过滤，只有符合 <having-condition> 的记录才会被 插入到虚拟表VT7中。</having-condition></li>
<li>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li>ORDER BY: 将虚拟表VT9中的记录按照 &lt;order_by_list&gt; 进行排序操作，产生虚拟表VT10.</li>
<li>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。  </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/31/《MySQL从入门到精通》之基本语句/" data-id="ckoqt9nwc002wb0upxwjx649f" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-进程与线程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2018/01/09/进程与线程/">进程间通信——以Python为例</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2018/01/09/进程与线程/" class="article-date">
  <time datetime="2018-01-09T13:18:09.000Z" itemprop="datePublished">2018-01-09</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>需要创建多个进程时，可以使用 multiprocessing 中的 Pool 类开进程池。Pool() 默认开启数量等于当前 cpu 核心数的子进程（当然可以手动改变）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"hello ,this is the %d process"</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = Pool()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        p.apply_async(target=hell0,args=(i,))</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>apply_async 表示在开进程时不阻塞主进程，是异步 IO 的一种方式之一。targe 参数传入要在子线程中执行的<strong>函数对象</strong>，args以元组的方式传入函数的参数。<br>join() 会等待线程池中的每一个线程执行完毕，在 join() 之前必须要先 close()，close() 表示不能再向线程池中添加新的 process 了。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。Python 提供了多种进程通信的方式，其中以 Queue 和 Pipe 用得最多。下面分别介绍这两种模式。</p>
<h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>让操作系统维持一块共享内存，所有要互相通信的进程通过这块内存交换信息。这样做的缺点是要格外注意数据同步问题。</p>
<p>下面以 Python 中 Queue 为例子做一个示范。Queue 是一种多进程安全的队列，其实现多进程间的通信有两种方法：</p>
<ul>
<li>get() 用于向队列中加入数据。有两个属性：blocked 和 timeout。blocked 为 true 时（默认为True）且 timeout 为正值时，如果当队列已满会阻塞 timeout 时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出 Queue.Full 异常。</li>
<li>put() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked 和timeout。blocked 为 true（默认为True）且 timeout 为正值时，如果当前队列为空会阻塞 timeout 时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出 Queue.Empty 异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_data</span><span class="params">(q,nums)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这是一个put进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        q.put(num)</span><br><span class="line">        print(<span class="string">'%d已经放入队列中啦！'</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这是一个get进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'已经从队列中获取%s并从中删除'</span> % q.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p1 = Process(target=put_data,args=(q,[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>],))</span><br><span class="line">    p2 = Process(target=put_data,args=(q,[<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>],))</span><br><span class="line">    p3 = Process(target=get_data,args=(q,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># p3是个死循环，需要手动结束这个进程</span></span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>
<p>我们来看一下运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">现在的进程编号为：10336，这是一个put进程</span><br><span class="line">1已经放入队列中啦！</span><br><span class="line">2已经放入队列中啦！</span><br><span class="line">3已经放入队列中啦！</span><br><span class="line">现在的进程编号为：9116，这是一个get进程</span><br><span class="line">已经从队列中获取1,并从中删除</span><br><span class="line">已经从队列中获取2并从中删除</span><br><span class="line">已经从队列中获取3并从中删除</span><br><span class="line">现在的进程编号为：2732，这是一个put进程</span><br><span class="line">4已经放入队列中啦！</span><br><span class="line">5已经放入队列中啦！</span><br><span class="line">已经从队列中获取4,并从中删除</span><br><span class="line">6已经放入队列中啦！</span><br><span class="line">已经从队列中获取5并从中删除</span><br><span class="line">已经从队列中获取6并从中删除</span><br></pre></td></tr></table></figure>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>操作系统在两个进程间维持一个“管道”，这两个进程通过这条管道交换彼此的信息。这样做缺点很多，比如只能在两个进程间交换数据、容易引起阻塞等。</p>
<p>下面以 Python 中 Pipe 为例子做一个示范。Pipe 就像一根水管，两边是进程。让我们看看Pipe官方文档的描述：  </p>
<blockquote>
<p>Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.</p>
</blockquote>
<p>Pipe 返回 conn1 和 conn2 代表水管的两端。Pipe 还有一个参数 duplex，默认为 True。当 duplex 为 True 时，开启双工模式，此时水管的两边都可以进行收发。当 duplex 为 False，那么 <strong>conn1 只负责接受信息，conn2 只负责发送信息。</strong><br>conn 通过 send() 和 recv() 来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv() 会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Pipe</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_data</span><span class="params">(p,nums)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这个一个send进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        p.send(num)</span><br><span class="line">        print(<span class="string">'%s已经放入管道中啦！'</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(p)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这个一个recv进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'已经从管道中获取%s并从中删除'</span> % p.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pipe(duplex=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 此时Pipe[1]即是Pipe返回的conn2</span></span><br><span class="line">    p1 = Process(target=put_data,args=(p[<span class="number">1</span>],[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>],))</span><br><span class="line">    <span class="comment"># 此时Pipe[0]即是Pipe返回的conn1</span></span><br><span class="line">    p3 = Process(target=get_data,args=(p[<span class="number">0</span>],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>
<p>让我们看一下输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">现在的进程编号为：9868，这个一个recv进程</span><br><span class="line">现在的进程编号为：9072，这个一个send进程</span><br><span class="line">1已经放入管道中啦！</span><br><span class="line">已经从管道中获取1,并从中删除</span><br><span class="line">2已经放入管道中啦！</span><br><span class="line">已经从管道中获取2并从中删除</span><br><span class="line">3已经放入管道中啦！</span><br><span class="line">已经从管道中获取3并从中删除</span><br></pre></td></tr></table></figure>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>多线程中任务中，可能会发生多个线程同时对一个公共资源（如全局变量）进行操作的情况，这是就会发生混乱。为了避免这种情况，需要引入线程锁的概念。只有一个线程能处于上锁状态，当一个线程上锁之后，如果有另外一个线程试图获得锁，该线程就会挂起直到拥有锁的线程将锁释放。这样就保证了同时只有一个线程对公共资源进行访问或修改。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">puls</span><span class="params">()</span>:</span></span><br><span class="line">    lock = Lock() <span class="comment"># 获得一个锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    print(num)</span><br><span class="line">    lock.release() <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = Thread(target=plus)</span><br><span class="line">        t.start()</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<p>锁的好处:</p>
<ol>
<li>确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。  </li>
</ol>
<p>锁的坏处:  </p>
<ol>
<li>阻止了多线程并发执行，效率大大降低。</li>
<li>由于存在多个锁，不同的线程持有不同的锁并试图获取对方的锁时，可能造成死锁。  </li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>线程其实并没有主次的概念，我们一般说的‘主线程’实际上是 main 函数的线程，而所谓主线程结束子线程也会结束是因为在主线程结束时调用了系统的退出函数。而守护线程是指 <code>不重要线程</code>。主线程在所有 <code>重要</code> 线程结束后结束。通常当客户端访问服务器时会为这次访问开启一个守护线程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n=x+y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    t = Thread(target=count,args=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    t.setDaemon = <span class="literal">True</span> <span class="comment"># 设为守护进程</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">进程和线程的区别</a></p>
<p><a href="https://blog.csdn.net/qq_32131499/article/details/94561780" target="_blank" rel="noopener">写时复制</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/09/进程与线程/" data-id="ckoqt9nta000rb0up6uk29m3n" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-重新开始" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2017/12/02/重新开始/">重新开始</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2017/12/02/重新开始/" class="article-date">
  <time datetime="2017-12-02T14:16:25.000Z" itemprop="datePublished">2017-12-02</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/矫情/">矫情</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>前阵子手贱删了博客文件，还糊里糊涂地把coding里的项目也删了。然后各种蜜汁错误，各种无法重新部署。最近几天又蜜汁部署成功。可以说十分难受了。</p>
<p><img src="重新开始/扶墙吐血.jpg" alt></p>
<p>不过塞翁失马，焉知非福。经过这么一遭我再次练习了一遍coding+hexo下博客的部署，也算是好事一桩了吧？（强行自我安慰一波233）<br>以后我一定天天向上，重新做人，再不手贱。</p>
<p><img src="重新开始/跪地哭.jpg" alt></p>
<p>再次感谢王哥的教程，很详细，帮助很大，很好，很棒。感兴趣的同志可以去他那里转转呀（手动滑稽）<a href="http://windliang.cc" target="_blank" rel="noopener">windliang的博客</a></p>
<p>扯到这里算是暂时结束，以后有时间再上来扯扯淡，写点学习心得啥的吧。</p>
<p><img src="重新开始/溜了.jpg" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/02/重新开始/" data-id="ckoqt9ntc000tb0up7dxrwqcs" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/闲聊/">闲聊</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>
  
</section>
</div>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>精神的壳 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="精神的壳"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/copybtn.js"></script>




<script src="/js/ocean.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>