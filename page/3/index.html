<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
<meta property="og:type" content="website">
<meta property="og:title" content="精神的壳">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="精神的壳">
<meta property="og:description" content="高山仰止，景行行止。虽不能至，心向往之。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="精神的壳">
<meta name="twitter:description" content="高山仰止，景行行止。虽不能至，心向往之。">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>精神的壳</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">精神的壳</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/网络那些事应用层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/07/网络那些事应用层/" class="post-title-link" itemprop="url">网络那些事之应用层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-07 21:53:17" itemprop="dateCreated datePublished" datetime="2018-06-07T21:53:17+08:00">2018-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-20 18:17:58" itemprop="dateModified" datetime="2020-01-20T18:17:58+08:00">2020-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络应用结构"><a href="#网络应用结构" class="headerlink" title="网络应用结构"></a>网络应用结构</h1><ul>
<li>客户机/服务器结构（C/S）</li>
<li>点对点结构（P2P）</li>
<li>混合结构（综合 C/S 与 P2P）</li>
</ul>
<p>应用层是程序员最常接触的层次，应当非常熟悉。</p>
<h2 id="端系统间的进程通信"><a href="#端系统间的进程通信" class="headerlink" title="端系统间的进程通信"></a>端系统间的进程通信</h2><p>一个进程可以理解为运行在端系统中的的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。而在不同的端系统上，通过跨越计算机网络交换<code>报文</code>实现进程间的通信。</p>
<p>多数应用程序由通信进程对组成，每对中的两个进程互相发送报文，从一个进程向另一个进程发送报文就必须经过下面的计算机网络。进程通过一个被称为<code>套接字</code>的软件接口向网络发送报文和接受报文。<code>套接字</code>类似于一栋屋子的门，无论是要进入屋子还是离开屋子，都要进过门。<code>套接字</code>是应用层与运输层的接口。在运输层，开发者对于<code>套接字</code>几乎没有控制权，只能</p>
<ol>
<li>选择运输层协议</li>
<li>设定几个参数，如最大缓存、最大报文段长度等</li>
</ol>
<h3 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h3><p>套接字是一种应用编程接口（API），不同主机的应用进程间通信的抽象机制。应用进程通过套接字将数据控制权转移给操作系统，以实现信息从应用层到传输层的转换。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>每个应用进程都可能对应一个或多个套接字。为了区分不同套接字，操作系统给每个套接字绑定一个 16 位整数（0——65535），称之为<strong>端口号（port）</strong>。</p>
<p>对外标识通信端点：IP Address + port。</p>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>为了与另一个端系统通信，必须知道：</p>
<ol>
<li>另一端系统的地址</li>
<li>定义在目的端系统中的接收进程的标志符</li>
</ol>
<p>端系统地址由<code>IP地址</code>确定，而接收进程标志符由<code>端口</code>确定。</p>
<p>操作系统对内标识套接字：<strong>套接字描述符（socket descriptor）</strong>，非常类似于文件的抽象机制。每个进程有一个套接字描述符表，进程每创建一个套接字都会在表里增加一个条目，每个条目对应一个套接字数据结构指针。</p>
<p><img src="https://i.loli.net/2019/12/21/LEHvFzdNowkq6Bc.png" alt="套接字描述符表"></p>
<p>地址族（family）：不同传输协议下主机的端点形式不同，用地址族区分不同的传输协议。</p>
<p>类型（service）：区分某一传输协议下的不同协议。</p>
<p><img src="https://i.loli.net/2019/12/21/4vTABxRFnmIgh9Q.png" alt="协议类型"></p>
<h2 id="几种常见的应用层协议"><a href="#几种常见的应用层协议" class="headerlink" title="几种常见的应用层协议"></a>几种常见的应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（超文本传输协议）是 Web 的核心。在 Web 应用中，客户与服务器之间是通过 HTTP 报文进行会话的。而HTTP协议定义了报文格式与交换方式。Web 服务器实现了 HTTP 的服务器端，用于存储 Web 对象，每个对象由 url 寻址。</p>
<p><img src="https://i.loli.net/2020/01/20/9MTnkYv5yfxOL1u.png" alt="HTTP请求格式"></p>
<p><img src="https://i.loli.net/2020/01/20/StgFZXMs5GIbwYc.png" alt="HTTP响应格式"></p>
<p>HTTP 使用<code>TCP</code>作为它的支撑运输协议，默认采用<code>带流水机制的持久性连接</code>。 一次完整的<code>请求——响应</code>流程是这样的：</p>
<ol>
<li>HTTP客户端首先发起一个与服务器的 TCP 连接，一旦连接建立，该客户端进程与服务器进程就可以通过套接字接口通信。</li>
<li>客户端向它的<code>套接字</code>接口发送 HTTP 请求报文。</li>
<li>服务器收到 HTTP 请求报文并生成相应的响应报文，通过服务器的<code>套接字</code>发送响应报文。</li>
<li>客户端从<code>套接字</code>接受响应报文。</li>
<li>所有报文传输结束，关闭 TCP 连接。</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 是无状态协议，不记录客户端的历史行为，换言之对服务器而言每个 HTTP 请求都是独立的，不和历史请求有任何关系。为了辨别用户身份，维持 session，cookie 应运而生，它是一小段储存在客户端且通常经过加密的数据。</p>
<p>Cookie 在 HTTP 协议中以头部行的形式传输，由服务器设置，被客户端（通常是浏览器）保存在本地。</p>
<p><img src="https://i.loli.net/2020/01/20/wvu6zqyA9rKFDib.png" alt="Cookie原理"></p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>通过 SMTP（简单邮件传输协议）实现发送邮件。因特网电子邮件系统由 3 部分组成：</p>
<ul>
<li>用户代理。常见的邮件客户端如 Outlook 等都是用户代理，如果是通过 Web 端发送邮件，那么浏览器是用户代理。用户代理负责读写邮件、与邮件服务器交互</li>
<li>邮件服务器。通常由企业提供，如 QQ 邮箱的服务器<code>smtp.qq.com</code>，126 邮箱服务器<code>smtp.126.com</code></li>
<li>SMTP。负责在邮件服务器之间发送邮件</li>
</ul>
<p>一个典型的发送邮件的过程是：</p>
<ol>
<li>从发送方的用户代理开始，传输到发送方的邮件服务器</li>
<li>从发送方的邮件服务器发到接收方的邮件服务器，然后被分发到接收方的邮箱中</li>
<li>接收方通过用户代理从邮箱获取邮件</li>
</ol>
<p>SMTP 是因特网电子协议中的主要应用层协议，它用 TCP 提供可靠数据传输服务。</p>
<p>SMTP 规定邮件报文首部必须包含关键字<code>From:</code>与<code>To:</code>，可以包含关键字<code>Subject:</code>。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>如果把客户向服务器发送报文比作打电话，那么服务器的IP地址是电话号码，域名是号码主人的姓名，而 DNS（Domain Name System 域名系统）就是电话簿，把姓名和电话号码联系起来。</p>
<p>DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>DNS提供的服务有：</p>
<ul>
<li>域名解析服务</li>
<li>主机别名服务</li>
<li>邮件服务器别名服务</li>
<li>负载均衡。将一个域名与多个IP地址对应起来，当客户对域名发出一个DNS请求时，每次响应都循环<br>这些IP地址的次序。由于客户总是向排在最前面的IP地址发送HTTP请求，由此实现了负载均衡。</li>
</ul>
<p>获得一个域名的 IP 地址的过程如下：</p>
<ol>
<li>浏览器把域名发送到用户主机上的DNS客户端 </li>
<li>DNS 客户端向 DNS 服务器发送一个包含主机名的请求</li>
<li>DNS 服务器通过查询相应的域名——&gt; I 地址间的映射关系，生成一个响应报文并返回</li>
<li>DNS 客户端收到响应报文，把报文中的IP地址传给浏览器</li>
</ol>
<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>多层命名服务器构成的<strong>分布式</strong>数据库。属于应用层协议，负责域名解析功能。  </p>
<h4 id="分层式层次式数据库"><a href="#分层式层次式数据库" class="headerlink" title="分层式层次式数据库"></a>分层式层次式数据库</h4><p>第一层：根域名服务器（root）</p>
<p>第二层：顶级域名服务器（top-level domain，TLD），负责 com，org，cn，jp 等</p>
<p>第三层：权威域名服务器（authoritative），负责组织域名解析，如 alibaba，baidu 等</p>
<p><img src="https://i.loli.net/2019/12/21/gXAveHhuimtyWl5.png" alt="分层结构"></p>
<p>举个例子：客户端访问 <a href="www.baidu.com">www.baidu.com</a>。</p>
<ol>
<li>向根域名服务器发送查询请求。根域名服务器返回 com 域名服务器地址。</li>
<li>向 com 域名服务器发送查询请求。com 域名服务器返回 baidu.com 域名服务器地址。</li>
<li>向 baidu.com 域名服务器发送查询请求。baidu.com 域名服务器返回 w<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 地址。</li>
</ol>
<p><strong>本地域名服务器：</strong> 不严格属于层级体系，每个 ISP 有一个本地域名服务器，是该 ISP 用户的默认域名解析服务器。作为代理将该 ISP 用户的查询转发给域名解析服务器系统。</p>
<h4 id="为什么不用采用集中式架构"><a href="#为什么不用采用集中式架构" class="headerlink" title="为什么不用采用集中式架构"></a>为什么不用采用集中式架构</h4><ul>
<li>单点失败问题</li>
<li>流量问题</li>
<li>距离问题</li>
<li>维护性问题</li>
</ul>
<p>不可伸缩！</p>
<h4 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h4><ul>
<li><p>迭代查询。用户的查询被转发到本地域名服务器上，本地域名服务器依次访问 3 层域名解析服务器系统。</p>
</li>
<li><p>递归查询。用户的查询被转发到本地域名服务器上，本地域名服务器访问根域名服务器，根域名服务器访问顶级域名服务器，顶级域名服务器访问权威域名服务器。最后的查询结果依次返回给上一层。</p>
</li>
</ul>
<h4 id="DNS-缓存与更新"><a href="#DNS-缓存与更新" class="headerlink" title="DNS 缓存与更新"></a>DNS 缓存与更新</h4><p>一段时间后，缓存条目会失效。本地域名服务器一般会缓存顶级域名服务器地址，所以根域名服务器较少被访问。</p>
<h4 id="DNS-记录与格式"><a href="#DNS-记录与格式" class="headerlink" title="DNS 记录与格式"></a>DNS 记录与格式</h4><p>DNS 记录又称资源记录（RR，Resource Record）。是一个四元组：<strong>（name，value，type，ttl）</strong>。</p>
<ul>
<li>type=A：name=主机域名，value=IP 地址。</li>
<li>type=NS：name=域（edu.cn、qiuyueqy.com），value=该域的权威域名解析服务器的主机域名。</li>
<li>type=CNAME：name=某真实域名的别名，value=真实域名。</li>
<li>type=MX：name=域（126.com，163.com）,value=与name对应的邮件服务器.</li>
</ul>
<h4 id="为什么在应用层实现"><a href="#为什么在应用层实现" class="headerlink" title="为什么在应用层实现"></a>为什么在应用层实现</h4><p>我们希望把复杂的东西尽量放在端系统实现。在应用层实现 DNS 协议有利于降低网络核心的复杂度。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>由上可知，为了获取一个DNS地址进行了很多次请求，这就影响了速度。为了加快响应速度，DNS服务器有缓存机制：在一个请求链中，当某DNS服务器接收到一个DNS回答，它能将该回答中的信息缓存到本地存储器中，类似于Web缓存器。在一段时间（默认为两天）后将缓存信息丢弃。</p>
<h4 id="DNS劫持与污染"><a href="#DNS劫持与污染" class="headerlink" title="DNS劫持与污染"></a>DNS劫持与污染</h4><p>DNS 污染是指服务器检测到用户访问特定的主机时，伪装成 DNS 服务器向用户返回错误IP地址。国内用户访问 youtube 等网站时就会遇到这种情况</p>
<p>DNS 劫持是通过劫持特定的DNS服务器，在 DNS 服务器里存放错误的缓存信息，这样 DNS 服务器就会向用户返回错误的 IP 地址</p>
<p>对于 DNS 劫持，可用采用更换默认 DNS 服务器的方式解决。而 DNS 污染只能通过修改 hosts 文件、VPN 等方式绕过服务器</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>P2P（Peer to Peer）应用的几个特点：</p>
<ul>
<li>没有服务器</li>
<li>任意端系统之间直接互联</li>
<li>节点阶段性接入Intent</li>
<li>节点可能更换IP地址</li>
</ul>
<h3 id="网关-gateway"><a href="#网关-gateway" class="headerlink" title="网关(gateway)"></a>网关(gateway)</h3><p>在一个局域网内互相通信是不需要用到网关的，而局域网内的接口要访问外网时，则需要把请求发送到网关上，由网关负责向外发送流量。同理，外网的信息也是通过网关再传达给内网接口</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/04/网络那些事基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/04/网络那些事基本概念/" class="post-title-link" itemprop="url">网络那些事之基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-04 19:31:43" itemprop="dateCreated datePublished" datetime="2018-06-04T19:31:43+08:00">2018-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-30 16:43:09" itemprop="dateModified" datetime="2020-01-30T16:43:09+08:00">2020-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>计算机网络是一个自治的、互联的计算机集合。</p>
<h1 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h1><p>因特网是一个世界范围的计算机网络，是“网络的网络”。由十多个第一层<code>ISP(因特网服务提供商)</code>和数十万个底层 ISP 组成。ISP 覆盖区域有所不同，有些跨越多个大洲和大洋，有些限于很小的地理区域。低层 ISP 与高层 ISP 互联，高层ISP彼此互联。</p>
<h2 id="端系统"><a href="#端系统" class="headerlink" title="端系统"></a>端系统</h2><p>所有连接到因特网的设备都称为<code>主机</code>或<code>端系统</code>。</p>
<p>端系统通过<code>通信链路</code>和<code>分组交换机</code>连接到一起。通俗的讲通信链路就是一条条光缆、网线等物理线路，不同的链路能以不同的速率传输数据，链路的传输速率单位为<code>bit/s或bps</code>，即<code>比特/秒</code>。端系统通过 ISP 接入因特网。</p>
<p>当一台端系统向另一台端系统发送数据时，发送端系统将数据将数据分段，并为每段加上首部字节。由此形成的信息包称为<code>分组</code>。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。目前最出名的两种分组交换机类型是<code>路由器</code>和<code>链路层交换机</code>。这两种类型的交换机朝着最终的目的地转发分组。链路层交换机常用于接入网中，而路由器常用于网络核心中。从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的<code>路径</code>。</p>
<p>与因特网相连的端系统提供了<code>应用程序编程接口(API)</code>,该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合。类似于我们在寄信的时候需要遵邮局的规定贴上邮票、写上邮政编码等，这些规定就是 API。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>常把与因特网相连的设备称为端系统，因为它们位于网络的边缘。将端系统连接到其<code>边缘路由器</code>的物理链路称为<code>接入网</code>。<code>边缘路由器</code>是端系统到任何其他远程系统的路径上的第一台路由器。<br>除了端系统外，<code>网络应用</code>也处于网络边缘。网络应用通常有两种结构：</p>
<ul>
<li>客户——服务器结构（Client-Server）。常见的 Web 应用都是这种结构。这种应用的特点是客户只与服务器进行交互，只有客户可以主动发起连接。<strong>客户与客户之间是互不可见的</strong></li>
<li>P2P 结构（点对点结构）。这种结构是对等的，不存在客户和服务器的概念。各个端点之间可以直接互相访问。例子有文件共享服务如bt下载，所以才会有<strong>越多人下载速度越快</strong>的说法</li>
</ul>
<h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><p>当前宽带住宅接入有两种流行类型：</p>
<ul>
<li>数字用户线(Digital Subscriber Line，DSL)。即常说的拨号上网。利用DSL调制解调器将到达家庭的数据信号和电话信号分隔开（ADSL是非对称接入，即上行与下行速率是不同的，通常下行更快）</li>
<li>电缆（HFC,混合光纤同轴电缆网）。通过有线电视网络进行传输，用cable modem（即“猫”）将电视信号与网络信号分开。这也是非对称的，下行通常到30Mbts，上行为2Mbps</li>
<li>光纤到户。本地中心局直接提供了一条光纤线路到家庭。</li>
<li>LAN 无限局域网。在公司、大学和越来越多的家庭环境中，通常是用局域网(LAN)将端系统连接到边缘路由器。尽管有多种不同的局域网技术，但<code>以太网</code>是目前最流行的接入技术。在无线LAN环境中，无线用户从一个接入点发送/接受分租，接入点与企业网连接，该企业网再与有线因特网相连，这就是 wifi。可达 54Mbps</li>
<li>蜂窝网。蜂窝网也属于无线接入。所谓3G网4G网都属于蜂窝网。</li>
</ul>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p><code>网络核心</code>即互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<p>网络核心的关键功能是<code>路由</code>+<code>转发</code>。<code>路由</code>即确定分组从源到目的地的路径。</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数分组交换机在链路的输入端用<code>存储转发传输机制</code>：交换机能够在开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。由此存在<code>存储转发延时</code>：如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R bit/s，则分组在这条链路上的传输时间为 L/R 秒。</p>
<h3 id="排队延时和丢包"><a href="#排队延时和丢包" class="headerlink" title="排队延时和丢包"></a>排队延时和丢包</h3><p>每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个<code>输出缓存</code>用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某天链路但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，由此分组又存在<code>排队延时</code>。缓存空间是有限的，一个到达的分组可能发现该缓存已满，此时会发生<code>丢包(分组丢失)</code>：到达的分组或正排队的分组之一会被丢弃。</p>
<h3 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个被称为<code>IP地址</code>的地址。当源主机要向目的地端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个<code>转发表</code>，用于将目的地址映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发行适当的出链路。路由器则将分组导向该出链路。</p>
<h2 id="分组交换时延"><a href="#分组交换时延" class="headerlink" title="分组交换时延"></a>分组交换时延</h2><p>分组从一个主机出发通过一系列路由器传输，在另一台主机中结束它的历程。这个过程是存在时延的。其中最为重要的几种时延是<code>节点处理时延</code>、<code>排队时延</code>、<code>传输时延</code>、<code>传播时延</code>。这些延时加起来称为<code>节点总时延</code></p>
<ul>
<li>节点处理时延（nodal processing delay）。造成这部分时延的原因主要是检查分组首部（差错检测）和决定将该分组导向何处（确定输出链路）</li>
<li>排队时延（queueing delay）。链路繁忙时新到达交换机的分组会进入排队状态。</li>
<li>传输时延（transmission delay）。仅当所有先到达的分组传输完毕后才能传输刚到达的分组。传输时延是将该分组的所有比特推向链路所需要的时间。L 为分组长度，R 为链路带宽，则传输时延为 L/R</li>
<li>传播时延（propagation delay）。分组在链路上传播的时间称为传播时延。d 为链路长度，v 为传播速率，则传播时延为 d/v</li>
</ul>
<p>传输时延与传播时延不同之处在于传输时延是分组从交换机到链路的时间，与分组的大小有关，与两台路由器之间的距离无关。而传播时延是分组在链接上传播消耗的时间，与分组大小无关，与距离有关。</p>
<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><p>每层完成一类特定功能，底层为上层提供服务，相邻的两层通过<code>接口</code>进行交互，任一层实体提供的服务是<code>垂直的</code>。</p>
<p>计算机网络体系结构是计算机网络各层及其协议的集合。<strong>协议是控制两个对等实体进行通信的规则</strong>的集合，协议是<code>水平的</code>。</p>
<p><img src="https://i.loli.net/2020/01/19/JHuDU5ys3oX84IC.png" alt="OSI模型通信过程"></p>
<p>中间系统只实现网络层、链路层和物理层，这三层合称“非端到端层(non-end-end)”。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>数据在每一层都会被打上一个该层的附加信息（所谓运输首部信息），称为 PDU(Protocol Data Unit)。而这些信息会在下一层被使用。</p>
<p><img src="https://i.loli.net/2020/01/19/zK7oIaJw41ncGgY.png" alt="OSI模型封装过程"></p>
<h3 id="为什么要封装"><a href="#为什么要封装" class="headerlink" title="为什么要封装"></a>为什么要封装</h3><ul>
<li>增加控制信息：地址信息（表示发送、接受端），差错检测编码，优先级设置等</li>
</ul>
<h3 id="非端到端层"><a href="#非端到端层" class="headerlink" title="非端到端层"></a>非端到端层</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>规范接口特性：机械特性（形状，大小）、电气特性（电压、电频），功能特性（引脚）等</li>
<li>比特编码：如何表示 0 和 1</li>
<li>数据率：数据传输速率</li>
<li>传输模式：单工通信（单向），半双工通信（交替单向，发和收不同时），全双工通信（同时收发）</li>
</ul>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul>
<li>两个直接相连的结点间的数据帧传输。</li>
<li>物理寻址。在帧头增加收发端物理地址标识信息（通常为 MAC 地址）。</li>
<li>流量控制。匹配发送和接收速度，避免淹没接收端。</li>
<li>差错控制。判断丢失帧与重复帧。</li>
<li>访问控制。决定哪个设备拥有物理链路使用权。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>跨越多个网络的数据分组传输</li>
<li>逻辑寻址，全局唯一（通常为 IP 地址）。</li>
<li>路由：路径选择及分组转发。</li>
</ul>
<p><img src="https://i.loli.net/2020/01/19/Xjb7cGfD285kEev.png" alt="分组转发"></p>
<p>网络层地址不变，链路层地址随传输过程不断更新。</p>
<h3 id="端到端层"><a href="#端到端层" class="headerlink" title="端到端层"></a>端到端层</h3><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>源到目的端进程间报文传输。</p>
<ul>
<li>报文分段与重组</li>
<li>端口号寻址：确保将报文提交给正确进程。</li>
<li>连接控制：作为自下而上第一个端到端层次，建立或拆除端到端间的逻辑连接。</li>
<li>流量控制</li>
<li>差错控制（如 TCP）</li>
</ul>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>不对数据进行分段，只插入一些信息。</p>
<ul>
<li>对话控制：建立、维护进程间对话</li>
<li>同步：在数据流中插入同步点，便于恢复对话</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>处理两个系统间交换信息的语法语义问题（如大小端机器对数据的表示方式不同）。</p>
<ul>
<li>数据表示转化：发送端把信息转化为主机独立的编码，接收端转化为主机相关编码</li>
<li>加密解密</li>
<li>压缩解压缩</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>向用户提供网络服务接口（如浏览器），根据不同应用场景处理用户数据。</p>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p><img src="https://i.loli.net/2020/01/19/OMNn6oqPg4f9G7d.png" alt="TCP/IP模型"></p>
<h2 id="Internet五层协议"><a href="#Internet五层协议" class="headerlink" title="Internet五层协议"></a>Internet五层协议</h2><p>综合 OSI 与 TCP/IP</p>
<ol>
<li>应用层。应用层是网络应用程序及他们的应用层协议存留的地方。HTTP、SMTP、FTP、DNS等都属于应用层协议。分组在应用层中称为<code>报文</code></li>
<li>运输层。<strong>进程之间</strong>传送报文。在因特网中有两个运输协议<code>TCP</code>和<code>UDP</code>。分组在运输层中称为<code>报文段</code></li>
<li>网络层。<strong>主机之间</strong>数据分组与转发。网络层接受运输层递交的报文段和目的地址，类似于寄信时要向邮局提供目标地址。著名的<code>IP协议</code>就在网络层。该协议定义了数据报中的各个字段及端系统和路由器如何作用于这些字段，以达到<code>逻辑寻址</code>的目的。分组在网络层称为<code>数据报</code></li>
<li>链路层。将网络层的IP数据包组装成帧（帧包含数据和必要的控制信息，例如信道编码，卷积码，turbo码），在<strong>相邻网络元素</strong>之间传输。</li>
<li>物理层。物理层负责将帧一个比特一个比特地从一个节点移动到下一个节点。进一步与链路实体（如双通铜线、单模光缆）相关。传输数据为比特流，物理层需要定义比特传输的电气特性（多少电压代表1多少代表0）、机械特性（接口形状尺寸等），如USB、Bluetooth等。而传输物理介质如光纤、双绞线等并不处于物理层的范畴</li>
</ol>
<p><img src="https://i.loli.net/2020/01/19/i1bsCztfQAxcIyK.png" alt="五层模型数据封装"></p>
<p>下面是知乎一个有趣的例子：</p>
<blockquote>
<p>为了实现跨越互联网的，主机 A 的进程 P1，和主机 B 的进程 P2 之间的通信，我们逐层把这个任务交给 TCP/IP 协议栈。<br>运输层：“如果有人能帮我把数据从某个网络中的机器 A 搬到另一个网络中的机器 B，我就可以搞定这个任务，因为我知道不同的数据应该交给机器上的哪个进程。”<br>网络层：“如果有人能帮我把数据从局域网中直接相连的一台机器搬到另一台机器，我就可以把数据从一个网络搬到另一个网络，因为我知道路线怎么走，要经过哪些节点。”<br>链路层：“我知道怎样在局域网中搬数据，还能用 CSMA/CD 协议协调工作，还能用 CRC32 校验发送的数据和接收的数据是一致的，blabla… But，我只是说说，我不干苦力活。”<br>物理层：“楼上的大爷们发话了，兄弟们上。”</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/《MySQL从入门到精通》之备份与恢复/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/03/《MySQL从入门到精通》之备份与恢复/" class="post-title-link" itemprop="url">MySQL之备份与恢复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-03 19:35:59" itemprop="dateCreated datePublished" datetime="2018-06-03T19:35:59+08:00">2018-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 09:01:31" itemprop="dateModified" datetime="2020-03-12T09:01:31+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用mysqldump命令备份"><a href="#使用mysqldump命令备份" class="headerlink" title="使用mysqldump命令备份"></a>使用mysqldump命令备份</h1><p><code>mysqldump</code> 命令可以将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。</p>
<p>mysqldump的工作原理就是查出需要备份的数据库和表的结构，然后在文本文件中生成相应的 <code>create</code> 和 <code>insert</code> 语句。需要导入数据库文件时 MySQL 通过使用文本文件中记录的语句生成相应的数据库和表就可以了。</p>
<p>使用 <code>mysqldump</code> 命令进行数据备份时，经常分为以下3种形式：</p>
<ol>
<li>备份一个数据库</li>
<li>备份多个数据库</li>
<li>备份所有数据库</li>
</ol>
<p>下面分别介绍：</p>
<h2 id="备份一个数据库"><a href="#备份一个数据库" class="headerlink" title="备份一个数据库"></a>备份一个数据库</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -p dbname [table1 table2 ...] &gt; filename</span><br></pre></td></tr></table></figure>
<p>dbname 为数据库名。table1、table2 为表名，没有指定 table 时将备份整个数据库。filename为文本文件名称，通常使用<code>.sql</code>作为后缀。</p>
<p>例：备份数据库 users 中的 studnets 表到 D 盘的 sql 文件夹下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p users  students &gt; D:\sql\students.sql</span><br></pre></td></tr></table></figure>
<h2 id="备份多个数据库"><a href="#备份多个数据库" class="headerlink" title="备份多个数据库"></a>备份多个数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u username -p <span class="comment">--databeses dbname1 dbname2 &gt; filename</span></span><br></pre></td></tr></table></figure>
<p>加上 <code>databases</code> 选项，后面跟多个数据库名称</p>
<p>例：备份数据库 users、customers 到 D 盘：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--databeses users customers &gt; data.sql</span></span><br></pre></td></tr></table></figure>
<h2 id="备份所有数据库"><a href="#备份所有数据库" class="headerlink" title="备份所有数据库"></a>备份所有数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p <span class="comment">--all --databases &gt; filename</span></span><br></pre></td></tr></table></figure>
<h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p>使用 <code>mysql</code> 命令进行还原：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p [dbname] &lt; filename</span><br></pre></td></tr></table></figure>
<p>dbname 表示数据库名称，该参数是可选的。指定数据库名称时，表示还原该数据库下的表，不指定时表示还原数据库。</p>
<p>也可以在进入相应数据库后用 <code>source</code> 命令恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; source filename;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/《MySQL从入门到精通》之事件与优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/03/《MySQL从入门到精通》之事件与优化/" class="post-title-link" itemprop="url">MySQL之事务与优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-03 15:03:41" itemprop="dateCreated datePublished" datetime="2018-06-03T15:03:41+08:00">2018-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-21 00:24:32" itemprop="dateModified" datetime="2020-04-21T00:24:32+08:00">2020-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 MySQL 中，事务由一条或多条 SQL 语句组成，在这个事务中，每条 MySQL 语句是相互依赖的。而整个事务作为一个不可分割的整体，一旦某条 MySQL 语句执行失败或产生错误，整个事务将会回滚。</p>
<p>只有 <code>InnoDB</code> 类型的表支持事务。MySQL默认表类型为 <code>InnoDB</code>。</p>
<h2 id="事务的基本要素-ACID"><a href="#事务的基本要素-ACID" class="headerlink" title="事务的基本要素(ACID)"></a>事务的基本要素(ACID)</h2><ol>
<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。</li>
<li>隔离性（Isolation）：每个事务在自己的空间内执行，与其他事务隔离，而且事务的结果只有在它被完全执行时才能看到。这样即使一个系统同时发生多个事物，孤立性也可以保证特定的事务在完成之前其结果不被公布。</li>
<li>持久性（Durability）：事务提交之后，就一定是在硬盘永久的存储，而不会丢失。</li>
</ol>
<h2 id="事务的创建与存在周期"><a href="#事务的创建与存在周期" class="headerlink" title="事务的创建与存在周期"></a>事务的创建与存在周期</h2><p>创建事务的一般过程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化事务 ————&gt; 创建事务 ————&gt; 提交或回滚</span><br></pre></td></tr></table></figure>
<p><strong>无论最后是提交还是回滚，都会关闭这个事务</strong>。  </p>
<ul>
<li>初始化事务：<code>start transaction;</code> 或 <code>begin;</code>，MySQL默认是<strong>自动提交</strong>的，所以需要用命令改为手动模式</li>
<li>创建事务：执行 SQ L语句</li>
<li>提交或回滚： 提交 <code>commit;</code>，回滚 <code>rollback;</code></li>
</ul>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ol>
<li>脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时结果不一致。</li>
<li>幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h2 id="事务的隔离性等级"><a href="#事务的隔离性等级" class="headerlink" title="事务的隔离性等级"></a>事务的隔离性等级</h2><p>事务具有隔离的空间。在 MySQL 服务器中，用户通过不同的会话执行不同的事务，在多用户环境中，许多 RDBMS（关系型数据库管理系统）会话在任意时刻都是活动的。为了使这些事务互不影响，保证数据库性能不受影响，采用事务的孤立等级是很重要的。</p>
<p>如果没有孤立性，不同的查询操作会在同一事务的环境中检索到不同的结果，这将导致数据的不一致性。</p>
<ol>
<li>序列化(serializable)：以序列的形式对事务进行处理。该孤立级的特定是只有当事务提交后，用户才能从数据库上查看数据的变化。。</li>
<li>可重读(repeatale read)：对应于程序的安全性做出部分妥协，以提高性能。事务在孤立级上不会被看成一个序列，不过在当前执行的事务过程中，用户依然看不到事务的过程。直到事务提交为止，用户才能看到事务的变化结果。（客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前是看不到改变的）</li>
<li>读已提交(read committed)：该孤立级的安全性比可重读低。在这一级事务用户可以看到其他事务添加到新纪录。在事务处理时如果存在其他用户同时对事务的相应表进行修改那么在同一事务的不同时间内，查询操作可能返回不同的结果(客户端 A、B 同时开启事务，B 向表中插入数据行且提交后，A 在自己提交前可以看到改变)</li>
<li>读未提交(read uncommitted)：该孤立级提供事务之间最小程度间隔，该孤立级容易产生幻读。其他用户可以在该孤立级上看到未提交的事务。(客户端 A、B 同时开启事务，B 向表中插入数据行且未提交，A 也可以看到改变)</li>
</ol>
<table>
<thead>
<tr>
<th>孤立等级</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>序列化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>可重读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>读已提交</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>设置事务的隔离等级：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> ...;</span><br></pre></td></tr></table></figure>
<h2 id="事务的性能"><a href="#事务的性能" class="headerlink" title="事务的性能"></a>事务的性能</h2><h3 id="应用小事务"><a href="#应用小事务" class="headerlink" title="应用小事务"></a>应用小事务</h3><p>应用小事务的意义在于保证每个事务不会在执行前等待很长时间，从而避免各个事务因为互相等待而导致系统性能大幅度下降。应尽量缩短 <code>insert</code>、<code>update</code> 等操作与 <code>commit</code> 之间的间隔时间。</p>
<h3 id="合适的孤立级"><a href="#合适的孤立级" class="headerlink" title="合适的孤立级"></a>合适的孤立级</h3><p>事务的性能与其对服务器产生的负载成反比，即事务孤立级越高，其性能越低。例如序列化虽然很稳定，但是会大大影响 MySQL 的性能，生产中比较少用，而用乐观锁悲观锁解决幻读等问题</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>当两个或多个处于不同序列的用户打算同时更新某相同数据库时，因互相等待对方释放权限而导致双方一直处于等待状态。两个不同序列的客户端同时对数据执行操作极有可能产生死锁。更通俗地讲，当两个事物相互等待操作对方释放所持有的资源而导致两个事务都无法操作对方持有的资源，这样无限期的等待称为死锁。</p>
<p>InnoDB具有检查死锁的功能。如果发现产生了死锁，InnoDB会立刻撤销其中一个任务以便死锁消失。这样就可以使另一个事务获取对方所占有的资源而执行操作逻辑。</p>
<h2 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h2><ul>
<li>使用索引.<strong>对于新表可以先不创建索引，等数据导入后在创建，这样可以提高数据导入效率</strong>。一般来说，索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况</li>
<li>尽量少用 <code>like</code> 语句与通配符 <code>%</code></li>
<li>选取最合适的字段大小。表越小，速度越快。所以能用 <code>char</code> 就不要用 <code>varchar</code> ，能用 <code>mediumint</code> 就不用 <code>bigint</code>。<strong>尽量使用 <code>not null</code> 这样在查询时数据库不用去比较null值。</strong></li>
<li>用 <code>join</code> 代替子查询。这样 MySQL 不需要在内存中创建临时表来完成逻辑上的需要两个步骤的查询工作。。</li>
<li>优化 insert 语句。一次插入多条数据比每次插入一条数据快。能用 <code>union</code> 将多条 <code>select</code> 结合就不要单独用多次 <code>select</code></li>
<li>使用事务。我们可以使用子查询、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。这时候就要用到事务。</li>
<li>用外键分解表中低频字段。有些字段的使用频率很低，当表的数据量很大时查询速度会很慢。用外键将这些字段拆分成一个单独的表可以提高效率。</li>
<li>在相同类型的字段间进行比较的操作</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/mysql定义完整性约束/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/30/mysql定义完整性约束/" class="post-title-link" itemprop="url">MySQL之完整性约束</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-30 20:19:42" itemprop="dateCreated datePublished" datetime="2018-05-30T20:19:42+08:00">2018-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-18 20:03:32" itemprop="dateModified" datetime="2018-06-18T20:03:32+08:00">2018-06-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MySQL提供了多种完整性约束，作为数据库关系模式定义的一部分，可以通过<code>create table</code>或<code>alter table</code>语句来定义。一旦定义了完整性约束，MySQL服务器会随时检测处于更新状态的数据库内容是否符合相关的完整性约束，从而保证数据的一致性与正确性。</p>
<p>在关系模型中，提供了实体完整性、参照完整性和用户完整性3项规则。</p>
<h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p><code>实体</code>是一个数据对象，是指客观存在并可以相互区分的事物，如一个教师、一个学生等。一个实体在数据库中表现为一条记录。</p>
<p>实体完整性是指关系的主属性及主键的组成不能为空。也就是主键不能使空值null。关系对应于现实世界的实体集，而现实世界的实体是可以区分的，即说明每个实例具有唯一性标识。在关系模型中，是使用主键作为唯一性标识的。</p>
<p>先来认识一下关系型数据库中重要的三个键：</p>
<ul>
<li>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 </li>
<li>候选键(candidate key):不含有多余属性的超键称为候选键 </li>
<li>主键(primary key):用户选作元组标识的一个候选键程序主键</li>
</ul>
<p>在MySQL中，实体完整性是通过<em>主键约束</em>和<em>候选键约束</em>实现的。</p>
<h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中多个列组合而成的主键也被称为复合主键。在MySQL中，主键必须遵循如下规则：</p>
<ol>
<li>每个表只能定义一个主键</li>
<li>主键必须能唯一标识表中的每一行记录并且不能为null</li>
<li>复合主键不能包含不必要的多余列</li>
<li>一个列名在复合主键的列表中只能出现一次</li>
</ol>
<h3 id="作为列的主键约束"><a href="#作为列的主键约束" class="headerlink" title="作为列的主键约束"></a>作为列的主键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="作为表的主键约束"><a href="#作为表的主键约束" class="headerlink" title="作为表的主键约束"></a>作为表的主键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>如果主键仅由表中的某一列构成，以上两种方法均可以定义主键。如果主键由表中多个列组成，那么只能有第二种方法定义主键约束。</strong></p>
<h2 id="候选键约束"><a href="#候选键约束" class="headerlink" title="候选键约束"></a>候选键约束</h2><p>如果一个属性集能<strong>唯一标识元组</strong>而又<strong>不含有多余的属性</strong>，那么这个属性集称为关系的候选键，用关键字<code>unique</code>来定义。</p>
<p>候选键可以是表中的某一列，也可以是表中多个列所构成的一个组合。<strong>任何时候，候选键的值必须是唯一的且不能为空</strong>。定义方法类似于主键：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    <span class="keyword">unique</span> (<span class="keyword">name</span>,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>候选键与主键的区别在于：</p>
<ol>
<li>一个表只能创建一个主键，但是可以有多个候选键</li>
<li>定义主键约束时，系统会自动创建<code>primary key</code>索引，定义候选键约束时，系统会自动创建<code>unique</code>索引</li>
</ol>
<h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p>现实世界的实体之间往往存在着某种联系，在关系模型中，实体及实体间的联系都是用关系来描述的，那么自然就存在关系与关系间的引用。</p>
<p><strong>参照完整性就是定义外键与主键之间的引用关系</strong>的。参照完整性的定义为：</p>
<blockquote>
<p>若属性（或属性组）F是基本关系R的外键，它与基本关系S的主键K对应，则对于R中的每个元组在F上的值只允许两种可能：要么取空值，要么等于S中某个元组的主键值，其中R与S可以是不同的关系，也可以是同一是关系，而F和K定义在同一个域中。</p>
</blockquote>
<p>声明外键的基本语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[constraint [symbol]] foreign key (index_col_name,...) reference_defination</span><br></pre></td></tr></table></figure></p>
<p><code>reference_defination</code>主要用于定义外键所参照的表、列，它的基本语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">references tbl_name [(index_col_name,...)]</span><br><span class="line">[match full | match pratial | match simple]</span><br><span class="line">[on <span class="keyword">delete</span> reference_options]</span><br><span class="line">[<span class="keyword">on</span> <span class="keyword">update</span> reference_options]</span><br></pre></td></tr></table></figure></p>
<p><code>tbl_name</code>指定外键所参照的表名，这个表称为<code>被参照表</code>或<code>父表</code>，外键所在的表被称为<code>参照表</code>或<code>子表</code>。 </p>
<p><code>index_col_name</code>指定被参照表中与外键相关联的列，<strong>必须是父表的主键或候选键</strong>，格式语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col_name [(length)] [ASC|DESC]</span><br></pre></td></tr></table></figure></p>
<p><code>reference_options</code>指定参照完整性约束的实现策略，默认为<code>restrict</code>。语法格式如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restrict | cascade | <span class="keyword">set</span> <span class="literal">null</span> | <span class="keyword">no</span> <span class="keyword">action</span></span><br></pre></td></tr></table></figure></p>
<p>cascade：瀑布、级联</p>
<ul>
<li>restrict 限制策略：当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除和更新</li>
<li>no action 不采取措施策略：一个相关的外键值在被参照表中时，删除或更新被参照表中的键值动作不被允许。类似于restrict</li>
<li>cascade 级联策略：从被参照表中删除或更新纪录行时，自动删除或更新参照表匹配的记录行</li>
<li>set null 制空策略：从被参照表中删除或更新纪录行时，设置参照表中与之对应的外键列的值为null。这个策略需要被参照表中的外键没有声明限定词not null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    class_id <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> <span class="keyword">class</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (class_id) <span class="keyword">references</span> <span class="keyword">class</span>(<span class="keyword">id</span>)</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span></span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>当父子表是同一张表时，MySQL不允许指定<code>on update cascade</code>与<code>on update set null</code></strong>，相关联的两个字段类型必须一致。</p>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><p>用户定义完整性是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求，关系模型提供定义和检查这类完整性规则的机制。</p>
<p>MySQL提供了<strong>非空约束</strong>，<strong>check约束</strong>和<strong>触发器</strong>3种用户自定义完整性约束。</p>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>通过<code>create table</code>或<code>alter table</code>语句将某个列加上关键字<code>not null</code>可以实现非空约束。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">modify</span> age <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h2><p>可以对列或表使用<code>check</code>约束，语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span> (expr)</span><br></pre></td></tr></table></figure></p>
<p><code>expr</code>是一个SQL表达式，用于指定需要检查的限定条件。更新数据时MySQL会检查更新后的数据行是否满足<code>check</code>约束中的限定条件。该条件可以是表达式，也可以是子查询。</p>
<h3 id="对列使用check约束"><a href="#对列使用check约束" class="headerlink" title="对列使用check约束"></a>对列使用check约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span> <span class="keyword">check</span>(age&gt;<span class="number">6</span> <span class="keyword">and</span> age&lt;<span class="number">19</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="对表使用check约束"><a href="#对表使用check约束" class="headerlink" title="对表使用check约束"></a>对表使用check约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    <span class="keyword">check</span>(<span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> students))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="触发器约束"><a href="#触发器约束" class="headerlink" title="触发器约束"></a>触发器约束</h2><p>触发器由MySQL的基本命令事件来触发的某种特定操作，这些基本的命令有<code>insert</code>、<code>update</code>、<code>delete</code>等事件来触发某些特定的操作。满足触发器的触发条件时，数据库系统会自动执行触发器中定义的程序语句。</p>
<h3 id="创建单行触发器"><a href="#创建单行触发器" class="headerlink" title="创建单行触发器"></a>创建单行触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">before</span>|<span class="keyword">after</span> 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> 执行语句;</span><br></pre></td></tr></table></figure>
<ul>
<li>before|after 指定触发器执行时间是在触发事件之前还是之后</li>
<li>触发事件 <code>insert</code>、<code>delete</code>、<code>update</code>等都是触发事件</li>
<li>执行语句 当满足条件时执行的触发器语句</li>
</ul>
<p>创建一个触发器，自动在用户向users表插入数据行之前向日志插入当前时间：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> userstime <span class="keyword">before</span> <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">users</span> <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> userslog <span class="keyword">values</span> (<span class="literal">null</span>, <span class="keyword">now</span>());</span><br></pre></td></tr></table></figure></p>
<h3 id="创建多行触发器"><a href="#创建多行触发器" class="headerlink" title="创建多行触发器"></a>创建多行触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称 <span class="keyword">before</span>|<span class="keyword">after</span> 触发事件</span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">执行语句列表</span><br><span class="line"><span class="keyword">end</span>\g</span><br></pre></td></tr></table></figure>
<p>要执行的多条语句放入<code>begin</code>和<code>end</code>中，用<code>;</code>分隔。</p>
<h3 id="查看触发器："><a href="#查看触发器：" class="headerlink" title="查看触发器："></a>查看触发器：</h3><p>查看所有触发器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据名字查看触发器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> infomation_schema.triggers <span class="keyword">where</span> trigger_name=触发器名;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 触发器名称;</span><br></pre></td></tr></table></figure>
<h1 id="命名完整性约束"><a href="#命名完整性约束" class="headerlink" title="命名完整性约束"></a>命名完整性约束</h1><p>可以对完整性使用添加，删除和修改等操作。为了删除和修改完整性约束，需要在定义约束的同时对其进行命名。命名完整性约束是在各种完整性约束的定义说明之前加上<code>constraint</code>字句实现的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint &lt;symbol&gt; [primary key | foreign key | check]</span><br></pre></td></tr></table></figure></p>
<p>对users表添加外键约束并命名为class：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="keyword">class</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (class_id)</span><br><span class="line"><span class="keyword">references</span> <span class="keyword">class</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="更新完整性约束"><a href="#更新完整性约束" class="headerlink" title="更新完整性约束"></a>更新完整性约束</h1><p>对各种约束命名后就可以用<code>alter table</code>语句来更新或删除。</p>
<h2 id="删除完整性约束"><a href="#删除完整性约束" class="headerlink" title="删除完整性约束"></a>删除完整性约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> [<span class="keyword">foreign</span> <span class="keyword">key</span> | <span class="keyword">index</span> | &lt;symbol&gt;] | primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>
<p>在删除主键时，必须在创建一个主键否则不会成功。</p>
<p>删除users表的名为class的外键：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">class</span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/《MySQL从入门到精通》之索引与视图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/30/《MySQL从入门到精通》之索引与视图/" class="post-title-link" itemprop="url">MySQL之索引与范式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-30 18:33:48" itemprop="dateCreated datePublished" datetime="2018-05-30T18:33:48+08:00">2018-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 08:58:04" itemprop="dateModified" datetime="2020-03-12T08:58:04+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种特殊的数据结构，类似于字典里的 key。通过索引查询数据库中的内容时，不需要遍历所有数据而是直接指向数据所在的位置，这样就可以快速查询到想要的内容。</p>
<p>索引是把双刃剑，虽然索引可以提高检索数据的速度，提高整体的性能，但是也会带来一些副作用：  </p>
<ol>
<li>额外的物理空间（单列索引至少占原表5%到15%）</li>
<li>额外的创建和维护时间（create、insert、update、delete等）</li>
</ol>
<p>MySQL 支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则：</p>
<ol>
<li>越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。</li>
<li>简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。</li>
<li>尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</li>
</ol>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>常见的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引等</p>
<ol>
<li>普通索引：即不应用任何限制条件的索引，该索引可以在任何数据类型中创建。字段本身的约束条件可以判断其值是否为空或唯一。</li>
<li>唯一性索引：使用 <code>unique</code> 参数可以设置唯一索引。创建该索引时索引的值必须唯一。通过唯一索引，用户可以快速定位某条数据。<strong>主键是一种特殊的唯一索引</strong>。</li>
<li>全文索引：<code>fulltext</code> 参数可以设置索引为全文索引。全文索引只能创建在 <code>char</code>、<code>varchar</code>、<code>text</code> 类型字段上。查询数据量较大的字符串型字段时，使用全文索引可以提高查询速度。<strong>只有 MyISAM 支持 <code>fulltext</code> 索引</strong></li>
<li>单列索引：就是只对应一个字段的索引，可以包括以上三种索引方式。</li>
<li>多列索引：在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段。可用通过这几个字段进行查询但是<strong>这几个字段必须包含多列索引的第一个字段，只有这样多列索引才会发挥作用</strong></li>
</ol>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="在建立数据表时创建索引"><a href="#在建立数据表时创建索引" class="headerlink" title="在建立数据表时创建索引"></a>在建立数据表时创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name (</span><br><span class="line">    create_defination</span><br><span class="line">    [<span class="keyword">unique</span> | fulltext] <span class="keyword">index</span></span><br><span class="line">    [别名](属性名<span class="number">1</span>[(长度)[,属性名<span class="number">2</span>(长度)...]] [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>])</span><br><span class="line">)[table_options];</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">    sex <span class="built_in">tinyint</span>(<span class="number">1</span>),</span><br><span class="line">    fulltext <span class="keyword">index</span> username(<span class="keyword">name</span>)</span><br><span class="line">)<span class="keyword">engine</span>=MyISAM;</span><br></pre></td></tr></table></figure>
<h3 id="在已建立的数据表中创建索引"><a href="#在已建立的数据表中创建索引" class="headerlink" title="在已建立的数据表中创建索引"></a>在已建立的数据表中创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> | fulltext] <span class="keyword">index</span> index_name </span><br><span class="line"><span class="keyword">on</span> table_name(属性[(长度) [AES|<span class="keyword">DESC</span>]])</span><br></pre></td></tr></table></figure>
<p>一个简单的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> username <span class="keyword">on</span> <span class="keyword">users</span>(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p>也可以通过修改表结构的方式创建索引，参见《MySQL从入门到精通》之基本语句。</p>
<h1 id="范式-Normal-Form"><a href="#范式-Normal-Form" class="headerlink" title="范式(Normal Form)"></a>范式(Normal Form)</h1><p>关系型数据库的规范化理论为：关系数据库中的每一个关系都要满足一定的规范。根据满足规范的条件不同，可以分为5个等级，一般只要把数据库规范到第三等级就足够了。</p>
<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h2><p>第一范式包括下列指导原则：</p>
<ol>
<li>数据组中的每个属性只可以包含一个值</li>
<li>关系中的每个数组必须包含相同数量的值</li>
<li>关系中的每个数组一定不能相同</li>
</ol>
<p>在任何一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。  </p>
<p><strong>如果数据表中的每一个列都是不可再分割的基本数据项，即同一列中不能有多个值，那么就称此数据表符合第一范式</strong>，由此可见第一范式具有不可再分割的原子特性。</p>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h2><p>第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。<strong>第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分</strong>。 为了实现区分各记录行通常需要为表设置一个“区分列”，用以存储各个实体的唯一标识。这个唯一属性列被称为<strong>主关键字或主键。</strong></p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h2><p>第三范式是在第二范式的基础上建立起来的。<strong>第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖</strong>，也就是说，第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。<br>所谓传递函数依赖，就是指如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖与关键字段A。参考下面的例子：  </p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (员工姓名、年龄、部门编码、部门经理)  </p>
</blockquote>
<p>上面这个关系表是符合第二范式的，但是不符合第三范式，因为该关系表内部隐含着如下关系：</p>
<blockquote>
<p>(员工编码) ——&gt; (决定) (部门编码) ——&gt; (决定) (部门经理)  </p>
</blockquote>
<p>上面的关系表纯真非关键字段“部门经理”对关键字段“员工编码”的函数传递依赖，对于上面这种关系，可以把这个关系表改为如下两个关系表：  </p>
<blockquote>
<p>员工信息表：(员工编码，员工姓名，年龄好部门编码)<br>部门信息表：(部门编码和部门经理)  </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/字符串编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/23/字符串编码/" class="post-title-link" itemprop="url">也谈 Unicode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-23 22:47:56" itemprop="dateCreated datePublished" datetime="2018-05-23T22:47:56+08:00">2018-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-15 00:45:33" itemprop="dateModified" datetime="2020-02-15T00:45:33+08:00">2020-02-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机系统/" itemprop="url" rel="index"><span itemprop="name">计算机系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="不同的编码方式"><a href="#不同的编码方式" class="headerlink" title="不同的编码方式"></a>不同的编码方式</h1><p>由于计算机是美国人发明的，所以最早的时候只收录了 127 个字符，包括阿拉伯数字、英文字母大小写和一些常用符号，称为 <code>ASCII</code>。后来计算机越来越普及，127 个字符显然不够。于是各国又制定了自己国家的字符编码。为了避免不同国家之间通信出现乱码的问题，一种统一字符集 <code>Unicode</code> 诞生了。<code>ASCII</code> 用 1 个字节来储存一个字符，而 <code>Unicode</code> 用 4 个字节来储存字符。理论上所有的文字、符号都可以用 Unicode 编码表示。换言之，Unicode 是一种表示所有字符的方式`。</p>
<p>有了 Unicode，就解决了从字符到二进制的表示问题。接下来问题就是计算机内如何编码这套字符集了。</p>
<p>所有 Unicode 字符长度都是 4 字节，理论上计算机只需要每次读取 4 个字节就可以得到一个字符，这就是所谓的 <code>UTF-32 编码</code>。由于常用字符数目不到 65535 个，用 2 个字节就能容纳，那就意味着 4 个字节中有 2 个是经常被浪费掉的。所谓浪费就是犯罪，既然如此，系统可以老老实实每次读取 2 字节，遇到特殊符号时再往后多读 2 字节 就可以了。这就是 Java 默认的 <code>UTF-16 编码</code>。可是问题依然没有完全解决，英语是最常用的语言，前面说过，只需要 1 个字节就可以表示英文字母了，UTF-16 把每个字母也按照 2 字节 的方式编码，这无疑还是浪费了很多存储空间。另一种编码方式 <code>UTF-8 编码</code> 则解决了这个问题。UTF-8 编码通常只占 1 字节，但是会用几位冗余信息告诉系统，当前字符有没有结束，还需要继续往下读下一个字节。UTF-8 编码对英文只会占用 1 字节 的空间，而一些特殊字符如中文，则会智能地多占用一点空间进行存储，这样就大大节约了空间，特别适合用于本地存储和网络传输。在计算机内存中，统一使用 Unicode 字符集，而在网络传输和硬盘保存时，推荐使用 UTF-8 作为编码方式。</p>
<p>占用不同字节数的 UTF-8 编码表示形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx    // 0-127，ASCII 字符</span><br><span class="line">110xxxxx 10xxxxxx   // 128-2047</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx  // 2048-65535</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx // 65536-0x10ffff</span><br></pre></td></tr></table></figure>
<p>通常按 UTF-8 编码的中文字符占 3 字节。这种变长编码导致字符串无法按字节下标直接读取一个字符，但由于其与 ASCII 完全兼容、非常节约存储空间、算法高效等特性，在实际中获得了广泛的应用。以下 3 种字符串常量均表示长度为 6 字节的相同串：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"世界"</span>  <span class="comment">// 中文字符</span></span><br><span class="line"><span class="string">"\xe4\xb8\x96\xe7\x95\x8c"</span>  <span class="comment">// UTF-8</span></span><br><span class="line"><span class="string">"\u4e16\u754c"</span>  <span class="comment">// Unicode</span></span><br></pre></td></tr></table></figure>
<h1 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h1><p>在 python3中，字符默认按 Unicode 编码，而在进行网络传输和硬盘保存时，常常将 Unicode 字符按 UTF-8 的方式编码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(s.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>当我们从网络上获取数据时，常常也是获取到以 UTF-8 形式编码的字节，为了方便我们对数据进行处理，需要解码成普通的 Unicode：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line">print(b.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 输出：'中文'</span></span><br></pre></td></tr></table></figure>
<p><strong>为了避免乱码，应该始终坚持以 UTF-8 的形式进行字符和字节之间的转换</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/unittest单元测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/23/unittest单元测试/" class="post-title-link" itemprop="url">unittest简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-23 17:08:42" itemprop="dateCreated datePublished" datetime="2018-05-23T17:08:42+08:00">2018-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-02 22:19:27" itemprop="dateModified" datetime="2020-03-02T22:19:27+08:00">2020-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/语言/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有个词叫TDD(Tset Driven Development)，测试驱动开发。一个好的开发人员不仅要懂开发，还要懂得一定的测试技巧。python自带了很多的测试库，比如unittest，coverage….介绍一下unittest的使用。</p>
<h1 id="unittests四个重要的概念"><a href="#unittests四个重要的概念" class="headerlink" title="unittests四个重要的概念"></a>unittests四个重要的概念</h1><p>unittest有四个重要的面向对象概念：</p>
<ol>
<li>test fixture。这个概念主要处理测试环境的搭建和清理。很多时候我们在进行测试的时候需要搭建合适的环境，例如创建目录、创建数据库等，而在测试完毕后这些环境又不再需要了。test fixturn可以帮我们很好的处理这些事情。</li>
<li>test case。 既然要进行测试，测试用例当然是最重要的。每一项测试内容都是一个test case。</li>
<li>test suite。我们当然不希望只能一项项的进行测试，最好是将要测试的项目放在一起。test suite相当于test case的集合，当然test suite也能嵌套在test suite中。</li>
<li>test runner。顾名思义，这个概念负责执行测试并控制结果输出。</li>
</ol>
<h1 id="创建testcase"><a href="#创建testcase" class="headerlink" title="创建testcase"></a>创建testcase</h1><p>unittest提供了TastCase类，要创建一个testcase只需要继承这个父类就好了。</p>
<p>先在<code>mathfunc.py</code>编写三个函数用于测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minus</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>在<code>test_math.py</code>中创建测试用例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试add函数"""</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试minus函数"""</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span><span class="number">-1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""测试string函数"""</span></span><br><span class="line">        self.assertIn(<span class="string">'h'</span> <span class="keyword">in</span> string(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure>
<p>这就创建了一个testcase，包含三个测试。<strong>testcase中所有的测试必须以<code>test</code>开头</strong>。<code>self.assert*()</code>是由TestCase提供的测试函数。每一个测试里的文档会在输出测试报告时显示。不用python内置的assert()是因为uniittest在遇到<code>self.assert*()</code>发生错误时会把这个测试标记为failure，然后继续执行其他测试。</p>
<h1 id="创建testsuite"><a href="#创建testsuite" class="headerlink" title="创建testsuite"></a>创建testsuite</h1><p>有了testcase，自然想把它加入到suite中。unittest提供了<code>TestSuite</code>类来表示一个suite。默认情况下，unittest按测试函数的函数名进行排序，然后按这个排序执行测试。如果我们想控制测试执行顺序，就要在向suite添加case时做点文章：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line">suite = unittest.TestSuite()</span><br><span class="line"><span class="comment"># 传入列表，这样就会按照元素顺序执行测试</span></span><br><span class="line">suite.addTests([TestMath(<span class="string">'test_add'</span>), TestMath(<span class="string">'test_minus'</span>), TestMath(<span class="string">'test_string'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure></p>
<p>还可以通过unittest提供的TestLoader类来添加testcase，<strong>TestLoader会返回一个suite</strong>。不过<strong>TestLoader无法保证按照顺序执行测试</strong>。TestLoader类提供了一下常用方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test_math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三种方法都可以</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(<span class="string">'test_math.TestMath'</span>))</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromNanes([<span class="string">'test_math.TestMath'</span>])</span><br><span class="line">suite.addTests(unitest.TestLoader().loadTestsFromTestCase(TestMath))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果test_math在/usr/test/目录下</span></span><br><span class="line">suite.addTests(unittest.TestLoader().discover(<span class="string">r'/usr/test/'</span>))</span><br><span class="line"><span class="comment"># 可用添加单个testcase</span></span><br><span class="line">suite.addTest(TestMath(<span class="string">'test_add'</span>))</span><br></pre></td></tr></table></figure></p>
<ul>
<li>loadTestsFromName(模块名.testcase名)</li>
<li>loadTestsFromTestCase(testcase名)</li>
<li>discover(start_dir, pattern=’test*.py’, top_level_dir=None)。start_dir是目标文件夹路径，unittest会查找指定目录及子目录下的全部符合pattern的模块并执行里面的TestCase。<strong>电脑中不能有同名的目标文件夹，否则unittest可能无法找到正确的位置</strong>。patter默认是’test*.py’。</li>
</ul>
<h1 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h1><p>TaseCase父类提供了<code>setUp()</code>，<code>tearDown()</code>，<code>setUpClass()</code>，<code>tearDownClass()</code>。我们在自己的测试用例中重写就可以了。</p>
<p>setUp()与tearDown()会在每个测试之前执行。setUp()负责搭建测试环境，tearDown()负责清理环境。如果setUp()执行失败那么这次测试不会进行，如果setUp()成功执行那么不管测试是否成功tearDown()都会执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.app = create_app(<span class="string">'TESTING'</span>)</span><br><span class="line">        self.app_context = self.app.app_context()</span><br><span class="line">        self.app_context.push()</span><br><span class="line">        self.client = self.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        self.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>如果想要在所以case之前执行一次环境准备，所有case之后清理环境，可用<code>setUpClass()</code>和<code>tearDownClass()</code>。不过要带上<code>@classmethod</code>装饰器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> manage <span class="keyword">import</span> create_app, db</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.app = create_app(<span class="string">'TESTING'</span>)</span><br><span class="line">        cls.app_context = cls.app.app_context()</span><br><span class="line">        cls.app_context.push()</span><br><span class="line">        cls.client = cls.app.test_client(use_cookies=<span class="literal">True</span>)</span><br><span class="line">        db.create_all()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(cls)</span>:</span></span><br><span class="line">        db.session.remove()</span><br><span class="line">        db.drop_all()</span><br><span class="line">        cls.app_context.pop()</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h1 id="执行测试及控制输出"><a href="#执行测试及控制输出" class="headerlink" title="执行测试及控制输出"></a>执行测试及控制输出</h1><p>通常我们使用<code>unittest.main()</code>就会调用Test Runner开始测试。当然也可以手动执行Runner。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></p>
<p>verbosity设定了测试报告的详细程度，有0，1，2三种。默认值是1，数字越大越详细。</p>
<p>也可以把输出写到文件里,将文件指针传给Runner()里的<code>stream</code>参数就可以了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'/usr/test/report'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    runner = unittest.TextTest.Runner(verbosity=<span class="number">2</span>, stream=f)</span><br><span class="line">    runner.run(suite)</span><br></pre></td></tr></table></figure></p>
<h1 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h1><p>unittest提供3种跳过测试的装饰器：skip([reason])、skipIf(condtion[,reason])，skipUnless(conditon[,reason])。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mathfunc <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMath</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @unittest.skip('跳过add函数')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="number">1</span>+<span class="number">2</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_minus</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span><span class="number">-1</span>, minus(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_string</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertIn(<span class="string">'h'</span> <span class="keyword">in</span> string(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/git常见用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/23/git常见用法/" class="post-title-link" itemprop="url">git常见用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-23 06:45:34" itemprop="dateCreated datePublished" datetime="2018-05-23T06:45:34+08:00">2018-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-16 20:12:38" itemprop="dateModified" datetime="2020-02-16T20:12:38+08:00">2020-02-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用git也有一段时间了，一直没有做总结，在这里记录一下方便以后查看。</p>
<h1 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h1><p>windows下直接从<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a>下载就可以了，安装过程是傻瓜式的，一路点确定就OK。安装完成后发现多了个叫<code>git bash</code>的程序，打开程序会弹出一个命令行窗口就可以了。</p>
<p>linux下安装git很简单，直接在终端输入 <code>git</code>，系统会告诉你是否已经安装。如果没有安装还会告诉你安装方法。Debian 和 Ubantu 下通过 <code>sudo apt-get install git</code> 就可以进行安装。</p>
<p>由于git是分布式版本控制系统，所以必须指出每台机器的身份。这就要配置git相关变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.username <span class="string">"name"</span></span><br><span class="line">git config --global user.email <span class="string">"email"</span></span><br></pre></td></tr></table></figure>
<p>有时候我们发现自己的账户和邮箱配置错了，重设我们的账户和邮箱：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --replace-all user.username <span class="string">"new name"</span></span><br><span class="line">git config --global --replace-all user.email <span class="string">"new email"</span></span><br></pre></td></tr></table></figure>
<h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>目标文件夹下，打开终端输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>这就为这个文件夹创建了一个版本库，有了版本库就可以开始使用 git 的各项功能了。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>git 有分区的概念，平时我们新建、删除、修改文件都是在<code>工作区</code>，通过 <code>git add</code> 命令把工作区的变动提交到<code>暂存区</code>（stage），再用 <code>git commit</code> 把stage的内容提交到<code>分支</code>（branch）。</p>
<p>每次我们对文件进行修改，都会改变 git 的状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status <span class="comment">#查看当前仓库的状态（是否有文件被修改，有文件没有commit等）</span></span><br><span class="line">git diff file <span class="comment">#比较工作区与缓存区的不同</span></span><br><span class="line">git diff head  <span class="comment"># 比较工作区与分支的不同</span></span><br></pre></td></tr></table></figure>
<h3 id="显示过往提交记录"><a href="#显示过往提交记录" class="headerlink" title="显示过往提交记录"></a>显示过往提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改，<strong>相当于 git add 的反向命令，即把暂存区最新版本转移到工作区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>
<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的，<strong>相当于 git commit 的反向命令，即把分支最新版本转移到暂存区</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h3 id="显示提交记录"><a href="#显示提交记录" class="headerlink" title="显示提交记录"></a>显示提交记录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline <span class="comment"># 在 log 显示信息过乱时可以加 --oneline 只显示提交记录及其版本号</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline <span class="comment"># 把分支记录以时间线的形式显示</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/U5lM6bayKAHwX1r.png" alt="log"><br><img src="https://i.loli.net/2020/02/16/mO2ACVn9jQaMZJg.png" alt="log--oneline"></p>
<p>HEAD 表示当前版本，可以用 HEAD^ 表示上一版本，HEAD^^ 表示上上版本… HEAD~100 表示第前 100 个版本。</p>
<h3 id="版本回退-1"><a href="#版本回退-1" class="headerlink" title="版本回退"></a>版本回退</h3><p>使用 git 的一个主要好处就是 git 提供方便的版本控制，可以在需要的时候回退到任意版本。</p>
<p>版本回退命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure>
<p>但是这里有个问题：当我们回到历史版本后，<code>git log</code> 命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好 <code>git relog</code> 命令可以解决这个问题，<code>git reflog</code> 记录了我们每次在版本间的移动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/16/BFnk1zxTIN7Khly.png" alt="reflog"></p>
<p>可以看到，我通过 checkout 从 174e8dc 来到 e346f09，这样就不怕穿越不回现代啦~</p>
<h3 id="管理修改-1"><a href="#管理修改-1" class="headerlink" title="管理修改"></a>管理修改</h3><p>有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>
<p>如果文件已经 add 到了暂存区，想要把它从暂存区里撤下来也是可以的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file</span><br></pre></td></tr></table></figure>
<p>那如果文件已经 commit 了怎么版本？还记得前面的版本回退命令吗？直接回退就好啦！</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>要先在 Github 中添加这台机器的 ssh 密钥以允许你把本地文件传到 Github 上。执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email"</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在当前文件夹下生成 <code>.ssh</code> 文件夹，里面有两个文件：<code>id_rsa</code> 和 <code>id_rsa.pub</code>。带 pub 的是公钥，把 <code>id_rsa.pub</code> 里的内容添加到 Github 上。</p>
<p>想把 Github 中的仓库和本地仓库关联起来，通过这条命令可以实现，xxxxx 是远程仓库的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxxxx</span><br></pre></td></tr></table></figure>
<p>origin 是这个 git 本地仓库对远程仓库的称呼，也可以用别的名字如 dev、test 等，但是通常都用origin。</p>
<p>删除本地仓库与远程仓库的关联也很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>有时候我们在 Github 上可能看到一些很有意思的库，可以用这个命令把它下载到本地，其中 xxxxx 是这个仓库的网址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxxxx</span><br></pre></td></tr></table></figure>
<h3 id="把本地库内容推送到远程"><a href="#把本地库内容推送到远程" class="headerlink" title="把本地库内容推送到远程"></a>把本地库内容推送到远程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如果是第一次推送，可以为push加上 <code>-u</code> 参数，这样以后推送的时候就不用再输入 Github 的账号和密码了。master 代表远程仓库的主分支，如果要推送到其他分支就换成其他分支名。</p>
<h3 id="抓取远程库内容"><a href="#抓取远程库内容" class="headerlink" title="抓取远程库内容"></a>抓取远程库内容</h3><p>抓取远程仓库内容并 merge 到本地</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment"># 默认抓取 origin 中和当前分支关联的远程分支</span></span><br></pre></td></tr></table></figure>
<h3 id="删除远程仓库中的文件"><a href="#删除远程仓库中的文件" class="headerlink" title="删除远程仓库中的文件"></a>删除远程仓库中的文件</h3><p>很多时候随着项目的进行，远程仓库中一些文件不再被使用，或者干脆就是不小心提交了没啥用的文件。当然，可以在 Github 点击删除按钮进行删除，但是目前 Github 只提供了单个文件的删除，如果想要删除一个文件夹及其下的所有文件那工作量简直令人崩溃 orz。</p>
<p>其实，我们可以通过从版本库中删除这个文件再推送到 Github 的方式删除远程仓库中的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached file</span><br><span class="line">git commit -m <span class="string">"delete file"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><code>-r</code> 表示递归删除，这在 file 表示文件夹时尤其有用。<code>--cached</code> 表示对版本库中的缓存进行操作，这样就不会把本地文件给删除了~</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建新分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure>
<p>移动到一个分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>
<p>创建并移动到一个新分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure>
<p>创建并移动到一个和远程分支对应的分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名 origin/远程分支</span><br></pre></td></tr></table></figure>
<p>建立本地分支对远程分支的关联：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream 本地分支 origin/远程分支</span><br></pre></td></tr></table></figure>
<p>将当前分支与另一分支合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure>
<h3 id="处理分支冲突"><a href="#处理分支冲突" class="headerlink" title="处理分支冲突"></a>处理分支冲突</h3><p>合并分支时，可能会遇到因两个分支的内容有冲突而导致合并失败的现象（这在执行 pull 操作时尤其常见，特别是当你在 Github 上在线修改了一个文件，而本地没有修改时）。git 会在冲突文件中用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同内容的分支。我们需要将文件进行修改后再执行 commit：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到，本地 HEAD 和远程分支冲突了</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">git is good</span><br><span class="line">=======</span><br><span class="line">git is very good</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件修改一下</span></span><br><span class="line">git is very good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git add test.txt</span><br><span class="line">git commit -m "解决冲突"</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>当项目开发到一定阶段，我们会给它打上一个<code>标签</code>（tag）表示达到了某种程度。就像很多软件经常会说：我们升级到 v7.0.1 版本啦，快来升级哟~ 这里的 v7.0.1 就是一个标签。</p>
<p>查看当前版本库中所有标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>给某次 commit 打上标签很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名 版本号</span><br></pre></td></tr></table></figure>
<p>像 commit 那样给标签添加说明，<code>-a</code> 表示创建一个带附注的标签，<code>-m</code> 表示附注：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名 版本号 -a -m <span class="string">"add an annotation"</span></span><br></pre></td></tr></table></figure>
<p>查看一个标签的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 标签名</span><br></pre></td></tr></table></figure>
<p>签出一个标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 标签名</span><br></pre></td></tr></table></figure>
<p>删除本地标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签名</span><br></pre></td></tr></table></figure>
<p>推送本地标签到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<p>删除远程仓库中的标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/标签名</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/31/《MySQL从入门到精通》之基本语句/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="路边的土豆">
      <meta itemprop="description" content="高山仰止，景行行止。虽不能至，心向往之。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="精神的壳">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/31/《MySQL从入门到精通》之基本语句/" class="post-title-link" itemprop="url">MySQL之基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-31 21:15:37" itemprop="dateCreated datePublished" datetime="2018-03-31T21:15:37+08:00">2018-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-18 19:04:06" itemprop="dateModified" datetime="2020-04-18T19:04:06+08:00">2020-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 MySQL 中，表、视图、存储过程和索引等具体存储数据或对数据进行操作的实体都被称为数据库对象。</p>
<ul>
<li>表：是包含数据库中所有数据的数据库对象，由行和列组成，用于组织和存储数据类型</li>
<li>字段：表中每列被称为一个字段，字段具有自己的属性，如字段类型、字段大小等。其中，字段类型是字段最重要的属性，它决定了字段能存储哪种数据。</li>
<li>索引：是一个单独的、物理的数据结构。它是依赖于表建立的，在数据库中索引使用数据库程序无需对整个表进行扫描就可以在其中找到所需的数据。索引可以比作是一本书的目录</li>
<li>视图：视图是从一张或多张表中导出的表（也称虚拟表），是用户查看数据的一种方式，表中包括几个被定义的数据列与数据行，其结构和数据建立在对表的查询基础之上。</li>
<li>存储过程：一组为了完成特定功能的 SQL 语句集合（包括查询、插入、删除、更新等操作），经编译后以名称的形式存储在 SQL Server 服务端的数据库中，由用户通过指定存储过程的名字来执行对应的存储操作。</li>
</ul>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎其实就是如何在存储数据，如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 支持很多表，每种类型都有自己的特定作用、优点和缺点。MySQL 还相应提供了很多不同的存储引擎，可以以最适合于应用需求的方式存储数据。</p>
<p>MySQL中的数据用各种不同的技术存储在文件或内存中，这些技术采用不同的存储机制、索引技巧、锁定水平并最终提供广泛的、不同的功能和能力。通过选择不同的技术，能够获取额外的速度或者功能，从而改善应用的整体功能。</p>
<p>查询当前数据库的引擎：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%storage_engine%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>InnoDB 支持自动增长列：<code>AUTO_INCREMENT</code>。自动增长列的值不能为空，且值必须唯一。<strong>MySQL中规定自动增长列必须为主键</strong>，在插入值时，如果自动增长列不输入值或插入的值为0、null，则插入的值为自动增长后的值。</p>
<p>InnoDB支持外键（foreign key）。外键所在表为子表，外键所依赖的表为父表。<strong>父表中被子表外键关联的字段必须为主键</strong>。当修改父表的某天信息时，子表也必须有相应的改变。</p>
<p>InnoDB是如下情况的理想引擎：  </p>
<ol>
<li>更新密集的表。InnnoDB特别适合处理多重并发的更新请求</li>
<li>事务。InnoDB是唯一支持事务的标志MySQL存储引擎。在管理敏感数据（如用户注册）时特别有用</li>
<li>自动灾难修复。与其他引擎不同，InnoDB能自动从灾难中恢复，虽然MyISAM也能做到但是其过程要长得多</li>
</ol>
<h3 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h3><p>MyISAM 引擎的优点在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MySQL支持5中基本字段类型：数值型，字符型，文本型，逻辑型和日期时间型。</p>
<ul>
<li>数值型：MySQL 支持所有标准 SQL 数值数据类型。这些数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。<br>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/1.png" alt="整数型"></p>
<p><img src="http://ke.dajiangtai.com/content/411/2.png" alt="浮点型"></p>
<ul>
<li>时间日期型：表示时间值的日期和时间类型为 DATETIME、DATE、TIMESTAMP、TIME 和 YEAR。每个时间类型有一个有效值范围和一个零值，当指定非法值时使用”零”值。</li>
</ul>
<p><strong>TIMESTAMP 类型有专有的自动更新特性。</strong></p>
<p><img src="http://ke.dajiangtai.com/content/411/3.png" alt="时间日期类型"></p>
<ul>
<li>字符串型：字符串类型指 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。</li>
</ul>
<p><img src="http://ke.dajiangtai.com/content/411/4.png" alt="字符串类型"></p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>创建表时，使用字符串类型时应遵循以下原则：  </p>
<ol>
<li>从速度方面考虑，要选择固定长度的列，可以使用 CHAR 类型</li>
<li>要节省空间，使用动态长度的列，可以使用 VARCHAR 类型</li>
<li>要将列中的内容限制在一种选择，可以用 ENUM 类型</li>
<li>允许一个列中有多于一个的条目，可以用 SET 类型</li>
</ol>
<ul>
<li>布尔型：其实 MySQL 里根本没有布尔型，虽然可以用 <code>boolean</code> 但实际上 MySQL 会把它替换成 <code>tinyint(1)</code>。用 1 或 True 表示真，0 或 False 表示假。</li>
</ul>
<h2 id="SQL-语句入门"><a href="#SQL-语句入门" class="headerlink" title="SQL 语句入门"></a>SQL 语句入门</h2><p>使用数据库，首先要会 SQL 语句。下列 SQL 语句中，带 <code>{}</code> 的是必选项，<code>[]</code> 是可选项，<code>[default]</code> 表示可选并有默认值的选项，<code>|</code> 表示或。SQL 语句以 <code>;</code> 结尾，也可以用 <code>\g</code> 或 <code>\G</code>，<code>\g</code> 与 <code>;</code> 是相同的，而 <code>\G</code> 可以让结果显示更美观。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名</span><br><span class="line">[<span class="keyword">default</span>]<span class="built_in">character</span> <span class="keyword">set</span> [=] 字符集名;</span><br></pre></td></tr></table></figure>
<p><code>character set</code> 默认情况下是 MySQL 服务器配置文件里的字符集。可以是GB2312 或 GBK（简体中文）、UTF8、BIG5（繁体中文）、Latin1（拉丁文）等，最常见的就是 GBK 和 UTF8。</p>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> [<span class="keyword">like</span> <span class="string">'模式'</span>];</span><br></pre></td></tr></table></figure>
<p>查看所有数据库，谓词 <code>like</code> 用于指定匹配模式（支持正则）。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> <span class="keyword">like</span> <span class="string">'db%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure>
<p>使用 <code>use</code> 语句将数据库指定为当前数据库后，当前数据库在当前工作会话关闭（即断开与该数据库的连接）或再次使用 <code>use</code> 语句指定数据库时结束工作状态。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据库名;</span><br></pre></td></tr></table></figure>
<p><code>if exists</code> 在删除数据库前先判断数据库是否已经存在，只有已经存在是才会执行删除操作，这样可以避免删除不存在的数据库时产生异常。</p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">temporary</span>] <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名</span><br><span class="line">(&#123;create_defination[,create_defination]&#125;) [table_options] [select_statement];</span><br></pre></td></tr></table></figure>
<p>说明：  </p>
<ol>
<li>temporary：创建一个临时表</li>
<li>if not exists：避免表存在时出错</li>
<li>create_defination：定义表的列属性</li>
<li>table_options：表的一些特性参数，涉及表数据如何存储。如engine选项：engine=MyISAM。</li>
<li>select_statement：select语句描述部分，用它可以快速创建表</li>
</ol>
<p>create_defination格式：</p>
<blockquote>
<p>col_name type [not null | null] [default default_value] [auto_increment] [primary key] [reference_defination]</p>
</blockquote>
<p>下面是例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">tinyint</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    age <span class="built_in">tinyint</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> 数据表名 [列名];</span><br></pre></td></tr></table></figure>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>修改表结构指增加或删除字段、修改字段名称或字段类型、设置取消主键外键、设置取消索引等</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 数据表名 alter_spec[,alter_spec] | table_options</span><br></pre></td></tr></table></figure>
<p>alter_spec:  </p>
<ul>
<li>add create_defination[first | after column_name] //添加新字段</li>
<li>add index [index_name] (index_col_name) //添加索引名称</li>
<li>add primary key (index_col_name) //添加主键名称</li>
<li>add unique [index_name] (index_col_name) //添加唯一索引</li>
<li>alter col_name {set default 默认值 | drop default} //修改字段默认值</li>
<li>change old_col_name create_defination //修改字段名、类型</li>
<li>modify col_name create_defination //修改字段定义</li>
<li>drop col_name //删除字段</li>
<li>drop index index_name //删除索引</li>
<li>rename as new_tab_name //修改表名</li>
</ul>
<p><strong><code>alter table</code> 语句允许指定多个动作，其动作间用逗号分隔，每个动作表示一个修改。</strong></p>
<ul>
<li>添加新字段及修改字段定义：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">add</span> email <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">after</span> location,</span><br><span class="line"><span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改字段名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">change</span> <span class="keyword">user</span> username varhcar(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除字段：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">drop</span> email;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改表名：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">rename</span> the_users;</span><br></pre></td></tr></table></figure>
<h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><p>在一张已存在的数据表的基础上创建一份该表的备份，也就是复制表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>] 数据表名 <span class="keyword">like</span> 源数据表名;</span><br></pre></td></tr></table></figure>
<p>使用该语法复制数据表时，将创建一个与源数据表相同结构的新表，该数据表的别名、数据类型和索引都将被复制，但是表的内容是不会被复制的。因此，创建的表是一张<strong>空表</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">like</span> the_users;</span><br></pre></td></tr></table></figure>
<p>如果在复制表格式的同时也想复制表中的内容，可以使用<code>as</code>（查询表达式）字句实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> the_users;</span><br></pre></td></tr></table></figure>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] 数据表名;</span><br></pre></td></tr></table></figure>
<p>可同时删除多张表，多个表之间用逗号<code>,</code>连接。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> [<span class="keyword">low_priority</span> | <span class="keyword">delayed</span> | <span class="keyword">high_priority</span>] [<span class="keyword">ignore</span>]</span><br><span class="line">[<span class="keyword">into</span>] 数据表名 [(字段名)] <span class="keyword">values</span> (&#123;值 | <span class="keyword">default</span>&#125;),(...),...</span><br></pre></td></tr></table></figure>
<ul>
<li>[low_priority | delayed | high_priority]：<code>low_priority</code> 是 <code>insert</code>、<code>delete</code>、<code>update</code> 都可选的操作，降低 <code>insert</code>、<code>delete</code>、<code>update</code> 的优先级。<code>delayed</code> 是 <code>insert</code> 语句支持的一种可选修饰符，用于指定MySQL服务器把待插入的行数据放在一个缓冲器中，直到待插数据的表空闲时，才真正的在表中插入数据行。<code>high_priority</code> 是 <code>insert</code>和 <code>select</code> 语句支持的一种可选修饰符，用于指定 <code>insert</code> 和 <code>select</code> 操作优先执行。</li>
<li>[ignore]： 在执行 <code>insert</code> 语句时，所出现的错误都会被当做警告</li>
<li>[into]： 指定被操作的数据表</li>
<li>[(字段名,…)]： 当不指定该选项时，表示要向表中所有列插入数据，否则表示向数据表的指定列插入数据。</li>
<li><p>({值 | default}),(…),…：用于指定需要插入的数据清单，其<strong>顺序必须与字段的顺序相对应</strong>。其中的每一列的数据可以是一个变量、常量、表达式或者null。但是其<strong>数据类型要与对应的字段类型相匹配</strong>；也可以使用 <code>default</code> 关键字，表示为该列插入默认值，但是前提是已经明确指定了默认值，否则会出错。</p>
</li>
<li><p>插入完整数据：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'qiuyue'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>插入数据记录的一部分：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (<span class="keyword">name</span>, age) <span class="keyword">values</span> (<span class="string">'qiuyue'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>插入查询结果：MySQL 支持将查询结果插入到数据表中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 数据表名[(字段名,...)] <span class="keyword">select</span> ...;</span><br></pre></td></tr></table></figure>
<p><strong>select 字句返回的结果集中的字段数量、字段类型必须与目标数据表完全一致。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span> (username,age) <span class="keyword">select</span> username,age <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 数据表名</span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span>=值<span class="number">1</span>[,字段<span class="number">2</span>=值<span class="number">2</span> ...]</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [<span class="keyword">limit</span> 行数]</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">users</span> <span class="keyword">set</span> username = <span class="string">'qiuyue'</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 数据表名</span><br><span class="line">[<span class="keyword">where</span> 条件表达式] [<span class="keyword">order</span> by...] [<span class="keyword">limit</span> 行数];</span><br></pre></td></tr></table></figure>
<p><strong>如果没有指定 <code>where</code> 条件，将删除所有记录</strong>。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>如果要删除所有行，还可以使用 <code>truncate table</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> [<span class="keyword">table</span>] 数据表名</span><br></pre></td></tr></table></figure>
<p><code>truncate</code> 会<strong>删除数据表中所有数据且无法恢复</strong>。<br><code>delete</code> 与 <code>truncate</code> 区别如下：</p>
<ol>
<li>使用 <code>truncate</code> 语句会重新设置 <code>auto_increment</code> 计数器的初始值</li>
<li>对于参与了索引和视图的表不能使用 <code>truncate</code> 语句</li>
<li><code>truncate</code> 比 <code>delete</code> 使用的系统和事物资源少。每删除一条记录 <code>delete</code> 语句都会添加一条日志，而 <code>truncate</code> 只在事物日志中记录页的释放。</li>
</ol>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> selection_list</span><br><span class="line"><span class="keyword">from</span> 数据表名</span><br><span class="line"><span class="keyword">where</span> primary_constraint</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sroting_cloumns </span><br><span class="line"><span class="keyword">having</span> secondary_constraint</span><br><span class="line"><span class="keyword">limit</span> <span class="keyword">count</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查询一张表的一列或多列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>; //查询users表所有内容</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,age <span class="keyword">from</span> <span class="keyword">users</span>; //查询users表id列和age列所有内容</span><br></pre></td></tr></table></figure>
<ul>
<li>从多个表中获取数据：</li>
</ul>
<p>使用 <code>select</code> 语句进行多表查询，需要确定所查询的数据在哪个表中，多个表之间用 <code>,</code>分隔：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> users.id, users.name, student.id, student.name</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span>, student;</span><br></pre></td></tr></table></figure>
<p>还可以在 <code>where</code> 子句中用连接符 <code>=</code> 来确定表之间的联系。然后根据这个条件返回查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> users.name,student.location <span class="keyword">from</span> <span class="keyword">users</span>,studnet <span class="keyword">where</span> users.id=student.id <span class="keyword">and</span> users.id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>users.id=student.id</code> 表示将 users 和 student 两张表根据 <code>users.id=stduent.id</code> 的条件连接起来，叫做等同连接。如果不使用 <code>users.id=stduent.id</code> 那么产生的结果是两张表的笛卡尔积，叫全连接。</p>
<ul>
<li>带关键字 in 的查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段 [<span class="keyword">not</span>] <span class="keyword">in</span> (元素<span class="number">1</span>，元素<span class="number">2</span> ...);</span><br></pre></td></tr></table></figure>
<p>关键字 <code>in</code> 可以判断某个字段的值是否在指定的集合中，如果在该记录会被查询出来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,age <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'Mike'</span>, <span class="string">'David'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>带关键字between…and…的范围查询：between…and… 是<strong>前闭后闭</strong>的</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>带like的字符匹配查询：通过 <code>like</code> 可以实现模糊查询，它有两种通配符 <code>%</code> 和 <code>_</code>:<ul>
<li>% 可以匹配 0 个或多个字符，可以代表任意长度的字符串。如 “Mi%ke” 可以匹配Mike，Miosfke等</li>
<li>_ 最多只能匹配一个字符。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">"Jack_a"</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> studnet <span class="keyword">where</span> location <span class="keyword">like</span> <span class="string">"China\_%"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>group by 分组查询</li>
</ul>
<p>通过关键字 <code>group by</code> 可以将数据划分到不同的组中，实现对记录的分组查询。常搭配 count(), sum(), avg(), max(), min() 等聚合函数使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> class_id <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br><span class="line"><span class="keyword">select</span> class_id, <span class="keyword">count</span>(*) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> class_id;</span><br></pre></td></tr></table></figure>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接是把不同表的记录连接在一起的最普遍的方法。</p>
<ul>
<li>内连接查询：把不符合连接条件的行从视图中删除，最常见的例子是相等查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,s.age,s.class_id,c.name <span class="keyword">as</span> class_name </span><br><span class="line"><span class="keyword">from</span> students <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">join</span> classes <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">on</span> s.class_id = c.id <span class="keyword">and</span> s.id &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>左外连接：返回结果除了内连接的数据外，还包括左表中不符合条件的数据，并在右表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>
<ul>
<li>右外连接：返回结果除了内连接的数据外，还包括右表中不符合条件的数据，并在左表相应列加 null 值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> 左表名 <span class="keyword">left</span> <span class="keyword">join</span> 右表名 <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure>
<h1 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h1><p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。  </p>
<p><img src="https://i.loli.net/2019/02/24/5c720eb160e17.jpg" alt="执行顺序">  </p>
<p>下面来分析一下这些语句：  </p>
<ol>
<li>FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li>ON: 对虚表VT1进行ON筛选，只有那些符合 <join-condition> 的行才会被记录在虚表VT2中。</join-condition></li>
<li>JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3,如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li>
<li>WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合 <where-condition> 的记录才会被插入到虚拟表VT4中。</where-condition></li>
<li>GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li>CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li>HAVING： 对虚拟表VT6应用having过滤，只有符合 <having-condition> 的记录才会被 插入到虚拟表VT7中。</having-condition></li>
<li>SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li>DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li>ORDER BY: 将虚拟表VT9中的记录按照 &lt;order_by_list&gt; 进行排序操作，产生虚拟表VT10.</li>
<li>LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。  </li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">路边的土豆</p>
  <div class="site-description" itemprop="description">高山仰止，景行行止。虽不能至，心向往之。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">路边的土豆</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
