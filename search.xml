<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络那些事之传输层]]></title>
    <url>%2F2020%2F01%2F22%2F%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[概览本层将会涉及： 复用/分用 可靠数据传输 流量控制 拥塞控制 TCP/UDP 传输层传输层协议为运行在不同 Host 上的进程提供了一种逻辑通信机制。所谓逻辑通信，指发送方接收方像是直接通信，下面的协议是透明的。 传输层与网络层不同在于传输层提供进程之间逻辑通信，网络层提供主机之间逻辑通信。 多路复用与多路分用某层一个协议直接对应上层多个协议/实体，则需要复用/分用。 多路复用：传输层从多个 socket 接收数据，进行头部封装后交给网络层。 多路分用：传输层从网络层接收数据，根据头部信息分发给多个 socket。 TCP/UDP 的多路复用分用UDP socket 通过目的端口号唯一确定，来自不同客户端有相同目的端口的 UDP 报文会被发到相同的服务器 socket 上。 TCP socket 通过原IP，目的IP， 原端口号，目的端口号唯一确定，来自不同客户端有相同目的端口的 TCP 报文会被发到不同的服务器 socket 上。 UDP 复用/分用 错误校验（无纠错） 属于无连接协议，提供尽力而为的服务。报文可能丢失，可能非按序到达。 checksum：校验和。负责错误校验。 为什么在传输层做链路检测传输层是端到端协议，不能确保这层以下的层次都有错误校验机制。因此需要在离应用层最近的这一层做错误校验。 优势 延迟低（无连接）。 实现简单（不维护连接状态）。 头部开销少（只需 8bytes，而 TCP 头部需要 20bytes）。 没有拥塞控制，可以控制发送时间和速率。 可靠数据传输可靠：不错（带纠错），不丢，不乱。 不错利用校验和检测位错误。如果有错误，尝试进行恢复。 如何从错误中恢复确认（Acknowledgements，ACK）：接收方显示告知发送方分组已正确接收。 NAK：接收方显示告知发送方分组错误。 发送方收到 NAK 后，重传分组。如果收到的 ACK/NAK 坏掉，重传分组。 解决重传分组重复问题序列号：发送方给每个分组增加序列号。接收方丢弃重复分组。 如果接收方用 ACK 告知最后一个正确接收分组的序列号，可以不使用 NAK。 不丢发送方等待“合理”时间，这个时间内没收到 ACK，重传分组。如果这个时间设置过短，依然能正常通信，但是会产生冗余包： 提高性能（不乱）利用流水线机制与滑动窗口协议。为了实现流水线机制，我们需要： 更大的序列号范围 更大的存储空间以缓存分组 滑动窗口协议窗口：允许使用的序列号范围 N。 滑动窗口：随着协议的运行，窗口在序列号空间内向前滑动。 GBN（后退N帧） 协议采用累积确认机制，ACK(n)：确认到序列号 n（包含n）的分组已被正确接受。为分组设置定时器。 超时事件Timeout(n)：重传序列号大于等于 n 的所有未确认分组。 发送方维护两个变量：base and nextseqnum： 12345678910111213141516171819202122232425if (nextseqnum &lt; base + N) &#123; // 如果有窗口内有可用序列号 udt_send(packet[nextseqnum]) // 发送编号为 nextseqnum 的数据 if (base == nextseqnum) start_timer; // 开始定时器 nextseqnum++;&#125; else &#123; refuse_data(data); // 拒绝发送&#125;if timeout or corrupt(rcvpkt) &#123; // 如果超时或收到损坏的 ACK start_timer; // 重置定时器 udt_send(data[base]) ... udt_send(data[nextseqnum-1]) // 重传所有未确认分组&#125;if notcorrupt(rcvpkt) &#123; // 如果正常收到 ACK base = getacknum(rcvpkt) + 1; // 更新 base，窗口向前滑动！ if (base == nextseqnum) // 所有已发送分组均被正确接收 stop_timer; else start_timer;&#125; 接收方值只记住一个变量 expectedseqnum： 12345678if !corrupt(rcvpkt) and hasseqnum(rcvpkt, expectedseqnum) &#123; // 如果正确接收分组 data = extract(rcvpkt); deliver(data); // 向应用层传递数据 udt_send(expectednum, ACK, checksum); // 发送 ACK(expectedseqnum) expectednum++; // 更新 expectedseqnum&#125; else &#123; // 分组损坏 or 乱序到达：直接丢弃 udt_send(expectednum, ACK, checksum);&#125; SR（选择重传）协议接收方对每个分组单独确认，设置缓存机制，缓存乱序到达分组。发送方只重传没收到 ACK 的分组，为每个分组都设置定时器。 在接收方，我们也设置一个窗口： TCPTCP 的可靠数据传输，既不是 GBN，也不是 SR！ 复用/分用 点对点传输 流水线机制 发送方/接收方缓存（SR） 双全工 面向连接 流量控制 序列号指 segment 中第一个字节的编号而不是 segment 的编号，建立 TCP 连接时，双方随机选择序列号。 ACKs 指希望收到的下一字节序列号，使用累计确认机制（GBN）。 触发重传的事件 超时 收到重复 ACK TCP 只使用一个计时器。 设置定时器超时时间SampleRTT：从段发出到收到 ACK 用时。 EstimatedRTT：多个 SampleRTT 加权平均值。 超时时间间隔（TimeoutInterval） = EstimatedRTT + 安全边界（DevRTT） 快速重传通过检测多个重复的 ACK，发送方确认某个分组已经丢失。快速重传可以在定时器超时之前即进行重传。 如果发送方收到对某一数据的 3 个 ACK，则启动快速重传机制。 流量控制本质上，流量控制是一种速度匹配机制。 接收方为 TCP 连接分配 Buffer： 接收方通过在 Segment 头部字段将 RcvWindow 告诉发送方。发送方已发送但未接收 ACK 的数据量不超过 RcvWindow。 RcvWindow = 0，发送方仍然可以发送一个很小的段来更新 RcvWindow 值。 TCP 连接管理三次握手： 客户端发送 SYN 报文。 服务器发送 SYN/ACK 报文 客户端发送 ACK 报文，此时可以包含数据。 四次挥手： 客户端发送 FIN 报文 服务器发送 ACK。发送 FIN 客户端收到 FIN，回复 ACK，进入等待状态（确保服务器正确关闭资源） 服务器收到 ACK，连接关闭 拥塞控制与流量控制考虑端到端时延不同，拥塞控制是出于避免发出过多报文导致网络拥塞的考虑。如果说流量控制是小乘佛法，那么拥塞控制就是大乘佛法。 网络层不显式提供拥塞控制支持，端系统通过观察丢失、时延等网络行为判断是否发生拥塞。 基本原理发送方设置一个变量 CongWin，动态调整变量以改变发送速率。保证： LastByteSend - LastByteAcked &lt;= CongWin rate = CongWin/RTT 如何感知网络拥塞发生 Loss 事件（超时或收到 3 个重复 ACK）后，发送方调整速率。 如何调整速率加性增-乘性减（拥塞避免）逐渐增加发送速率，直到发生 Loss。 方法：AIMD（Additive Increase，Mutiplicative Decrease）： Additive Increase：每个 RTT 将 CongWin 增大一个 MSS（Max Segment Size） Mutiplicative Decrease：发生 Loss 后将 CongWin 减半 慢启动TCP 连接建立时，CongWin = 1。此阶段可用带宽远高于初始速率。 原理：每收到一个 ACK，执行 CongWin++（指数增长，每次翻倍）。记录一个变量 Threshold = CongWinSize(Loss)。CongWinSize 超过 Threshold 后由指数增长变为线性增长。 Loss 处理： 3 个重复 ACK：CongWinSize /= 2，然后线性增长 Timeout：CongWinSize = 1，然后指数增长（达到 Threshold 后再线性增长） Timeout 比重复 ACK 更严重！ CongWinSize &lt; Threshold，CongWinSize 指数增长 CongWinSize &gt; Threshold，CongWinSize 线性增长 收到 3 个重复 ACK，Threshold = CongWinSize / 2，CongWinSize /= 2（Threshold == CongWinSize） 发生 Timeout，Threshold = CongWinSize / 2，CongWinSize = 1]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归、迭代与回溯]]></title>
    <url>%2F2020%2F01%2F19%2F%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[递归、迭代与回溯递归递归是程序执行过程函数调用自己不断压栈的过程，将一个大问题分解为若干个性质相似的小问题。一个递归模型必须包含两部分： 递归体 和 递归出口 。以求解斐波那契数列为例， 1234def Fib(n): if n == 0 or n == 1: return n # 递归出口 return Fib(n-1) + Fib(n-2) # 递归体 迭代递归深度过大会导致浪费系统资源，同时拖慢程序运行速度。所以，有时候我们需要把递归解法转化为非递归。 对于不需要回溯的问题，可用直接转换法，用中间变量来保存中间结果。这种方法在 尾递归 或 单向递归 中很常见，还是以斐波那契数列为例： 123456789101112def Fib(n): if n &lt;= 1: return n i = 0 j = 1 while n &gt; 1: result = i + j # 用中间变量保存迭代结果 i = j j = result n -= 1 return result 回溯对于不能直接求值，需要回溯的问题，利用栈保存中间结果。例如下面这个逆序输出用户输入的函数： 123456789void test(int sum)&#123; int x; scanf(“%d”, &amp;x); if (!x) sum = 0; else test(sum); sum += x; printf(“%d”, um);&#125; 可见这个函数不是简单的单向递归，在递归结束后还要执行一些操作。这就必须用栈来消去递归： 1234567891011121314151617181920void ditui(int sum)&#123; Stack S; StackInitiate(&amp;S); int x, e; scanf(“%d”, &amp;x) ; while (x) &#123; StackPush(&amp;S, x); scanf(“%d”, &amp;x); &#125; sum=0; printf(“%d”, sum); while (StackNotEmpty(S)) &#123; StackPop(&amp;S, &amp;e); sum+=e; printf(“%d”, sum); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管程]]></title>
    <url>%2F2019%2F10%2F13%2F%E7%AE%A1%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[管程管程是一种抽象概念，封装了一个锁、几个条件变量和共享资源。锁保证了某个时刻只有一个线程能进入管程，而条件变量用来控制共享资源。 条件变量每个条件变量表示一种等待原因，对应一个队列，当进程由于共享资源被占用进入等待状态时，我们称其 挂在 某个条件变量上。 条件变量有一个 wait 方法和一个 signal 方法。wait 方法释放当前线程进入管程时获得的锁然后阻塞它。如果有线程挂在这个条件变量上，signal 方法会释放一个队列中的线程，否则 signal 就是一个空操作。 1234567891011121314151617181920212223242526272829303132333435from threading improt Event, get_identfrom Collections improt dequeevent = Event()class Condition: def __init__(self): self.waitting_value = 0 # 挂在这个条件变量上的线程数目 self.queue = deque global event def wait(self, lock): """ 把当前线程挂在这个条件变量上 :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源 :return: """ self.waitting_value += 1 self.queue.append(get_ident()) print("Now we are in the thread: &#123;&#125;, executing wait()".format(get_ident())) lock.release() # 释放当前线程的lock，让别的线程有机会被执行 event.wait() # 阻塞当前线程 lock.acquire() # 请求再次进入管程 def signal(self): """ 如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作 """ if self.waitting_value &gt; 0: self.queue.popleft() print("Now we are in the thread: &#123;&#125;, executing signal()".format(get_ident())) event.set() # 唤醒一个线程 self.waitting_value -= 1 event.clear() 用管程实现生产者-消费者问题问题描述： 一个或多个生产者产生数据后放在缓冲区里 单个消费者从缓冲区里取出数据处理 任何时刻只有一个生产者或消费者可以访问缓冲区 问题分析： 任何时刻只能有一个线程操作缓冲区（互斥访问） 缓冲区空时，消费者必须等待生产者（条件同步） 缓冲区满时，生产者必须等待消费者（条件同步） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from collections import dequefrom threading import Lock, Event, get_ident, Threadfrom random import randintfrom time import sleepevent = Event()class Condition: def __init__(self): self.wait_value = 0 # 挂在这个条件变量上的线程数目 global event def wait(self, lock): """ 把当前线程挂在这个条件变量上 :param lock: 管程的锁。同一时刻只有一个线程能获得管程内的资源 :return: """ self.wait_value += 1 print("Now we are in the thread: &#123;&#125;, executing wait()".format(get_ident())) lock.release() # 释放当前线程的lock，让别的线程有机会被执行 event.wait() # 阻塞当前线程 lock.acquire() # 请求再次进入管程 def signal(self): """ 如果有线程挂在这个条件变量上，signal 选择一个唤醒；如果没有这就是个空操作 """ if self.wait_value &gt; 0: print("Now we are in the thread: &#123;&#125;, executing signal()".format(get_ident())) event.set() # 唤醒一个线程 self.wait_value -= 1 event.clear()class BoundBuffer: def __init__(self, max): self.count = 0 # 共享资源 self.not_full = Condition() # 条件变量 self.not_empty = Condition() # 条件变量 self.lock = Lock() # 锁 self.buffer = deque() self.max = max def deposit(self): while True: self.lock.acquire() sleep(1) while self.count == self.max: self.not_full.wait(self.lock) product = randint(1, 100) self.buffer.append(product) print("add &#123;&#125; to the buffer".format(product)) self.count += 1 self.not_empty.signal() self.lock.release() def remove(self): while True: self.lock.acquire() sleep(1) while self.count == 0: self.not_empty.wait(self.lock) print("remove &#123;&#125; from the buffer".format(self.buffer.popleft())) self.count -= 1 self.not_full.signal() self.lock.release()if __name__ == "__main__": model = BoundBuffer(3) generator = Thread(target=model.deposit,) comsumer = Thread(target=model.remove,) generator.start() comsumer.start()]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 禁止创建泛型数组]]></title>
    <url>%2F2019%2F01%2F27%2FJava%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[java 不允许直接创建泛型数组，也不允许创建泛型实例。也就是说下面这种情况是不被允许的： 12345public class Test&lt;T&gt; &#123; private T[] a = new T[1]; // error private T t = new T(); // error ...&#125; java 的泛型只停留在了编译层，编译器在编译完成后，会把泛型信息擦除，用第一个限定类型来替代，没有指定限定类型的泛型参数则用 Object 类替代： 1234567891011// 指定了泛型参数的限定类型public &lt;T extends Comparable&gt; void test1() &#123;...&#125;// 经编译器类型擦除后public &lt;Comparable&gt; void test1() &#123;...&#125;// 无限定类型public &lt;T&gt; void test2() &#123;...&#125;// 经编译器类型擦除后public &lt;Object&gt; void test2() &#123;...&#125; 经过类型擦除后，拥有不同泛型参数的泛型类在虚拟机眼中就是一样的了： 123Test&lt;String&gt; t1 = new Test&lt;&gt;();Test&lt;Integer&gt; t2 = new Test&lt;&gt;();t1.getClass() == t2.getClass(); // true java 允许父类的引用类型指向子类实例，而 Object[ ] 是任何数组的父类，这个时候如果我们往里面放不同于原始数据类型 但是满足后来使用的父类类型的话，编译不会有问题。如果是普通类，这样做也不会有什么问题，因为在运行时会检查加入数组的对象的类型，所以下面这段代码运行时会报错 ArrayStoreException： 1234String[] s = new String[10];Object[] o = s; // OKInteger i = new Integer(2);o[0] = i; // throws ArrayStoreException 如果可以创建泛型数组，那么一个 Object 数组引用类型指向这个泛型数组实例是可行的： 12Test&lt;String&gt;[] tarr = new Test&lt;&gt;[10]; // 实际不行，假设可行Object[] o = tarr; 编译器编译时会根据引用类型进行类型检查，所以以下代码可以通过编译。在运行时会检查加入数组的对象的类型，但由于类型擦除，不同泛型参数的泛型类在虚拟机眼里是类型相同的，那么在运行时一个 Test 实例成功被放进 Test[ ] 中了： 12Test&lt;Integer&gt; t = new Test&lt;&gt;();o[0] = t; 一个与泛型数组类型不同的实例可以被加入数组中而 java 无法检测到这一错误。那么很显然无法保证泛型数组元素类型的一致性，其后果不言而喻。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask——启动吧，Flask！]]></title>
    <url>%2F2018%2F11%2F15%2FFlask%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[新一代虚拟环境工具：pipenv以前虚拟环境主要靠 virtualenv， 配合 requirements.txt 做到一键安装依赖的效果。但是 requirements.txt 需要手动管理包记录，每次安装新的包之后都要更新这个文件，很麻烦。现在有了新的工具 pipenv。pipenv 将虚拟环境配置与依赖包管理整合在一起，并自动记录依赖包的安装、更新与卸载。真正做到了”一键使用“。pipenv 的用法参考这篇文章。 启动Flask在 Flask 更新到版本 1.0 以后，不再推荐使用下面的方式启动 Flask 1app.run() 取而代之的是命令 1flask run Flask 根据以下规则会自动探测程序实例： 从当前目录寻找 app.py 或 wsgi.py 模块，并从中寻找名为 app 或 application 的实例 从环境变量 FLASK_APP 对应的值寻找名为 app 或 application 的实例 例如，如果 Flask 实例 app 位于 hello.py，将 FLASK_APP 设为 hello，Flask 就会在当前目录的 hello.py 模块寻找实例 Flask 默认为生产模式(production mode), 通过环境变量 FLASK_ENV 可以修改为开发模式(debug mode)： 1FLASK_ENV = development 利用 –host 与 –port 参数可以修改 Flask 运行主机与端口 12flask run --host=0.0.0.0flask run --port=9000 也可以通过环境变量 FLASK_RUN_HOST 与 FLASK_RUN_PORT 设置。 可以通过 flask --help 查看所有可用命令 管理环境变量如果安装了 python-dotenv 包， Flask 会从 .env 文件 和 .flaskenv 文件中加载环境变量。此时 Flask 加载环境变量的优先级是：系统环境变量 &gt; .env 中的环境变量 &gt; .flaskenv 中的环境变量 .env 用于存放公开环境变量, 如 FLAKS_APP, .flaskenv 用于存放敏感环境变量如 Email 账号密码： 1234!# MyFlask/.env# 这是注释FLASK_APP = hello Shell用如下命令可以启动带有上下文的 Python Shell 环境： 1flask shell 和其他 flask 命令相同，在执行这个命令前要确保 Flask 实例可以被找到 flask 命令通过为一个函数添加 @app.cli.command() 装饰器，可以注册一个 flask 命令。函数的名称即为命令名，也可以通过给装饰器传参的方式命名： 123@app.cli.command('greet')def hello(): click.echo('hello!') flask 命令是通过 Click 包实现的，更多关于自定义命令的设置和功能请看Click文档]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解堆和栈]]></title>
    <url>%2F2018%2F07%2F18%2F%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[堆（heap）和栈（stack）都是数据结构。在运行程序时，需要在内存中开辟相应的空间。同理，运行JVM也是需要内存空间的，启动时在自己的内存空间中进行更细致的划分。因为虚拟机中每一篇内存处理的方式都不同，所以要单独进行管理。 JVM内存的划分有五片：寄存器，本地方法区，方法区，堆内存和栈内存。 堆内存堆存放在二级缓存中，储存数组和对象（数组本质上也是对象）。Java用new关键字创建一个对象，换言之凡是new建立的对象都储存在堆中。堆中存放的对象用于封装数据。如果对象的一个数据消失，这个对象并不会随之消失，所以堆是不会随时释放的。对象的生命周期由JVM的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 栈内存栈使用一级缓存，由系统自动分配释放。他们通常都是被调用时处于存储空间中，调用完毕立即释放。栈储存函数的参数值，局部变量等。先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。 看一段代码： 1234String a = "hello";String b = new String("hello");System.out.println(a.equals(b)); // trueSystem.out.println(a == b); //false b指向一个String类对象，而a呢？java将其转化为以下几个步骤： 定义一个名为a的String类的对象引用变量：String a 在栈中查找是否有”hello”的地址，如果没有则开辟一个存放字面值为”hello”的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”hello”的地址，则查找对象o，并返回o的地址。[此处数据不是通过new（）创建的] 将a指向对象o的地址 equals方法检查两个对象值是否相等，而==检查内存地址是否相等。所以此时equals与==会结果不同 区别下面总结一下栈内存和堆内存的区别： 栈内存存储的是局部变量而堆内存存储的是实体 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础-使用集合类]]></title>
    <url>%2F2018%2F06%2F28%2Fjava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[将集合的接口与实现分离Java集合类库将接口（interface）与实现（implementation）分离。在使用集合类时，一旦构建了集合就不需要知道究竟使用了哪种实现，因此只有在构建集合对象时使用具体的类才有意义。可以使用接口类型存放集合的引用：12Queue&lt;Customer&gt; expressLane = new LinkedListQueue&lt;&gt;();expressLane.add(new Customer("David")); 这样做有利于随时更改实现类型，当发现有更合适的实现类时，只需要修改调用构造器处的代码就可以了：1Queue&lt;Customer&gt; expressLane = new CirculArrayQueue&lt;&gt;(100); Collection接口集合类的基本接口是Collection接口,这个接口有两个方法：123456public interface Collection&lt;E&gt;&#123; boolean add(E element); Iterator&lt;E&gt; iterator(); ...&#125; add方法用于向集合中添加元素。如果添加成功返回true，否则false。iterator方法返回一个实现了Iterator接口的对象，这个对象又称为迭代器，可以用这个迭代器依次访问集合中的元素 迭代器Iterator接口包含4个方法：1234567public interface Iterator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(Consumer&lt;? super E&gt; action);&#125; Java迭代器的查找与位置变更是紧密相连的，查找一个元素的唯一方法是调用next()，而在执行查找操作时，迭代器的位置随之向前移动。当调用next()时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。而remove()会从迭代器中删除上次调用next()方法时返回的元素。 迭代器应理解为处于两个元素之间，当调用next()时，迭代器就越过下一个元素并返回刚刚越过的那个元素的引用。 链表Java中所有链表都是双向的。对于链表，尽量不使用随机访问而使用遍历操作，否则效率很低。Java提供了LinkedList类，可以很简单实现列表：1234567List&lt;String&gt; staff = new LinkedList&lt;&gt;(); // LinkedList类实现了List接口staff.add("Susan");staff.add("David");staff.add("Mike");Iterator&lt;String&gt; iterator = staff.iterator();iterator.next();iterator.remove(); 通过add方法可以向链表尾部添加元素。想要在链表中间插入元素，由于迭代器是表述集合中位置的，所以要借助迭代器实现，而只有在有序集合中这样做才有意义，Iterator是使用与所有集合的，所以对于有序集合，Java提供了Iterator的子类ListIterator：12345678List&lt;String&gt; staff = new LinkedList&lt;&gt;();staff.add("Susan");staff.add("David");ListIterator&lt;String&gt; iter = staff.ListIterator();iter.next();iter.add("Mike"); // 在Susan之后，David之前添加MikeString first = iter.previous(); // 反向遍历链表iter.remove(); // 删除被previous越过的元素Mike set方法用于替换被next或previous越过的元素：12345List&lt;String&gt; staff = new LinkedList&lt;&gt;();staff.add("Susan");staff.add("David");staff.next();staff.set("Mike"); // Susan被替换为Mike 泛型数组列表在Java中，可以用变量来确定数组的大小：1Employee staff[] = new Employee[num]; 为了达到数组动态变长/缩短的效果，使用泛型数组列表ArrayList。泛型即“参数化类型”、将类型参数化，类似于方法中的变量参数，只是此时类型也定义成参数形式（又称为类型参数）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面：1ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;(); 用add([int index,]obj)方法往数组列表添加元素，不指定索引则默认加到末尾。remove(int index)删除元素，get(int index)按索引获取元素，set(int index, obj)重置对应索引的元素（不能用于添加元素），size()方法获取ArrayList长度。 将数组列表拷贝到数组用toArray()方法：12X[] a = new X[list.size()];list.toArray(a); 泛型化与原始数组列表之间的兼容性在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型ArrayList。 散列集与树集散列集的查找性能比数组和链表都要高。散列表为每个对象计算一个数，称为散列码，散列码由对象的实例域产生一个整数，具有不同数据域的对象产生不同的散列码。java提供了set接口，由HashSet类实现。散列迭代器将依次访问所有的桶，由于散列将元素分散在表的各个位置上，所以访问它们的顺序几乎是随机的。 树集TreeSet类与HashSet十分相似，不过在遍历树集中的元素时默认按添加顺序排序。也可以在构造树集时提供一个Comparator改变排序规则。TreeSet类实现了SortedSet接口和NavigableSet接口。 队列队列可以在尾部添加一个元素，在头部删除一个元素。有两个端头的队列称为双端队列，可以在头部和尾部同时添加或删除元素。不支持在队列中间插入元素。java提供了Deque接口并由ArrayDeque和LinkedList类实现，这两个类都提供了双端队列。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础—处理异常]]></title>
    <url>%2F2018%2F06%2F24%2FJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[处理异常的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。如果某个方法不能采用正常的途径完成他的任务 ，就可以通过另外一个路径退出方法。在这种情况下，方法并不能返回任何值，而是抛出（throw）一个封装了错误信息的对象，然后这个方法会退出且不返回任何值。 异常又分为受查(check)异常与非受查(uncheck)异常。非受查异常包括Error类异常与RuntimeException类异常，这些异常都是因为程序本身设计不合理产生的，属于逻辑异常。而受查异常表示其他异常，如IOException。处理异常指的是处理受查异常。 throws/throw抛出异常一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。所以方法应在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出哪类受查异常。这就要用到throws关键字。例如FileInputStream类的构造器方法可能由于文件不存在而抛出一个FileNotFoundException：1234public FileInputStream(String name) throws FileNotFoundException&#123; ...&#125; 多个Exception之间用 ，分开。如果超类方法没有抛出任何异常，那么子类方法也不能抛出异常。 如果要手动抛出一个异常，用关键字throw。首先构造一个异常对象，然后用throw把这个对象抛出就可以了。如抛出一个EOFException：1throw new EOFException； try/catch捕获异常12345678try&#123; ...&#125;catch (ExceptionType e)&#123; ...&#125; 可以使用多个单独的catch字句捕获多个异常。异常对象可能包含与异常本身相关的信息，要想获得对象的更多信息可以用1e.getMessage() 对实现了AutoCloseable接口的资源进行处理时，可以使用带资源的try语句，这样无论是否成功使用资源，在try块退出时都会自动关闭资源：12345678910try (Resource res = ...)&#123; code&#125;// 打开hello.txttry (FileWriter writer = new FileWriter('hello.txt', true))&#123; deal with the resource&#125; 编译器严格执行throws说明符，如果方法A调用了方法B，而方法B被声明为可能抛出异常e，则A要么继承e（即声明为可能抛出e），要么捕获e finallyfinally块中的代码不管是否有异常被捕获，都会执行。并且如果处理结果与try/catch中的处理发生冲突，finally中的处理结果会覆盖之。123456789101112try&#123; code&#125;catch (ExceptionType e)&#123; code&#125;finally&#123; code&#125; ThrowableThrowable是类，Error和Exception都继承自这个类。所以也可以用try/catch进行捕捉12345try &#123; ...&#125;catch(Throwable t) &#123; t.printStackTrace();&#125; 在方法声明中，也可以抛出Throwable类异常，由这个方法的调用者处理：1234567891011121314public void test() throws Throwable&#123; ... throw new Throwable;&#125;public static void main(String[] args)&#123; try &#123; test(); &#125;catch(Throwable t) &#123; t.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Python中的赋值、引用、拷贝]]></title>
    <url>%2F2018%2F06%2F17%2FPython%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[全局变量在函数之外创建的变量属于__main__，又被称为全局变量。它们可以在__main__中的任意函数中访问，与局部变量在函数结束时消失不同，全局变量可以在不同函数的调用之间持久存在。 全局变量常常用作标志（Flags）。标志是一种布尔型变量，可以标志一个条件是否为真。1234567verbose = Truedef example(): if verbose: print('你好，今天天气很好！') else: print('你好') 如果在函数里尝试给全局变量赋值，必须先用global关键字进行声明，否则函数会创建一个同名局部变量而不是使用全局变量。123456verbose = Truedef example(): global verbose verbose = False print('你好') 对象、值和别名在Python中，string、tuple和number是不可变对象，而list、dict等是可变对象。 先来看一段代码：12345b = [1, 2, 3]a = bprint(a is b) # Trueb.append(4)print(a) # [1, 2, 3, 4] a is b返回True，说明这python内部a与b是相同的，变量a与变量b都指向同一个对象。此时称a和b为这个对象的别名。当对象的值发生改变时，a和b自然也会随之改变。如果a、b只是值相等而不指向同一个对象，我们称a与b是相等的。相同必定相等，相等不一定相同。123a = [1, 2, 3]b = [1, 2, 3]print(a is b) # False 我们平时说的【变量】其实只是标签，是对内存中对象的引用。赋值操作只是给变量一个指向对象的引用 is与==的区别写代码的时候常常用is和==来比较两个对象是否相等，但是它们有什么不同呢？参考下面的例子：12345678910111213141516171819a = 1b = 1a == b # Truea is b # Truea = 888b = 888a == b # Truea is b # Falsea = 'hello'b = 'hello'a is b # Truea == b # Truea = 'hello world'b = 'hello world'a == b # Truea is b # False is和==的结果不同！不是说好的都是比较两个对象是否相等吗？怎么到这里变了样了？不急，先介绍一下python内置的一个函数：id()，这个函数会打印参数的内存地址，让我们来试试：123456789a = 888b = 888id(a) # 1939743592336id(b) # 1939745557808a = 'hello world'b = 'hello world'id(a) # 1939745897200id(b) # 1939745912624 可以看到，尽管a、b的值是相同的，但是其内存地址却不同。那么答案就很显然了，is比较的是两个对象的内存地址是否相等，==比较的是两个对象的值是否相等。这样就能解释为什么is和==的结果不同了。But wait，那么为什么当a、b的值为1和’hello’时，is与==的结果是一样的呢？这就要说到python的小整数池和垃圾回收机制了。python为了让运行速度快些，在内存中专门开辟了一块区域放置-5到256，所有代表-5到256的对象都会指向这个区域。类似的，字符串类型作为Python中最常用的数据类型之一，Python解释器为了提高字符串使用的效率和使用性能，做了很多优化，例如：Python解释器中使用了 intern（字符串驻留）的技术来提高字符串效率，什么是intern机制？即值同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的，当然，肯定不能改变，这也决定了字符串必须是不可变对象。同时，如果字符串中有空格，默认不启用intern机制。对字符串储蓄池中的字符串使用is和==比较会得到相同的结果。：123456789a = 1b = 1id(a) # 1963327952id(b) # 1963327952a = 'hello' b = 'hello' id(a) # 1939745887600id(b) # 1939745887600 注意：在shell中，仅有以下划线、数字、字母组成的字符串会被intern。而pycharm中只要是同一个字符串不超过20个字符都被加入到池中 python传参python函数参数传递是引用传递：12345def test(n): print(id(n))k = "string"id(k) # 2305161642256test(k) # 2305161642256 深浅拷贝常用的拷贝方式有： 没有限制条件的分片表达式（L[:]）能够复制序列，但此法只能浅层复制。 字典 copy 方法，D.copy() 能够复制字典，但此法只能浅层复制 有些内置函数，例如 list，能够浅拷贝 list(L) copy 标准库模块能够生成完整拷贝：deepcopy 本质上是递归 copy，是深层复制 浅拷贝浅拷贝属于“新瓶装旧酒”，即生成了一个新的变量，而变量所指向的对象和原来的是一样的：1234567l = ["hello", [2, 3, 4]]id(l) # 3048239386824[id(i) for i in l] # [1524761040, 1524761072]k = l.copy()id(k) # 3048239387080，地址不同，k是另一个变量[id(i) for i in k] # [1524761040, 1524761072]，地址相同，指向同一个变量 深拷贝深拷贝属于“新瓶装新酒”，即生成了一个新变量，指向和原对象相等的新对象（不可变对象除外）：123456789import copyl = ["hello world", [2, 3, 4]]id(l) # 3048239386824[id(i) for i in l] # [3048239385040, 3048239387080]k = copy.deepcopy(l)id(k) # 3048240927048，地址不同，k是另一个变量[id(i) for i in k] # [3048239385040, 3048240927304]，字符串是不可变对象，所以仍指向原地址，对于list则分配了一片新的内存空间，只是值与原对象相同]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础—继承与多态]]></title>
    <url>%2F2018%2F06%2F15%2FJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[修饰符extends表示继承，子类会继承超类的域和方法。例如子类Manager继承超类Employee： 1234public class Manager extends Employee&#123; // 添加新的域或方法&#125; 覆盖方法想要访问超类的私域，需要使用修饰符super，用 super 代表超类。如：重写Manager的getsalary方法为基本工资+奖金。而salsry是private的，只有Employee类的方法才能访问。要获得基本工资必须通过调用超类getsalary方法。为了区别这两个方法，超类的方法表示为super.funcname([args])的形式： 12345public double getSalary()&#123; this.salary = bonus + super.getsalary(); return this.salary;&#125; 覆盖方法时，一定要保证返回类型的兼容性。允许子类将覆盖方法的返回类型定义为原返回类型的子类型。覆盖方法时，子类方法可见性不能低于超类。如果超类方法是public，那么覆盖方法也是public 子类构造器由于子类不能访问超类的私有域，所以必须在子类构造器中利用超类的构造器对超类私有域进行初始化。通过关键字super实现对超类构造器的调用。 super调用构造器语句必须是子类构造器的第一条语句： 12345678910public class Manager extends Employee&#123; private int bonus; ... public Manager(String aName) &#123; super(aName); this.bonus = 500; &#125;&#125; 方法调用与多态一个被定义为指向超类的变量可以指向子类，反之行不通。一个变量对象可以指向多种实际类型的现象被称为多态，在运行时能自动选择调用哪个方法的现象称为动态绑定。对于private、static、final方法，编译器可以准确地知道应该调用哪个方法，称为静态绑定 理解方法调用假设要调用x.f(args)。其中x为隐式参数，声明为类C的一个对象，下面是调用过程描述： 编译器查看对象的声明类型和方法名。可能存在多个名字为f，但参数类型不一样的方法。编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。至此编译器已获得所有可能被调用的候选方法 编译器查看调用方法是提供的参数类型。如果所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析。由于存在类型转换，所以该过程也遵循“相似原则”，形参类型与实参匹配度最高的优先。至此编译器已获得需要调用的方法名字和参数类型，即方法签名 在jvm创建的方法表中搜索相应的方法。每次调用都要进行搜索，开销太大。jvm创建了一张方法表，里面存放着方法签名与实际调用方法的映射关系。 阻止继承：final类和方法不允许扩展的类被称为final类。如果定义类的时候用了final修饰符就表明这个类是final类： 1234public final class Programmer extends Employee&#123; ...&#125; 类中的方法也可以被声明为final。如果这样做子类就不能覆盖这个方法（final类的所有方法默认为final方法）： 12345678public class Employee&#123; ... public final String getName() &#123; return this.name; &#125;&#125; 将方法或类定义为final最大的好处是防止其在子类中被改变含义。 受保护访问最好将类中的域标记为private，任何声明为private的内容对其他类都是不可见的，即使是子类也一样。如果希望子类能够访问超类的私有域或方法，可以用修饰符：protected 12345678910public class Employee&#123; protected salary; ... public protected double getsalary() &#123; return this.salary; &#125;&#125; Java的4种可见性修饰符下面是Java用于控制可见性的4种修饰符： 仅对本类可见——private 对所有类可见——public 对本包和所有子类可见——protected 仅对本包可见——默认，不需要修饰符 对象包装器Java不是完全的面向对象语言，其基本类型：boolean、char、short、int、long、float、double的值都不是对象。而这些基本类型都有与之对应的类。如int对应Integer，char对应Character，void对应Void…对象包装类包装的值都是不变的。 要定义一个整形数组列表，只要： 1ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 此时，调用： 1list.add(3) 编译器将会将其视为： 1list.add(Integer.valueOf(3)) 这种行为称为自动装箱，与之对应的还有自动拆箱。手动拆箱的方法为Integer.parseInt(Integer obj)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础—包]]></title>
    <url>%2F2018%2F06%2F15%2FJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%8C%85%2F</url>
    <content type="text"><![CDATA[包Java允许使用包（package）将类组织起来，使用包的主要原因是确保类名的唯一性。如果有两个名字相同的类，只要把它们放在不同的包中就不会有影响。 从编译器（compiler）的角度看，嵌套的包之间没有任何关系。例如java.util包与java.util包毫无关系，每一个都拥有独立的类集合。 当编译一个.java文件（即一个编译单元）时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与.java文件中每个类的名称相同，只是多了一个后缀名.class。因此在编译少量.java文件之后，会得到大量的.class文件。每一个.java文件编译以后都会有一个public类，以及任意数量的非public类。因此每个.java文件都是一个构件，如果希望许许多多的这样的构件从属于同一个群组，就可以在每一个.java文件中使用关键字package。而这个群组就是一个类库。 就表示你在声明该编译单元是名为fruit的类库的一部分，或者换句话说，你正在声明该编译单元中的public类名称是位于fruit名称的保护伞下，由fruit名称罩着。任何想要使用该public类名称的人都必须指定全名或者与fruit结合使用关键字import。 将类放入包中要想将类放入包中，就必须将包的名字放在源文件的开头。包中定义类的代码之前。使用关键字package：1234567// 文件名为Employee.java，位于目录com/qiuyueqy/learnjava下package com.qiuyueqy.learnjava;public class Employee&#123; ...&#125; 上面代码表明编译单元位于com.qiuyueqy.learnjava的保护伞下，任何想要使用该public类的人必须指定全名或使用修饰符import 如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包 编译器对文件（以.java为扩展名）进行操作，而java解释器加载类（以.class为扩展名） 类的导入一个类可以使用所属包中所有的类，一起其他包的公有类。可以用两种方式访问其他包的公有类： 在类名前加上完整的包名123456789java.time.LocalDate date = new java.time.LoalcDate.now();``` - 通过关键字`import`导入，**`import`必须在`package`之后**```javapackage com.qiuyueqy.learnjava;import java.time.*;import java.util.Date; 静态导入import语句不仅可以导入类，还可以导入类的静态方法和静态域：12// 导入System类的静态方法和静态域import static java.lang.Systme.*; 这样就可以使用System类的静态方法和域，而不用加前缀：12out.println("Hello World!"); // System.out.println()exit(0); // System.exit() 包作用域一个类、方法或变量如果没有指定private或public，则可以被同一个包中的所有方法访问（如非公）。 类路径javac编译器要查询一个编译单元，会先从当前包开始，然后查询所有import语句，确定import语句导入的包中是否包含所需要的类。 java虚拟机（jvm）查询类文件时，它首先在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件里找，如果找不到再从环境变量CLASSPATH（可以通过操作系统来设置）里面找。CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包名称并将每个句点替换成反斜杠，以从CLASSPATH根中产生一个路径（例如，package fruit.Apple就变成为fruit/Apple或fruit/Apple或其他，这将取决于操作系统）。得到的路径会与CLASSPATH中的各个不同的根目录路径相连接以获得一个完整的目录路径，解释器就在这些目录中查找与你所需要的类名称相同的.class文件。 类文件默认与java文件处于同一位置，但也可以存储在jar（java归档）文件中。jar文件是多个压缩形式的类文件和子目录的集合。通过使用jar文件可以使类被多个程序共享。为了达到这个目的，需要做到以下几点： 把类放到一个目录中。这个目录是一个树状结构的基目录。例如：如果希望将com.qiuyueqy.learnjava类添加到其中，这个learnjava.class类文件就必须位于子目录/home/user/classdir/com/qiuyueqy中 将jar文件放在非类路径中，如：/home/user/archives 设置类路径（class path）。类路径是所有包含类文件的路径的集合。123/home/user/classdir:.:/home/user/archives/archives.jar // Linux下C:\classdir;.;C:\archives\archives.jar // windows下 类路径包括： 基目录: 如/home/user/classdir和C:\classdir 当前目录: . jar文件： 如/home/user/archives/archives.jar或C:\archives\archives.jar 设置类路径最好通过-classpath或-cp选项指定类路径，例如要执行Employee.class：1java -classpath /home/user/classdir:.:/home/user/archives/archives.jar Employee 也可以通过设置环境变量CLASSPAHT。默认CLASSPATH为.，改为我们需要的路径集合:123set CLASSPATH=C:\classdir;.;C:\archives\archives.jar //windows下export CLASSPATH=/home/user/classdir:.:/home/user/archives/archives.jar // Linux下 这样在shell退出前CLASSPATH变量都有效]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础—类与接口]]></title>
    <url>%2F2018%2F06%2F13%2FJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[对象与对象变量Java中，只有基本类型(primitive types)不是对象，例如number，string和boolean。 首先要清楚：对象与对象变量是不一样的。对象变量只是对对象的一个引用。 想使用对象变量，首先要构造对象并指定其初始状态。在定义类时，使用构造器指出如何初始化这个类，在构造一个新实例时，构造器会运行，将实例域初始化为所希望的状态。构造器是一种特殊的方法，没有返回值。构造器的名字与类名相同。一个类有一个或多个构造器方法。不要在构造器中定义与实例域重名的局部变量，否则编译器会报错。123456789101112class Bird&#123; private String colour; private int sex; // 下面这个就是构造器，方法名与类名相同 public Bird(String c, int s) &#123; this.colour = c; this.sex = s; &#125;&#125; 要构造一个对象，需要在构造器前面加上new操作符：1Bird bird = new Bird("绿色", 0) // 这里的Bird应该理解为调用Bird类的构造器，构造器前加上new操作符 bird是一个对象变量，并没有实际包含一个对象，而仅仅引用一个对象。任何对象变量的值都是对存储在另一个地方的一个对象的引用 更改器方法与访问器方法对于每个特定的类实例，都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。实现封装的关键是绝不能让类中的方法直接地访问其他类的实例域。程序仅能通过对象的方法与对象的实例域进行交互。对象的方法会改变原对象的状态，称之为更改器方法。只访问实例域而不改变原对象状态的方法，称之为访问器方法。 访问器方法不要返回可变对象，否则获取这个对象后通过调用可变对象的更改器方法会破坏封装性！ 自定义类关键字public修饰的类称为共有类。在一个.java源文件（编译单元）中，只能有一个共有类，类名与文件名相同。可以有多个非公有类。包之外的世界是无法看见这些非公有类的，因为它们不是public类，而且它们主要用来为公有类提供支持。 关键字public修饰的方法、字段意味着任何类的任何方法都可以通过点操作调用这些方法和字段，而private确保只有自身类可以访问这些实例域或方法。（同属一个类的实例可以互相访问访问私有域） 可以把实例域定义为final。构造对象时必须要初始化这样的域（构造器之前），并且在后面的操作中不能再对它进行改变。 静态域如果将域定义为static，每个类中只有一个这样的域。而每个对象对于所有的实例域却都有自己的一份拷贝。这样就把实例域与静态域区分开来：每个实例有自己的实例域，而各个实例共享一个静态域。 静态常量例如，在Math类中定义圆周率：123456public class Math&#123; ... public static final double PI = 3.14159265758; ...&#125; 在程序中，可以使用Math.PI获取这个常量。如果关键字static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math对象都有他自己的一份PI拷贝每个类对象都可以对公有域进行修改，所以最好不要把域设计成public。然而共有常量（即final域）却没有这个问题，因为PI被声明为final，不允许再修改它的值。 方法方法封装了一系列语句所描述的运算。方法需要参数（某种数据类型的值）并根据参数计算出某种数据类型的返回值（例如数学函数的结果）或者产生某种副作用（例如main函数） 静态方法静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有this参数的方法。静态方法不能访问实例域，因为它不能操作对象，但是静态方法可以访问自身类的静态域。一下两种情况适合用静态方法： 一个方法不需要访问对象状态，其所需要的参数都是通过显示参数提供 一个方法只需要访问类的静态域 静态方法还有一种常见用途就是用静态工厂方法构造对象，而不是使用new构造符。 main方法调用静态方法不需要使用对象，同理，main方法也是静态方法。main方法不对任何对象进行操作，事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象每个类可以有一个main方法，这是常用于类的单元测试的技巧，例如：123456789101112131415161718192021class Employee&#123; private String name; private int age; private double salary; public Employee(String n, int a, double s) &#123; this.name = n; this.age = a; this.salary = s; &#125; ... public static void main(String[] args) &#123; Employee e = new Employee("Mike", 21, 2354); e.raiseSalary(10); &#125;&#125; 如果想独立测试Employee类，只需执行1java Employee 如果Employee类是一个Application的一部分，可以用如下命令执行程序1java Application 此时Employee中的main方法不会被执行 方法参数java的对象引用是按值传递而不是引用调用。方法得到的是所有参数值得一个拷贝，而不是指针。方法不能修改传递给它的任何参数变量的内容。1234public static void raiseSalary(double Salary)&#123; Salary = Salary * 3; // 这不会对Salary对应的实参造成任何影响&#125; 但是，改变对象参数状态不是一件难事。由于java得到的是对象引用的拷贝，而对象引用及其拷贝都会指向同一个对象，所以可以通过改变对象引用拷贝达到修改对象参数的目的：1234public static void raiseSalary(Employee e)&#123; e.Salary = e.Salary * 3; // 这会修改Employee实例的Salary域&#125; 总结一下： 一个方法不能修改一个基本数据类型的参数 一个方法可以改变一个对象参数的状态 一个方法不能让对象参数引用一个新的对象（即无法改变实参的引用对象，这点也是由按值传递决定的） 对象构造Java提供了多种编写构造器的机制 重载多个方法有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法（这个过程称为重载解析）。123456789101112131415161718class Employee&#123; private int id; private String name; public Employee(String aName, int aid) &#123; this.name = aName; this.id = aid; &#125; public Employee(int aid) &#123; this.name = "Employee"; this.id = aid; &#125; ...&#125; Java允许重载任何方法，而不仅仅是构造器方法。因此，要完整地表述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。例如：String类有4个称为indexOf的公有方法，它们的签名是： indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int) 返回类型不是方法签名的一部分。也就是说：不能有两个名字相同，参数类型相同，返回值类型却不同的方法 默认域初始化如果在构造器中没有显式地给域赋初值，那么就会自动地赋为默认值：数值为0，布尔值为false，对象引用为null。这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，而不一定要明确初始化域。 无参数构造器很多类都包含一个无参数的构造函数，对象由无参数的构造函数创建时，其状态会设置为适当的默认值：12345678910class Employee&#123; ... public Employee() &#123; this.name = ""; this.salary = 5000; ... &#125;&#125; 如果在编写一个类时没有编写构造器，那么系统会提供一个无参数构造器，该构造器将所有实例域设置为默认值：数值为0，布尔值为false，引用对象为null 显示域初始化通过重载类的构造器方法啊，可以采用多种形式设置类的实例域的初始化方法，确保无论怎样调用构造器，每个实例域都可以被设置为一个有意义的初值。 可以在类定义中直接将一个值赋给任何域。在执行构造器之前，先执行赋值操作。初始值不一定是常量值，也可以调用方法对域进行初始化：12345678910111213class Employee&#123; private static int nextId = 1; private int id = assignId(); public int assignId() &#123; int r = nextId; nextId++; return r; &#125; ...&#125; 调用另一个构造器关键字this引用方法的隐式参数。然而，这个关键字还有另一个含义：如果构造器的第一个语句形如：this(...)，这个构造器将调用同一个类的另一个构造器，这样对公共的构造器代码部分只编写一次即可：12345public Employee(double s)&#123; // 调用另一构造器 Employee(String aName, double aSalary) this("Employee #" + nextId, s)&#125; 对象初始化块在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行：123456789101112131415class Employee&#123; private static int nextId = 1; private int id; private String name; private double salary; // 初始化域 &#123; this.id = nextId; nextId++; &#125; ...&#125; 无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器。 下面是调用构造器的具体处理步骤： 所有数据域初始化为默认值（0，false，null） 按照在类声明中出现的次序，依次执行所有的初始化语句和初始化块 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体 执行构造器主体 内部类在一个类的内部还可以定义内部类，内部类又分为静态内部类和非静态内部类： 非静态内部类非静态内部类可以访问外部类的私有属性。非静态内部类实例必须依赖于外部类实例而存在，语法为：new outerclass().new innerclass()。12345678910111213141516public class LinkList&lt;Item&gt;&#123; private Node first; private Node last; private int N; class Node &#123; private Node next; private Item item; &#125; public void add(Item item) &#123;...&#125; ...&#125; 静态内部类关键字static修饰的内部类为静态内部类，可以没有外部类实例。语法为；new outerclass.innerclass() 静态内部类不可以访问外部类的私有属性和方法，可以访问外部类私有静态成员:1234567891011121314151617181920public class Hero&#123; private int hp; public String name; public static void BattleWin() &#123; System.out.println("战斗胜利！"); &#125; static class BreakTower &#123; int hp = 50000; if (hp &lt;= 0)&#123; Hero.BattleWin(); // 静态内部类无法访问外部类实例属性。方法 System.out.println(name + "胜利！") &#125; &#125;&#125; 类之间的关系最常见的关系有： 依赖(deependence)。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。应尽可能减少将相互依赖的类，如果类A不依赖于B，那么B的任何改变对A没有影响。这称为让类之间的耦合度最小 聚合(aggregation)。意味着一个类的对象包含另一个类的对象。如订单类对象包含商品类对象 继承(inheritance)。继承是对象的一种扩展，子类拥有父类的全部方法和属性 Object类Object类时Java中所有类的始祖，Java中每个类都是由它扩展而来的。如果没有明确指出超类，Object类就是这个类的超类。 可以使用Object类型的变量引用任何类型的变量：1Object obj = new Employee("David", 4500); 不过，Object类型变量只是各种值的持有者，想要对其中的内容进行操作需要进行类型转换：1Employee e = (Employee) obj; 所有数组，不管是基本类型数组还是对象数组，都扩展了Object类：1234Object obj;Emplpyee[] staff = new Employee[3];obj = staff; // OKobj = new int[10]; // OK equals方法Object类中的equals方法用于检测一个对象是否等于另一个对象。两个对象是否相等是通过所属类及实例域状态决定的。12345678910111213141516171819202122public class Employee&#123; ... public boolean equals(Object otherObject) &#123; // 检查两个类是否引用同一个对象 if (this == otherObject) return true; // 如果形参为null返回false if (otherObject == null) return false; // 如果两个类所属类不相等，返回false if (getClass() != otherObject.getClass()) return false; // 想在我们知道otherObject是一个Employee类 Employee other = (Employee) otherObject; // 检查实例域是否相等 return Objects.equals(this.name, other.name) &amp;&amp; this.salary == other.salary // 可以使用this.name.equals(other.name)，为了防止this.name为null最好使用Objects.equals() &#125;&#125; 在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域相等，就需要比较子类中的域：12345678910111213public class Manager extends Employee&#123; ... @Override public boolean equals(Object otherObject) &#123; // super.equals检测otherObject与超类是否相等 if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; // 比较子类中的域 return this.bonus == other.bonus; &#125;&#125; 下面给出编写完美equals方法的步骤： 显示参数命名为otherObject，稍后将它转化成一个叫做other的变量 检测this与otherObject是否引用同一个对象： 1if (this == otherObject) return true； 检测otherObject是否为null 1if (otherObject == null) return false; 比较this与otherObject是否属于同一个类 1if (getClass() != otherObject.getClass()) return false; 将otherObject转化为相应类型变量 1ClassName other = (ClassName) otherObject 比较实例域，用==比较基本类型域，Objects.equals()比较对象域(对于数组类型的域使用Arrays.equals方法判断是否相等) 1234return field1 == other.field1 &amp;&amp; Objects.equals(this.field2, other.field2) &amp;&amp; Arrays.equals(this.field3, other.field3) &amp;&amp; ... hashCode方法Object中的hashCode返回由对象导出的整型值。在定义类时如果没有覆盖hashCode方法，会根据对象的内存地址产生一个散列码。如果定义了hashCode，则由对象内容导出一个散列码。 获得一个对象的散列码可以用Objects.hashCode方法，获得基本类型的散列码可以打包后调用hashCode方法：1Double.hashCode(10) toString方法Object类的toString方法返回表示对象值的字符串。一般表示形式为类名[域值]:1java.awt.Point[x=10,y=10] 当对象与字符串通过+操作符连接起来，Java编译器就会自动地调用toString方法：12Point p = new Point(10, 20);String message = "当前位置为" + p; 如果x是一个对象，调用System.out.println(x)，println方法会自动调用x.toString()。Object类定义了toString方法用来打印对象所属的类名和散列码：1System.out.println(System.out) // 输入java.io.PrintStream@2f6684 这是因为PrintStream类没有覆盖toString方法。数组继承了这一特性，打印数组中的元素使用Arrays.toString方法 接口接口（interface）主要用来描述类具有什么功能，而不给出每个功能的具体实现。这种做法有利于实现类的扩展，因为Java不支持多继承。接口还在有利于多态，因为虽然接口无法构造对象，却能声明接口的变量，且这个变量能引用所有实现了该接口的类对象。 构造一个接口构造接口与构造类相似，只是将class改为interface，此外，还可以将接口定义为泛型，接受类型参数，这样会提高接口的可用性：123456789public interface Compareable&#123; int compareTo(Object other);&#125;public interface Compareable&lt;T&gt;&#123; int compareTo(T other);&#125; 接口内声明了一些方法，绝不应含有实例域，而实现方法和提供实例域的任务都由实现接口的那个类完成。接口中的方法自动是public，在类中定义这些方法时也应使用public 实现接口为了让类实现接口，有两个步骤： 让类声明为实现给定的接口 对接口中所有方法进行定义 将类声明为实现某些接口，使用关键字implement:123456789101112131415161718class Employee implement Compareable&#123; ... public int compareTo(Object otherObject) &#123; Employee other = (Employee) otherObject; return Double.compare(salary, other.salary); &#125;&#125;class Employee implement Compareable&lt;Employee&gt;&#123; ... public int compareTo(Employee other) &#123; return Double.compare(salary, other.salary); &#125;&#125; 接口也可以继承，子接口有父接口中声明的方法和常量：123456789public interface Moveable&#123; int time();&#125;public interface runable extends Moveable&#123; double speed(); // 实现runable的类必须实现time()和speed()方法&#125; 接口的默认方法用default关键字可以在接口中声明方法时进行简单的定义，但不能涉及实例域因为接口没有实例：1234567public interface MouseListener&#123; default void mouseClcked(MouseEvent event) &#123; System.out.println("鼠标点击"); &#125;&#125; 如此一来，实现这个接口的类可以不覆盖这个默认方法而具有默认方法提供的功能。 默认方法冲突 如果接口的默认方法名与超类的方法名冲突了，遵循超类优先原则，即接口提供的默认方法会被忽略。 如果多个接口提供的默认方法名冲突，由类决定使用哪个接口的默认方法： 12345678910// Person和Named都有默认方法getName()class Student implement Person, Named&#123; ... public String getName() &#123; return Person.super.getName(); &#125;&#125; 如果多个接口都没有提供默认方法，那么要么在类中覆盖这个方法，要么这是一个抽象类，把这个方法定义为抽象方法由子类去实现 接口Comparable与ComparatorComparable接口Comparable接口是函数式接口，此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数：123456package java.lang;import java.util.*;public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 一个类若实现了Comparable接口，意味着这个类支持排序。实现了Comparable接口的类的对象的数组或列表可以使用Arrays.sort或Collections.sort进行自动排序。 Comparator接口实现了Comparator接口的类是一个比较器。对某些没有实现Comparable接口的类进行排序，只要提供一个比较器告诉排序方法按照什么规则进行排序就可以了，该接口的定义为：123456package java.util;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj); &#125; 实现Comparator接口的类一定要实现compare方法，而不一定要实现equals方法。int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。 二者的区别Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。（二者的使用实例见：参考博客）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>读书体会</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOP、装饰器、GIL]]></title>
    <url>%2F2018%2F06%2F10%2FOOP%E3%80%81Python%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81GIL%E4%B8%8Erequirements%2F</url>
    <content type="text"><![CDATA[面向对象编程（OOP）方法与函数面向对象编程思想中，方法是指一个对象可以使用的函数，举个例子 12arr = [1,2,3]arr.remove(2) arr被定义为指向列表对象的变量，而remove则是list对象的一个方法，用于从列表中删除某个值。而函数则是对对象进行操作，例如 12arr = [1,2,3]len(arr) len()函数对其参数求长度。在本例中len()的参数既是一个列表。 一切皆对象python一个很出名的特性是一切皆对象。比如变量，类，甚至函数也可以作为一个对象传给变量。比如： 12345678910def plus(x,y): return x+yplus(1,3)from threading import Threatif __name__ == '__main__': t = Threat(target=plus,args=(1,3,)) t.start() t.join() 第八行的target参数传入的是plus函数的对象，此时不需要括号。而第三行的plus()加了括号是告诉python解释器执行这个函数对象。 装饰器当我们想要为某个函数临时添加某个功能时，装饰器能很好地完成这项工作。 装饰器其实就是在函数里定义函数：将目标函数对象传入装饰器里，装饰器内部的函数做一些事情，然后再执行目标函数。 1234567891011121314def decorator(func): def wrapper(*args, **kwargs): print('hello') return func(*args, **kwargs) return wrapper@decoratordef test(text): print(text)test('这是关于装饰器的测试')# 输出：# hello# 这是关于装饰器的测试 这里的 @ 是 python 的语法糖，作用相当于 test = decorator(test) ，即把目标函数对象传入装饰器中。由于decorator返回的是函数对象wrapper，原来的 test 便转而指向了 wrapper 。当我们调用 test 时，实际上是调用了 wrapper 。 多层装饰器（装饰器传参）有时我们需要给装饰器传参，这就麻烦一点，需要多定义层函数： 123456789101112131415161718def log(context='hello'): def decorator(func): def warpper(*args, **kwargs): print(context) return func(*args, **kwargs) # 依次返回函数对象 return warpper # 依次返回函数对象 return decorator@log(context='hi')def test(text): print(text)test('这是关于装饰器的测试')# 输出：# hi# 这是关于装饰器的测试 这里要注意，由于此时的装饰器 log 有默认参数，所以必须以 @log() 的形式进行装饰。如果还是用 @log ，相当于 test = log(test) ，这就把 test 赋给了 context 而 decorator 缺少位置参数 func。用 @log() 则使test指向 decorator ，即实际上是这样的： 1test = log(context="hi")(test) 常用的内置装饰器python 带了很多装饰器可以对函数进行扩展。 @property@property装饰器可以把类的方法变成属性。例如 1234567class Student(): def __init__(self,score): self.score = score#调用Student类qiuyue = Student(90)print(qiuyue.score) #输出结果90 可是这样也不无问题，比如当输入分数不合理（如1000）时，无法对分数进行检查。当然，可以对Student类附加方法实现检查分数。 123456789101112131415class Student(): def get_score(self): return self._score def set_score(self,value): if not isinstance(score,int): raise ValueError('score must is an integer!') if value &gt; 100 or value &lt; 0: raise ValueError('score must between 0 to 100!') self._score = value#调用Student类qiuyue = Student()qiuyue.set_score(90)print(qiuyue.get_score()) #输出90 通过set方法对Student的score属性赋值，再用get方法获取score属性。这样就可以实现对score合法性的检查。但是为了一个属性特地写两个方法未免过于繁琐。所以用到装饰器@property封装set方法和get方法，实现对score属性赋值的同时进行数值合法性检查。 12345678910111213141516171819202122232425262728293031class Student(): @property def score(self) return self._score @score.setter def score(self,value) if not isinstance(value,int): raise ValueError('score must is an integer!') if value &gt; 100 or value &lt; 0: raise ValueError('score must between 0 to 100!') self._score = value @property def grade(self): if self._score is None: return None elif self._score &gt;= 90: print('优秀！') elif self._score &gt;=60: print('及格！) else: print('不及格！')#调用Student类qiuyue = Student()qiuyue.score = 90print(qiuyue.score) # 输出90qiuyue.score = 1000 # 报错，ValueErrorqiuyue.grade = '及格' # 报错qiuyue.grade # 输出优秀 可以看到，@property 装饰的第一个 score()，实际上是一个 get 方法，而`@score.setter装饰的第二个 score 实际上是 set 方法。@score.setter是@property的副产品。这两个装饰器一个装饰 get 方法，一个装饰 set 方法，这样就使 score 方法变成了 Student 类的属性，在对 score 属性赋值（即set）时会自动对值的合法性进行检查，调用 score 属性即调用 get 方法。@score.setter并不是必须的，当缺少@grade.setter` 装饰器时 score 属性变成只读属性，无法对其进行赋值，只能读取。 @classmethod与@staticmethod在介绍类方法@classmethod与静态方法staticmethod前，先要清楚一个概念：类属性与实例属性是不同的。 12345678910class Plus(): num = 1 def __init__(self): self.num = 1f = Plus()f.num = 2print(Plus.num) # 结果为1print(f.num) # 结果为2 众所周知，要调用类的方法，我们首先要把这个类实例化，然后通过实例名.方法名的方式调用。而@classmethod与@staticmethod都可以实现通过类名.方法名的方式调用方法。 @classmethod当类中有些方法不需要涉及实例，而需要涉及类，如对类属性的修改，往往使用@classmethod。用@classmethod修饰的方法不会将实例传入方法中，而会自动将自身类作为第一个参数传入。所以这个方法不需要写self参数，但需要一个cls参数代表这个类。 1234567class Apple(): species = '富士苹果' @classmethod def clsmed(cls): print('苹果的种类为：%s' % cls.species)Apple.clsmed() # 输出：苹果的种类为：富士苹果 @staticmethod如果类中有些方法既不涉及类，也不涉及实例，可以用@staticmethod。@staticmethod既不会将实例传入方法，也不会将自身类传入方法。所以既没有self参数也没有cls参数。一般在这两种情况下适合用 @staticmethod： 一个方法不需要访问对象状态，其所需要的参数都是通过显示参数提供 一个方法只需要访问类的静态域 1234567891011121314class Apple(): apple = 1 def change(self,data): self.apple = data print('还有%s个苹果' % self.apple) @staticmethod def stamed(): # 不需要访问实例对象 print('没有苹果了')apple = Apple()apple.change(2) # 输出：还有2个苹果Apple.stamed() # 输出： 没有苹果了 下面这个例子加深区分： 1234567891011121314151617181920class Apple(): species = '富士苹果' def __init__(self,data): self.num = data def common(self): print('还有%s个苹果' % self.num) @classmethod def clsmed(cls): print('苹果的种类为：%s' % cls.num) @staticmethod def stamed(): print('没有苹果了')apple = Apple(2)apple.common() # 输出：还有2个苹果Apple.clsmed() # 输出：苹果的种类为：富士苹果Apple.stamed() # 输出：没有苹果了 @wraps(func)函数的 __name__ 方法可以取出函数名，看一个装饰器的例子： 123456789101112def decorator(func): def wrapper(*args, **kwargs): print('hello') return func(*args, **kwargs) return wrapper@decoratordef test(): print('hi')print(test.__name__)# 输出：wrapper 可以看到，test 的 __name__ 属性被改变了，因为返回的那个 wrapper() 函数名字就是wrapper，所以，需要把原始函数的 __name__ 等属性复制到 wrapper() 函数中，否则，有些依赖函数签名的代码执行就会出错。用 functools.wraps 可以解决这个问题： 1234567891011121314from functools import wrapsdef decorator(func): @wraps(func) def wrapper(*args, **kwargs): print('hello') return func(*args, **kwargs) return wrapper@decoratordef test(): print('hi')print(test.__name__)# 输出： test Python的特点像java，C#这种编译型语言，会将代码编译成二进制再运行。而python作为一种解释型语言，是动态的逐行解释代码的，也就是从脚本第一行开始，没有统一的入口。一个Python源码文件除了可以被直接执行外，还可以作为模块（也就是库）被其他.py文件导入。此时这个源码文件的文件名（不包括.py）就是库名。python本身有很多有趣的方法，会在每一个python文件里自动生成，在特殊情况下还会自动调用，这种方法称之为魔法方法。魔法方法的形式为两个下划线(__)+方法名+两个下划线(__)。如：__new__。下面介绍一些常见的魔法方法。 __file__通过下面一行代码，就能很直接地看出__file__的作用。 123# 文件位置为E:/python/test.pyprint(__file__)# 输出E:/python/test.py 可见，__file__代表了当前python文件的路径。而且如前面所言，这个方法是python自动实现的，不需要你去编写。 __name__相信不少python初学者都见到过这样一段代码： 12if __name__ == "__main__": app.run() 可能很多人第一次看到这段代码的时候都会困惑：这个__main__我理解，是主函数的意思，可是这__name__是个什么东东？老规矩，上一段代码: 123# 文件位置为E:/python/test.pyprint(__name__)# 输出__main__ java，C等语言都会显示地定义一个main()函数，一个用C编写的程序都是以main()作为程序入口的。而python不同，哪个文件被直接执行，哪个文件的模块名就是__main__。现在说回__name__, __name__存放的就是当前python文件的名字，那么现在情况就很明显了，开头那段代码的意思是：如果这个文件是被直接运行的，就执行app.run()，如果这个文件是被别的文件导入后运行的，就会跳过app.run()。这样做的好处是避免了一些只能在主程序里执行的代码由于被导入了其他文件而错误执行。 GILGIL 全称Global Interpreter Lock。这里要指出，GIL 不是 Python 的锅，而是使用最为广泛的 Python解释器 CPython 的设计失误。最初在单核 CPU 时代为了保证多线程安全性，设计者采用了最为简单直接的方法：加锁，执行代码时，有一个 GIL 锁，任何 Python 线程执行前，必须先获得 GIL 锁。单核时代这样做没问题，可是随着多核 CPU 的普及，这样的做法妨碍了线程在多核上的执行。举个例子：核A 执行 线程1 ，核B 空闲，本来操作系统可以把 线程2 调到 核B 进行运算，由于 GIL 的存在，线程2 不得不等 线程1 释放 GIL 后再尝试获得 GIL 进行计算（即使如此，也很可能因为 线程1 优先级高再次获得 GIL 导致 线程2 迟迟无法进入运行状态，浪费了计算资源）。 当然，现在 Python 社区对 GIL 进行了很多优化，比如在 I/O 时释放 GIL、每执行 100 条字节码，自动释放 GIL…… 总而言之，在特定时刻，一个进程里只有一个 Python 线程被执行。这个GIL 实际上把所有线程的执行代码都给上了锁，所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核CPU上，也只能用到 1 个核。 GIL 的存在导致python不能很好地利用多核性能，但是可以通过多进程实现多任务。不同进程之间的 GIL 互不影响。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python合并列表、格式化输出与代码思路]]></title>
    <url>%2F2018%2F06%2F10%2FPython%E5%90%88%E5%B9%B6%E5%88%97%E8%A1%A8%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[合并Python提供了很多合并的方法： 12345678910111213141516171819202122232425"""合并两个列表"""l1 = ['a', 'b', 'c']l2 = ['d', 'f', 'g']# + 操作，不会改变原来的列表l3 = l1 + l2 # ['a', 'b', 'c', 'd', 'f', 'g']# extend()方法l2.extend(l1) # l2变成['d', 'f', 'g', 'a', 'b', 'c']，l1不变# ** 操作,不会改变原来的列表l3 = [**l2, **l1] # ['d', 'f', 'g', 'a', 'b', 'c']"""合并两个字典"""d1 = &#123;'a': 1, 'b':2&#125;d2 = &#123;'d': 3, 'g': 4&#125;# ** 操作d3 = &#123;**d2, **d1&#125; # &#123;'a': 1, 'd': 3, 'b': 2, 'g': 4&#125;, 如果有重复键，则以第一个参数为准# update()方法d1.update(d2) # d1变成&#123;'d': 3, 'b': 2, 'a': 1, 'g': 4&#125;，d2不变# * 操作，取两字典key值的集合d3 = &#123;*d2, *d1&#125; # &#123;'d', 'a', 'b', 'g'&#125; 封装协议常常可以看到封装协议这个词，比如smtplib.SMTP类就封装了smtp协议，Flask-httpauth.HTTPBasicAuth类封装了http协议。 所谓某个包封装了某个协议的意思是包为这个协议提供了一系列接口，使用者只需要调用这些接口就会自动实现这些协议,这样我们就不用自己再去造轮子了。 下面这段代码就是一个例子，我们调用SMTP类的connect()方法连接QQ邮箱服务器，starttls()方法实现smtp协议的tls连接，login()方法实现与服务器连接。 1234567from smtplib import SMTPsmtp = SMTP()smtp.connect(host='smtp.qq.com', port=587)smtp.ehlo()smtp.starttls()smtp.ehlo()smtp.login('xxxxx@qq.com', 'passwd') 可以看到，我们只是调用了一系列接口就自动遵循smtp协议与QQ邮箱服务器连接上了，至于方法内部是如何实现的我们并不需要了解。 字符串拼接用join()方法可以把字符串插入到迭代对象中。相当于split()的逆操作： 123&gt;&gt;&gt; l = ['hello', ' ', 'world']&gt;&gt;&gt; ''.join(l) # 'hello world'&gt;&gt;&gt; '-'.join(l) # hello- - world 编写分支条件提前结束最常见的分支条件当然就是if...else...这种格式了。当时当代码中有多层if嵌套时会大大降低可读性。这是可以用提前结束来减少if的使用： 12345678910111213141516171819202122232425262728293031323334def buy_fruit(nerd, store): """去水果店买苹果 - 先得看看店是不是在营业 - 如果有苹果的话，就买 1 个 - 如果钱不够，就回家取钱再来 """ if store.is_open(): if store.has_stocks("apple"): if nerd.can_afford(store.price("apple", amount=1)): nerd.buy(store, "apple", amount=1) return else: nerd.go_home_and_get_money() return buy_fruit(nerd, store) else: raise MadAtNoFruit("no apple in store!") else: raise MadAtNoFruit("store is closed!")# 使用“提前结束”def buy_fruit(nerd, store): if not store.is_open(): raise MadAtNoFruit("store is closed!") if not store.has_stocks("apple"): raise MadAtNoFruit("no apple in store!") if nerd.can_afford(store.price("apple", amount=1)): nerd.buy(store, "apple", amount=1) return else: nerd.go_home_and_get_money() return buy_fruit(nerd, store) 封装复杂逻辑一个判断中如果有多个逻辑条件并列容易使人发晕。一个明智的做法是把这些条件封装起来： 1234567891011# 如果活动还在开放，并且活动剩余名额大于 10，为所有性别为女性，或者级别大于 3# 的活跃用户发放 10000 个金币if activity.is_active and activity.remaining &gt; 10 and \ user.is_active and (user.sex == 'female' or user.level &gt; 3): user.add_coins(10000) return## 封装逻辑if activity.is_active and user.match_activity_condition(): user.add_coins(10000) return 多用肯定在做逻辑判断时，常会使用下面的代码： 123# 如果用户没有登录或者用户没有使用 chrome，拒绝提供服务if not user.has_logged_in or not user.is_from_chrome: return "our service is only available for chrome logged in user" 人类不擅长处理否定逻辑和或逻辑，所以最好多用肯定与且： 12if not (user.has_logged_in and user.is_from_chrome): return "our service is only available for chrome logged in user" 使用all()和any()all(seq)当sqe全为True时返回True，否则返回False。any(seq)只要seq中任何一个True就返回 True，否则返回False 1234567891011121314def all_numbers_gt_10(numbers): """仅当序列中所有数字大于 10 时，返回 True """ if not numbers: return False for n in numbers: if n &lt;= 10: return False return True# 使用all()def all_numbers_gt_10_2(numbers): return bool(numbers) and all(n &gt; 10 for n in numbers) 索引迭代通常我们想要找出迭代对象中某个值的索引，比如找出列表中第一个重复字符的索引，我们会这样做： 123456789l = ['a', 'b', 'c', 'a', 'b']visited = dict()def find(l): for i in range(len(l)): if l[i] in visited.keys(): return i visited[l[i]] = 1 return None 这种方法虽然可行，但是未免太蠢了。又是range()又是len()的，一点不简洁。enumerate()可以把一个迭代对象变成索引-元素树。（enumerate： 枚举，列举） 123456789l = ['a', 'b', 'c', 'c', 'b']visited = &#123;&#125;def find(l): for i, v in enumerate(l): if v in visited.keys(): return i visited[v] = 1 return None 这样就变得干净清爽多了。 对数值做格式化输出用format()方法可以实现字符串格式化。 1'hello &#123;&#125;'.format('Mike') # 'hello Mike' 除此之外，format()还有很多有趣的用法： 格式限定符为了限定输出格式，需要在{}里加上: 填充与对齐&gt;、&lt;、^表示右对齐，左对齐，居中。后面带宽度 :后面带填充的字符。默认是空格 1234'there are &#123;:&gt;3&#125; apples in here'.format(5) # 'there are 5 apples in here''there are &#123;:&lt;3&#125; apples in here'.format(5) # 'there are 5 apples in here''there are &#123;:^3&#125; apples in here'.format(5) # 'there are 5 apples in here''there are &#123;:0&gt;3&#125; apples in here'.format(5) # 'there are 005 apples in here' 控制精度输出浮点数时常常要控制精度： 1'圆周率约等于&#123;:.2f&#125;'.format(3.1415926) # '圆周率约等于3.14' 其中2表示保留到小数点后两位，遵循4舍5入原则。f表示数据是浮点数。 也可以控制整体的位数： 12'圆周率约等于&#123;:.2&#125;'.format(3.1415926) # '圆周率约等于3.1''圆周率约等于&#123;:.4&#125;'.format(3.1415926) # '圆周率约等于3.142' 除了format()之外，还可以用传统的占位符对输出进行格式化： 123'圆周率约等于%.2f' % (3.1415) # '圆周率约等于3.14''圆周率约等于%8.2f' % (3.141) # '圆周率约等于 3.14''圆周率约等于%08.2f' % (3.141) # '圆周率约等于00003.14']]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络那些事之应用层]]></title>
    <url>%2F2018%2F06%2F07%2F%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络应用结构 客户机/服务器结构（C/S） 点对点结构（P2P） 混合结构（综合 C/S 与 P2P） 应用层是程序员最常接触的层次，应当非常熟悉。 端系统间的进程通信一个进程可以理解为运行在端系统中的的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。而在不同的端系统上，通过跨越计算机网络交换报文实现进程间的通信。 多数应用程序由通信进程对组成，每对中的两个进程互相发送报文，从一个进程向另一个进程发送报文就必须经过下面的计算机网络。进程通过一个被称为套接字的软件接口向网络发送报文和接受报文。套接字类似于一栋屋子的门，无论是要进入屋子还是离开屋子，都要进过门。套接字是应用层与运输层的接口。在运输层，开发者对于套接字几乎没有控制权，只能 选择运输层协议 设定几个参数，如最大缓存、最大报文段长度等 套接字（Socket）套接字是一种应用编程接口（API），不同主机的应用进程间通信的抽象机制。应用进程通过套接字将数据控制权转移给操作系统，以实现信息从应用层到传输层的转换。 端口号每个应用进程都可能对应一个或多个套接字。为了区分不同套接字，操作系统给每个套接字绑定一个 16 位整数（0——65535），称之为端口号（port）。 对外标识通信端点：IP Address + port。 进程寻址为了与另一个端系统通信，必须知道： 另一端系统的地址 定义在目的端系统中的接收进程的标志符 端系统地址由IP地址确定，而接收进程标志符由端口确定。 操作系统对内标识套接字：套接字描述符（socket descriptor），非常类似于文件的抽象机制。每个进程有一个套接字描述符表，进程每创建一个套接字都会在表里增加一个条目，每个条目对应一个套接字数据结构指针。 地址族（family）：不同传输协议下主机的端点形式不同，用地址族区分不同的传输协议。 类型（service）：区分某一传输协议下的不同协议。 几种常见的应用层协议HTTPHTTP（超文本传输协议）是 Web 的核心。在 Web 应用中，客户与服务器之间是通过 HTTP 报文进行会话的。而HTTP协议定义了报文格式与交换方式。Web 服务器实现了 HTTP 的服务器端，用于存储 Web 对象，每个对象由 url 寻址。 HTTP 使用TCP作为它的支撑运输协议，默认采用带流水机制的持久性连接。 一次完整的请求——响应流程是这样的： HTTP客户端首先发起一个与服务器的 TCP 连接，一旦连接建立，该客户端进程与服务器进程就可以通过套接字接口通信。 客户端向它的套接字接口发送 HTTP 请求报文。 服务器收到 HTTP 请求报文并生成相应的响应报文，通过服务器的套接字发送响应报文。 客户端从套接字接受响应报文。 所有报文传输结束，关闭 TCP 连接。 CookieHTTP 是无状态协议，不记录客户端的历史行为，换言之对服务器而言每个 HTTP 请求都是独立的，不和历史请求有任何关系。为了辨别用户身份，维持 session，cookie 应运而生，它是一小段储存在客户端且通常经过加密的数据。 Cookie 在 HTTP 协议中以头部行的形式传输，由服务器设置，被客户端（通常是浏览器）保存在本地。 SMTP通过 SMTP（简单邮件传输协议）实现发送邮件。因特网电子邮件系统由 3 部分组成： 用户代理。常见的邮件客户端如 Outlook 等都是用户代理，如果是通过 Web 端发送邮件，那么浏览器是用户代理。用户代理负责读写邮件、与邮件服务器交互 邮件服务器。通常由企业提供，如 QQ 邮箱的服务器smtp.qq.com，126 邮箱服务器smtp.126.com SMTP。负责在邮件服务器之间发送邮件 一个典型的发送邮件的过程是： 从发送方的用户代理开始，传输到发送方的邮件服务器 从发送方的邮件服务器发到接收方的邮件服务器，然后被分发到接收方的邮箱中 接收方通过用户代理从邮箱获取邮件 SMTP 是因特网电子协议中的主要应用层协议，它用 TCP 提供可靠数据传输服务。 SMTP 规定邮件报文首部必须包含关键字From:与To:，可以包含关键字Subject:。 DNS如果把客户向服务器发送报文比作打电话，那么服务器的IP地址是电话号码，域名是号码主人的姓名，而 DNS（Domain Name System 域名系统）就是电话簿，把姓名和电话号码联系起来。 DNS是： 一个由分层的DNS服务器实现的分布式数据库 一个使主机能够查询分布式数据库的应用层协议 DNS提供的服务有： 域名解析服务 主机别名服务 邮件服务器别名服务 负载均衡。将一个域名与多个IP地址对应起来，当客户对域名发出一个DNS请求时，每次响应都循环这些IP地址的次序。由于客户总是向排在最前面的IP地址发送HTTP请求，由此实现了负载均衡。 获得一个域名的 IP 地址的过程如下： 浏览器把域名发送到用户主机上的DNS客户端 DNS 客户端向 DNS 服务器发送一个包含主机名的请求 DNS 服务器通过查询相应的域名——&gt; I 地址间的映射关系，生成一个响应报文并返回 DNS 客户端收到响应报文，把报文中的IP地址传给浏览器 实质多层命名服务器构成的分布式数据库。属于应用层协议，负责域名解析功能。 分层式层次式数据库第一层：根域名服务器（root） 第二层：顶级域名服务器（top-level domain，TLD），负责 com，org，cn，jp 等 第三层：权威域名服务器（authoritative），负责组织域名解析，如 alibaba，baidu 等 举个例子：客户端访问 www.baidu.com。 向根域名服务器发送查询请求。根域名服务器返回 com 域名服务器地址。 向 com 域名服务器发送查询请求。com 域名服务器返回 baidu.com 域名服务器地址。 向 baidu.com 域名服务器发送查询请求。baidu.com 域名服务器返回 wwww.baidu.com 地址。 本地域名服务器： 不严格属于层级体系，每个 ISP 有一个本地域名服务器，是该 ISP 用户的默认域名解析服务器。作为代理将该 ISP 用户的查询转发给域名解析服务器系统。 为什么不用采用集中式架构 单点失败问题 流量问题 距离问题 维护性问题 不可伸缩！ DNS 查询方式 迭代查询。用户的查询被转发到本地域名服务器上，本地域名服务器依次访问 3 层域名解析服务器系统。 递归查询。用户的查询被转发到本地域名服务器上，本地域名服务器访问根域名服务器，根域名服务器访问顶级域名服务器，顶级域名服务器访问权威域名服务器。最后的查询结果依次返回给上一层。 DNS 缓存与更新一段时间后，缓存条目会失效。本地域名服务器一般会缓存顶级域名服务器地址，所以根域名服务器较少被访问。 DNS 记录与格式DNS 记录又称资源记录（RR，Resource Record）。是一个四元组：（name，value，type，ttl）。 type=A：name=主机域名，value=IP 地址。 type=NS：name=域（edu.cn、qiuyueqy.com），value=该域的权威域名解析服务器的主机域名。 type=CNAME：name=某真实域名的别名，value=真实域名。 type=MX：name=域（126.com，163.com）,value=与name对应的邮件服务器. 为什么在应用层实现我们希望把复杂的东西尽量放在端系统实现。在应用层实现 DNS 协议有利于降低网络核心的复杂度。 DNS缓存由上可知，为了获取一个DNS地址进行了很多次请求，这就影响了速度。为了加快响应速度，DNS服务器有缓存机制：在一个请求链中，当某DNS服务器接收到一个DNS回答，它能将该回答中的信息缓存到本地存储器中，类似于Web缓存器。在一段时间（默认为两天）后将缓存信息丢弃。 DNS劫持与污染DNS 污染是指服务器检测到用户访问特定的主机时，伪装成 DNS 服务器向用户返回错误IP地址。国内用户访问 youtube 等网站时就会遇到这种情况 DNS 劫持是通过劫持特定的DNS服务器，在 DNS 服务器里存放错误的缓存信息，这样 DNS 服务器就会向用户返回错误的 IP 地址 对于 DNS 劫持，可用采用更换默认 DNS 服务器的方式解决。而 DNS 污染只能通过修改 hosts 文件、VPN 等方式绕过服务器 P2PP2P（Peer to Peer）应用的几个特点： 没有服务器 任意端系统之间直接互联 节点阶段性接入Intent 节点可能更换IP地址 网关(gateway)在一个局域网内互相通信是不需要用到网关的，而局域网内的接口要访问外网时，则需要把请求发送到网关上，由网关负责向外发送流量。同理，外网的信息也是通过网关再传达给内网接口]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络那些事——基本概念]]></title>
    <url>%2F2018%2F06%2F04%2F%E7%BD%91%E7%BB%9C%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[计算机网络是一个自治的、互联的计算机集合。 因特网因特网是一个世界范围的计算机网络，是“网络的网络”。由十多个第一层ISP(因特网服务提供商)和数十万个底层 ISP 组成。ISP 覆盖区域有所不同，有些跨越多个大洲和大洋，有些限于很小的地理区域。低层 ISP 与高层 ISP 互联，高层ISP彼此互联。 端系统所有连接到因特网的设备都称为主机或端系统。 端系统通过通信链路和分组交换机连接到一起。通俗的讲通信链路就是一条条光缆、网线等物理线路，不同的链路能以不同的速率传输数据，链路的传输速率单位为bit/s或bps，即比特/秒。端系统通过 ISP 接入因特网。 当一台端系统向另一台端系统发送数据时，发送端系统将数据将数据分段，并为每段加上首部字节。由此形成的信息包称为分组。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。目前最出名的两种分组交换机类型是路由器和链路层交换机。这两种类型的交换机朝着最终的目的地转发分组。链路层交换机常用于接入网中，而路由器常用于网络核心中。从发送端到接收端，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。 与因特网相连的端系统提供了应用程序编程接口(API),该API规定了运行在一个端系统上的软件请求因特网基础设施向运行在另一个端系统上的特定目的地软件交付数据的方式。因特网API是一套发送软件必须遵循的规则集合。类似于我们在寄信的时候需要遵邮局的规定贴上邮票、写上邮政编码等，这些规定就是 API。 网络边缘常把与因特网相连的设备称为端系统，因为它们位于网络的边缘。将端系统连接到其边缘路由器的物理链路称为接入网。边缘路由器是端系统到任何其他远程系统的路径上的第一台路由器。除了端系统外，网络应用也处于网络边缘。网络应用通常有两种结构： 客户——服务器结构（Client-Server）。常见的 Web 应用都是这种结构。这种应用的特点是客户只与服务器进行交互，只有客户可以主动发起连接。客户与客户之间是互不可见的 P2P 结构（点对点结构）。这种结构是对等的，不存在客户和服务器的概念。各个端点之间可以直接互相访问。例子有文件共享服务如bt下载，所以才会有越多人下载速度越快的说法 家庭接入当前宽带住宅接入有两种流行类型： 数字用户线(Digital Subscriber Line，DSL)。即常说的拨号上网。利用DSL调制解调器将到达家庭的数据信号和电话信号分隔开（ADSL是非对称接入，即上行与下行速率是不同的，通常下行更快） 电缆（HFC,混合光纤同轴电缆网）。通过有线电视网络进行传输，用cable modem（即“猫”）将电视信号与网络信号分开。这也是非对称的，下行通常到30Mbts，上行为2Mbps 光纤到户。本地中心局直接提供了一条光纤线路到家庭。 LAN 无限局域网。在公司、大学和越来越多的家庭环境中，通常是用局域网(LAN)将端系统连接到边缘路由器。尽管有多种不同的局域网技术，但以太网是目前最流行的接入技术。在无线LAN环境中，无线用户从一个接入点发送/接受分租，接入点与企业网连接，该企业网再与有线因特网相连，这就是 wifi。可达 54Mbps 蜂窝网。蜂窝网也属于无线接入。所谓3G网4G网都属于蜂窝网。 网络核心网络核心即互联因特网端系统的分组交换机和链路构成的网状网络。 网络核心的关键功能是路由+转发。路由即确定分组从源到目的地的路径。 存储转发传输多数分组交换机在链路的输入端用存储转发传输机制：交换机能够在开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。由此存在存储转发延时：如果某源端系统或分组交换机经过一条链路发送一个L比特的分组，链路的传输速率为R bit/s，则分组在这条链路上的传输时间为 L/R 秒。 排队延时和丢包每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机有一个输出缓存用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某天链路但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，由此分组又存在排队延时。缓存空间是有限的，一个到达的分组可能发现该缓存已满，此时会发生丢包(分组丢失)：到达的分组或正排队的分组之一会被丢弃。 转发表和路由选择协议在因特网中，每个端系统具有一个被称为IP地址的地址。当源主机要向目的地端系统发送一个分组时，源在该分组的首部包含了目的地的 IP 地址。如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个转发表，用于将目的地址映射为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发行适当的出链路。路由器则将分组导向该出链路。 分组交换时延分组从一个主机出发通过一系列路由器传输，在另一台主机中结束它的历程。这个过程是存在时延的。其中最为重要的几种时延是节点处理时延、排队时延、传输时延、传播时延。这些延时加起来称为节点总时延 节点处理时延（nodal processing delay）。造成这部分时延的原因主要是检查分组首部（差错检测）和决定将该分组导向何处（确定输出链路） 排队时延（queueing delay）。链路繁忙时新到达交换机的分组会进入排队状态。 传输时延（transmission delay）。仅当所有先到达的分组传输完毕后才能传输刚到达的分组。传输时延是将该分组的所有比特推向链路所需要的时间。L 为分组长度，R 为链路带宽，则传输时延为 L/R 传播时延（propagation delay）。分组在链路上传播的时间称为传播时延。d 为链路长度，v 为传播速率，则传播时延为 d/v 传输时延与传播时延不同之处在于传输时延是分组从交换机到链路的时间，与分组的大小有关，与两台路由器之间的距离无关。而传播时延是分组在链接上传播消耗的时间，与分组大小无关，与距离有关。 OSI七层协议每层完成一类特定功能，底层为上层提供服务，相邻的两层通过接口进行交互，任一层实体提供的服务是垂直的。 计算机网络体系结构是计算机网络各层及其协议的集合。协议是控制两个对等实体进行通信的规则的集合，协议是水平的。 中间系统只实现网络层、链路层和物理层，这三层合称“非端到端层(non-end-end)”。 封装数据在每一层都会被打上一个该层的附加信息（所谓运输首部信息），称为 PDU(Protocol Data Unit)。而这些信息会在下一层被使用。 为什么要封装 增加控制信息：地址信息（表示发送、接受端），差错检测编码，优先级设置等 非端到端层物理层 规范接口特性：机械特性（形状，大小）、电气特性（电压、电频），功能特性（引脚）等 比特编码：如何表示 0 和 1 数据率：数据传输速率 传输模式：单工通信（单向），半双工通信（交替单向，发和收不同时），全双工通信（同时收发） 链路层 两个直接相连的结点间的数据帧传输。 物理寻址。在帧头增加收发端物理地址标识信息（通常为 MAC 地址）。 流量控制。匹配发送和接收速度，避免淹没接收端。 差错控制。判断丢失帧与重复帧。 访问控制。决定哪个设备拥有物理链路使用权。 网络层 跨越多个网络的数据分组传输 逻辑寻址，全局唯一（通常为 IP 地址）。 路由：路径选择及分组转发。 网络层地址不变，链路层地址随传输过程不断更新。 端到端层传输层源到目的端进程间报文传输。 报文分段与重组 端口号寻址：确保将报文提交给正确进程。 连接控制：作为自下而上第一个端到端层次，建立或拆除端到端间的逻辑连接。 流量控制 差错控制（如 TCP） 会话层不对数据进行分段，只插入一些信息。 对话控制：建立、维护进程间对话 同步：在数据流中插入同步点，便于恢复对话 表示层处理两个系统间交换信息的语法语义问题（如大小端机器对数据的表示方式不同）。 数据表示转化：发送端把信息转化为主机独立的编码，接收端转化为主机相关编码 加密解密 压缩解压缩 应用层向用户提供网络服务接口（如浏览器），根据不同应用场景处理用户数据。 TCP/IP参考模型 Internet五层协议综合 OSI 与 TCP/IP 应用层。应用层是网络应用程序及他们的应用层协议存留的地方。HTTP、SMTP、FTP、DNS等都属于应用层协议。分组在应用层中称为报文 运输层。进程之间传送报文。在因特网中有两个运输协议TCP和UDP。分组在运输层中称为报文段 网络层。主机之间数据分组与转发。网络层接受运输层递交的报文段和目的地址，类似于寄信时要向邮局提供目标地址。著名的IP协议就在网络层。该协议定义了数据报中的各个字段及端系统和路由器如何作用于这些字段，以达到逻辑寻址的目的。分组在网络层称为数据报 链路层。将网络层的IP数据包组装成帧（帧包含数据和必要的控制信息，例如信道编码，卷积码，turbo码），在相邻网络元素之间传输。 物理层。物理层负责将帧一个比特一个比特地从一个节点移动到下一个节点。进一步与链路实体（如双通铜线、单模光缆）相关。传输数据为比特流，物理层需要定义比特传输的电气特性（多少电压代表1多少代表0）、机械特性（接口形状尺寸等），如USB、Bluetooth等。而传输物理介质如光纤、双绞线等并不处于物理层的范畴 下面是知乎一个有趣的例子： 为了实现跨越互联网的，主机 A 的进程 P1，和主机 B 的进程 P2 之间的通信，我们逐层把这个任务交给 TCP/IP 协议栈。运输层：“如果有人能帮我把数据从某个网络中的机器 A 搬到另一个网络中的机器 B，我就可以搞定这个任务，因为我知道不同的数据应该交给机器上的哪个进程。”网络层：“如果有人能帮我把数据从局域网中直接相连的一台机器搬到另一台机器，我就可以把数据从一个网络搬到另一个网络，因为我知道路线怎么走，要经过哪些节点。”链路层：“我知道怎样在局域网中搬数据，还能用 CSMA/CD 协议协调工作，还能用 CRC32 校验发送的数据和接收的数据是一致的，blabla… But，我只是说说，我不干苦力活。”物理层：“楼上的大爷们发话了，兄弟们上。”]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之备份与恢复]]></title>
    <url>%2F2018%2F06%2F03%2F%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[使用mysqldump命令备份mysqldump命令可以将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。 mysqldump的工作原理就是查出需要备份的数据库和表的结构，然后在文本文件中生成相应的create和insert语句。需要导入数据库文件时mysql通过使用文本文件中记录的语句生成相应的数据库和表就可以了。 使用mysqldump命令进行数据备份时，经常分为以下3种形式： 备份一个数据库 备份多个数据库 备份所有数据库 下面分别介绍： 备份一个数据库1mysqldump -u username -p dbname [table1 table2 ...] &gt; filename dbname 为数据库名。table1、table2 为表名，没有指定 table 时将备份整个数据库。filename为文本文件名称，通常使用.sql作为后缀。 例：备份数据库 users 中的 studnets 表到 D 盘的 sql 文件夹下： 1mysqldump -u root -p users students &gt; D:\sql\students.sql 备份多个数据库1mysqldump -u username -p --databeses dbname1 dbname2 &gt; filename 加上databases选项，后面跟多个数据库名称 例：备份数据库 users、customers 到 D 盘： 1mysqldump -u root -p --databeses users customers &gt; data.sql 备份所有数据库1mysqldump -u root -p --all --databases &gt; filename 数据恢复使用mysql命令进行还原： 1mysql -u root -p [dbname] &lt; filename dbname 表示数据库名称，该参数是可选的。指定数据库名称时，表示还原该数据库下的表，不指定时表示还原数据库。 也可以在进入相应数据库后用source命令恢复： 12mysql&gt; use test;mysql&gt; source filename;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之事务与优化]]></title>
    <url>%2F2018%2F06%2F03%2F%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[事务概述在MySQL中，事务由一条或多条SQL语句组成，在这个事务中，每条MySQL语句是相互依赖的。而整个事务作为一个不可分割的整体，一旦某条MySQL语句执行失败或产生错误，整个事务将会回滚。 只有InnoDB类型的表支持事务。MySQL默认表类型为InnoDB。 事务的基本要素(ACID) 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。 孤立性（Isolation）：每个事务在自己的空间内执行，与其他事务隔离，而且事务的结果只有在它被完全执行时才能看到。这样即使一个系统同时发生多个事物，孤立性也可以保证特定的事务在完成之前其结果不被公布。 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 事务的创建与存在周期创建事务的一般过程是： 1初始化事务 ————&gt; 创建事务 ————&gt; 提交或回滚 无论最后是提交还是回滚，都会关闭这个事务。 初始化事务：start transaction;或begin;，MySQL默认是自动提交的，所以需要用命令改为手动模式 创建事务：执行SQL语句 提交或回滚： 提交commit;，回滚rollback; 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 事务的孤立性等级事务具有孤立的空间，在MySQL服务器中，用户通过不同的会话执行不同的事务，在多用户环境中，许多RDBMS(关系型数据库管理系统)会话在任意时刻都是活动的。为了使这些事务互不影响，保证数据库性能不受影响，采用事务的孤立等级是很重要的。 如果没有孤立性，不同的select会在同一事务的环境中检索到不同的结果，这将导致数据的不一致性。 序列化(serializable)：以序列的形式对事务进行处理。该孤立级的特定是只有当事务提交后，用户才能从数据库上查看数据的变化。。 可重读(repeatale read)：对应于程序的安全性做出部分妥协，以提高性能。事务在孤立级上不会被看成一个序列，不过在当前执行的事务过程中，用户依然看不到事务的过程。直到事务提交为止，用户才能看到事务的变化结果。（客户端A、B同时开启事务，B向表中插入数据行，A在提交事务前是看不到改变的） 读已提交(read committed)：该孤立级的安全性比可重读低。在这一级事务用户可以看到其他事务添加到新纪录。在事务处理时如果存在其他用户同时对事务的相应表进行修改那么在同一事务的不同时间内，select语句可能返回不同的结果(客户端A、B同时开启事务，B向表中插入数据行且提交后，A可以看到改变) 读未提交(read uncommitted)：该孤立级提供事务之间最小程度间隔，该孤立级容易产生幻读。其他用户可以在该孤立级上看到未提交的事务。(客户端A、B同时开启事务，B向表中插入数据行且未提交，A也可以看到改变) 孤立等级 脏读 不可重复读 幻读 序列化 否 否 否 可重读 否 否 是 读已提交 否 是 是 读未提交 是 是 是 修改事务孤立级：1set transaction isolation level ...; 事务的性能应用小事务应用小事务的意义在于保证每个事务不会在执行前等待很长时间，从而避免各个事务因为互相等待而导致系统性能大幅度下降。应尽量缩短insert、update等操作与commit之间的间隔时间。 合适的孤立级事务的性能与其对服务器产生的负载成反比，即事务孤立级越高，其性能越低。例如序列化虽然很稳定，但是会大大影响MySQL的性能，生产中比较少用，而用乐观锁悲观锁解决幻读等问题 死锁当两个或多个处于不同序列的用户打算同时更新某相同数据库时，因互相等待对方释放权限而导致双方一直处于等待状态。两个不同序列的客户端同时对数据执行操作极有可能产生死锁。更通俗地讲，当两个事物相互等待操作对方释放所持有的资源而导致两个事务都无法操作对方持有的资源，这样无限期的等待称为死锁。 InnoDB具有检查死锁的功能。如果发现产生了死锁，InnoDB会立刻撤销其中一个任务以便死锁消失。这样就可以使另一个事务获取对方所占有的资源而执行操作逻辑。 优化数据库 使用索引.对于新表可以先不创建索引，等数据导入后在创建，这样可以提高数据导入效率。一般来说，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况 1alter table users add unique name (username); 尽量少用like语句与通配符% 选取最合适的字段大小表越小，速度越快。所以能用char就不要用varchar，能用mediumint就不用bigint。尽量使用not null这样在查询时数据库不用去比较null值。 用join代替子查询,这样MySQL不需要在内存中创建临时表来完成逻辑上的需要两个步骤的查询工作。。 优化insert语句。一次插入多条数据比每次插入一条数据快。能用union将多条select结合就不要单独用多次select 使用事务。我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。这时候就要用到事务。 1234BEGIN; INSERT INTO user VALUES (NULL, 'Mike'); UPDATE inventory SET Quantity=11 WHERE item='book'; COMMIT; 用外键分解表中低频字段。有些字段的使用频率很低，当表的数据量很大时查询速度会很慢。用外键将这些字段拆分成一个单独的表可以提高效率。 在相同类型的字段间进行比较的操作]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之完整性约束]]></title>
    <url>%2F2018%2F05%2F30%2Fmysql%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[MySQL提供了多种完整性约束，作为数据库关系模式定义的一部分，可以通过create table或alter table语句来定义。一旦定义了完整性约束，MySQL服务器会随时检测处于更新状态的数据库内容是否符合相关的完整性约束，从而保证数据的一致性与正确性。 在关系模型中，提供了实体完整性、参照完整性和用户完整性3项规则。 实体完整性实体是一个数据对象，是指客观存在并可以相互区分的事物，如一个教师、一个学生等。一个实体在数据库中表现为一条记录。 实体完整性是指关系的主属性及主键的组成不能为空。也就是主键不能使空值null。关系对应于现实世界的实体集，而现实世界的实体是可以区分的，即说明每个实例具有唯一性标识。在关系模型中，是使用主键作为唯一性标识的。 先来认识一下关系型数据库中重要的三个键： 超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 候选键(candidate key):不含有多余属性的超键称为候选键 主键(primary key):用户选作元组标识的一个候选键程序主键 在MySQL中，实体完整性是通过主键约束和候选键约束实现的。 主键约束主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中多个列组合而成的主键也被称为复合主键。在MySQL中，主键必须遵循如下规则： 每个表只能定义一个主键 主键必须能唯一标识表中的每一行记录并且不能为null 复合主键不能包含不必要的多余列 一个列名在复合主键的列表中只能出现一次 作为列的主键约束1234create table users ( id tinyint auto_increment primary key, name char(20) not null); 作为表的主键约束123456create table users ( id tinyint auto_increment, name char(20) not null, age tinyint, primary key (id,name)); 如果主键仅由表中的某一列构成，以上两种方法均可以定义主键。如果主键由表中多个列组成，那么只能有第二种方法定义主键约束。 候选键约束如果一个属性集能唯一标识元组而又不含有多余的属性，那么这个属性集称为关系的候选键，用关键字unique来定义。 候选键可以是表中的某一列，也可以是表中多个列所构成的一个组合。任何时候，候选键的值必须是唯一的且不能为空。定义方法类似于主键：123456789101112create table users ( id tinyint auto_increment primary key, name char(20) not null unique, age tinyint);create table users ( id tinyint auto_increment primary key, name char(20) not null, age tinyint, unique (name,age)); 候选键与主键的区别在于： 一个表只能创建一个主键，但是可以有多个候选键 定义主键约束时，系统会自动创建primary key索引，定义候选键约束时，系统会自动创建unique索引 参照完整性现实世界的实体之间往往存在着某种联系，在关系模型中，实体及实体间的联系都是用关系来描述的，那么自然就存在关系与关系间的引用。 参照完整性就是定义外键与主键之间的引用关系的。参照完整性的定义为： 若属性（或属性组）F是基本关系R的外键，它与基本关系S的主键K对应，则对于R中的每个元组在F上的值只允许两种可能：要么取空值，要么等于S中某个元组的主键值，其中R与S可以是不同的关系，也可以是同一是关系，而F和K定义在同一个域中。 声明外键的基本语法如下：1[constraint [symbol]] foreign key (index_col_name,...) reference_defination reference_defination主要用于定义外键所参照的表、列，它的基本语法格式如下：1234references tbl_name [(index_col_name,...)][match full | match pratial | match simple][on delete reference_options][on update reference_options] tbl_name指定外键所参照的表名，这个表称为被参照表或父表，外键所在的表被称为参照表或子表。 index_col_name指定被参照表中与外键相关联的列，必须是父表的主键或候选键，格式语法如下：1col_name [(length)] [ASC|DESC] reference_options指定参照完整性约束的实现策略，默认为restrict。语法格式如下：1restrict | cascade | set null | no action cascade：瀑布、级联 restrict 限制策略：当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除和更新 no action 不采取措施策略：一个相关的外键值在被参照表中时，删除或更新被参照表中的键值动作不被允许。类似于restrict cascade 级联策略：从被参照表中删除或更新纪录行时，自动删除或更新参照表匹配的记录行 set null 制空策略：从被参照表中删除或更新纪录行时，设置参照表中与之对应的外键列的值为null。这个策略需要被参照表中的外键没有声明限定词not null 12345678create table users ( id tinyint auto_increment primary key, name char(20) not null, class_id tinyint not null, constraint class foreign key (class_id) references class(id) on delete cascade on update cascade); 当父子表是同一张表时，MySQL不允许指定on update cascade与on update set null，相关联的两个字段类型必须一致。 用户定义完整性用户定义完整性是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求，关系模型提供定义和检查这类完整性规则的机制。 MySQL提供了非空约束，check约束和触发器3种用户自定义完整性约束。 非空约束通过create table或alter table语句将某个列加上关键字not null可以实现非空约束。1alter table users modify age tinyint not null; check约束可以对列或表使用check约束，语法如下：1check (expr) expr是一个SQL表达式，用于指定需要检查的限定条件。更新数据时MySQL会检查更新后的数据行是否满足check约束中的限定条件。该条件可以是表达式，也可以是子查询。 对列使用check约束12345create table users ( id tinyint auto_increment primary key, name char(20) not null, age tinyint check(age&gt;6 and age&lt;19)); 对表使用check约束123456create table users( id tinyint auto_increment primary key, name char(20) not null, age tinyint, check(name in (select name from students))); 触发器约束触发器由MySQL的基本命令事件来触发的某种特定操作，这些基本的命令有insert、update、delete等事件来触发某些特定的操作。满足触发器的触发条件时，数据库系统会自动执行触发器中定义的程序语句。 创建单行触发器12create trigger 触发器名 before|after 触发事件on 表名 for each row 执行语句; before|after 指定触发器执行时间是在触发事件之前还是之后 触发事件 insert、delete、update等都是触发事件 执行语句 当满足条件时执行的触发器语句 创建一个触发器，自动在用户向users表插入数据行之前向日志插入当前时间：123create trigger userstime before inserton users for each row insert into userslog values (null, now()); 创建多行触发器12345create trigger 触发器名称 before|after 触发事件on 表名 for each row begin执行语句列表end\g 要执行的多条语句放入begin和end中，用;分隔。 查看触发器：查看所有触发器：1show triggers; 根据名字查看触发器：1select * from infomation_schema.triggers where trigger_name=触发器名; 删除触发器1drop trigger 触发器名称; 命名完整性约束可以对完整性使用添加，删除和修改等操作。为了删除和修改完整性约束，需要在定义约束的同时对其进行命名。命名完整性约束是在各种完整性约束的定义说明之前加上constraint字句实现的：1constraint &lt;symbol&gt; [primary key | foreign key | check] 对users表添加外键约束并命名为class：1234alter table users add constraint class foreign key (class_id)references class(id)on update cascadeon delete cascade; 更新完整性约束对各种约束命名后就可以用alter table语句来更新或删除。 删除完整性约束1drop [foreign key | index | &lt;symbol&gt;] | primary key; 在删除主键时，必须在创建一个主键否则不会成功。 删除users表的名为class的外键：1alter table users drop foreign key class;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之索引与范式]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[索引索引是一种特殊的数据结构，类似于字典里的key。通过索引查询数据库中的内容时，不需要遍历所有数据而是直接指向数据所在的位置，这样就可以快速查询到想要的内容。 索引是把双刃剑，虽然索引可以提高检索数据的速度，提高整体的性能，但是也会带来一些副作用： 额外的物理空间（单列索引至少占原表5%到15%） 额外的创建和维护时间（create、insert、update、delete等） MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则： 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。 索引分类常见的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引等 普通索引即不应用任何限制条件的索引，该索引可以在任何数据类型中创建。字段本身的约束条件可以判断其值是否为空或唯一。 唯一性索引使用unique参数可以设置唯一索引。创建该索引时索引的值必须唯一。通过唯一索引，用户可以快速定位某条数据。主键是一种特殊的唯一索引。 全文索引fulltext参数可以设置索引为全文索引。全文索引只能创建在char、varchar、text类型字段上。查询数据量较大的字符串型字段时，使用全文索引可以提高查询速度。只有MyISAM支持fulltext索引 单列索引就是只对应一个字段的索引，可以包括以上三种索引方式。 多列索引在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段。可用通过这几个字段进行查询但是这几个字段必须包含多列索引的第一个字段，只有这样多列索引才会发挥作用 创建索引在建立数据表时创建索引12345create table table_name ( create_defination [unique | fulltext] index [别名](属性名1[(长度)[,属性名2(长度)...]] [ASC|DESC]))[table_options]; 一个简单的例子：1234567create table users ( id tinyint auto_increment primary key, name char(20) not null, age tinyint, sex tinyint(1), fulltext index username(name))engine=MyISAM; 在已建立的数据表中创建索引12create [unique | fulltext] index index_name on table_name(属性[(长度) [AES|DESC]]) 一个简单的例子：1create unique index username on users(name); 也可以通过修改表结构的方式创建索引，参见《MySQL从入门到精通》之基本语句。 范式(Normal Form)关系型数据库的规范化理论为：关系数据库中的每一个关系都要满足一定的规范。根据满足规范的条件不同，可以分为5个等级，一般只要把数据库规范到第三等级就足够了。 第一范式(1NF)第一范式包括下列指导原则： 数据组中的每个属性只可以包含一个值 关系中的每个数组必须包含相同数量的值 关系中的每个数组一定不能相同 在任何一个关系型数据库中，第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。 如果数据表中的每一个列都是不可再分割的基本数据项，即同一列中不能有多个值，那么就称此数据表符合第一范式，由此可见第一范式具有不可再分割的原子特性。 第二范式(2NF)第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分。 为了实现区分各记录行通常需要为表设置一个“区分列”，用以存储各个实体的唯一标识。这个唯一属性列被称为主关键字或主键。 第三范式(3NF)第三范式是在第二范式的基础上建立起来的。第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖，也就是说，第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。所谓传递函数依赖，就是指如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖与关键字段A。参考下面的例子： (员工编码) ——&gt; (决定) (员工姓名、年龄、部门编码、部门经理) 上面这个关系表是符合第二范式的，但是不符合第三范式，因为该关系表内部隐含着如下关系： (员工编码) ——&gt; (决定) (部门编码) ——&gt; (决定) (部门经理) 上面的关系表纯真非关键字段“部门经理”对关键字段“员工编码”的函数传递依赖，对于上面这种关系，可以把这个关系表改为如下两个关系表： 员工信息表：(员工编码，员工姓名，年龄好部门编码)部门信息表：(部门编码和部门经理)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串编码]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[不同的编码方式由于计算机是美国人发明的，所以最早的时候只收录了127个字符，包括阿拉伯数字、英文字母大小写和一些常用符号，称为ASCII编码。后来计算机越来越普及，127个字符显然不够。于是各国又制定了自己国家的字符编码。为了避免不同国家之间通信出现乱码的问题，一种同一编码unicode编码诞生了。ASCII用一个字节（byte）来储存一个字符，而unicode用2到6个字节来储存字符，理论上所有的文字、符号都可以用unicode编码表示。换言之，unicode 是一种计算机内部用于表示字符的方式，称为字符集。 有了 Unicode，就解决了从字符到二进制的编码问题。接下来问题就是计算机如何读取这套编码了。 既然 Unicode 通常占 2byte，系统可以老老实实每次读取 2byte，遇到特殊符号时再往后多读 2byte 就可以了。这就是 Java 默认的 UTF-16 编码。可是问题依然没有完全解决，英语是最常用的语言，UTF-16 把每个字母也按照 2byte 的方式编码，这无疑浪费了很多存储空间。另一种编码方式 UTF-8 则解决了这个问题。UTF-8 默认读取 1byte，但是会用几位冗余信息告诉系统，当前字符有没有结束，是不是还需要继续往下读下一个字节。采用 UTF-8 方式编码，对于英文只会占用 1byte 的空间，而一些特殊字符如中文，则会智能地多占用一点空间进行存储，这样就大大节约了空间，特别适合用于网络传输。在计算机内存中，统一使用unicode字符集，而在网络传输和硬盘保存时，推荐使用 UTF-8 作为编码方式。 编码与解码在python3中，字符默认以unicode方式编码，而在进行网络传输和硬盘保存时，常常将unicode字符按utf-8方式编码。这就要用到encode()方法： 123s = 'hello world'with open('test', 'w') as f: f.write(s.encode('utf-8')) encode()将字符转换成字节，而utf-8则指定是以何种编码格式转换。 当我们从网络上获取数据时，常常也是获取到以UTF-8形式编码的字节，为了方便我们对数据进行处理，用decode()方法：12b = b'\xe4\xb8\xad\xe6\x96\x87'print(b.decode('utf-8')) # 输出：'中文' 参数utf-8表明将字节以UTF-8的形式解码。在python中，字节的前面会有个前缀b。 为了避免乱码，应该始终坚持以UTF-8的形式进行字符和字节之间的转换。]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[unittest单元测试]]></title>
    <url>%2F2018%2F05%2F23%2Funittest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[有个词叫TDD(Tset Driven Development)，测试驱动开发。一个好的开发人员不仅要懂开发，还要懂得一定的测试技巧。python自带了很多的测试库，比如unittest，coverage….介绍一下unittest的使用。 unittests四个重要的概念unittest有四个重要的面向对象概念： test fixture。这个概念主要处理测试环境的搭建和清理。很多时候我们在进行测试的时候需要搭建合适的环境，例如创建目录、创建数据库等，而在测试完毕后这些环境又不再需要了。test fixturn可以帮我们很好的处理这些事情。 test case。 既然要进行测试，测试用例当然是最重要的。每一项测试内容都是一个test case。 test suite。我们当然不希望只能一项项的进行测试，最好是将要测试的项目放在一起。test suite相当于test case的集合，当然test suite也能嵌套在test suite中。 test runner。顾名思义，这个概念负责执行测试并控制结果输出。 创建testcaseunittest提供了TastCase类，要创建一个testcase只需要继承这个父类就好了。 先在mathfunc.py编写三个函数用于测试： 12345678def add(x, y): return x + ydef minus(x, y): return x - ydef string(s): return s 在test_math.py中创建测试用例： 123456789101112131415from mathfunc import *from unittest import TestCaseclass TestMath(TestCase): def test_add(self): """测试add函数""" self.assertTrue(1+2, add(1, 2)) def test_minus(self): """测试minus函数""" self.assertEqual(2-1, minus(2, 1)) def test_string(self): """测试string函数""" self.assertIn('h' in string('hello')) 这就创建了一个testcase，包含三个测试。testcase中所有的测试必须以test开头。self.assert*()是由TestCase提供的测试函数。每一个测试里的文档会在输出测试报告时显示。不用python内置的assert()是因为uniittest在遇到self.assert*()发生错误时会把这个测试标记为failure，然后继续执行其他测试。 创建testsuite有了testcase，自然想把它加入到suite中。unittest提供了TestSuite类来表示一个suite。默认情况下，unittest按测试函数的函数名进行排序，然后按这个排序执行测试。如果我们想控制测试执行顺序，就要在向suite添加case时做点文章：123456789from mathfunc import *import unittestsuite = unittest.TestSuite()# 传入列表，这样就会按照元素顺序执行测试suite.addTests([TestMath('test_add'), TestMath('test_minus'), TestMath('test_string')])if __name__ == '__main__': unittest.main() 还可以通过unittest提供的TestLoader类来添加testcase，TestLoader会返回一个suite。不过TestLoader无法保证按照顺序执行测试。TestLoader类提供了一下常用方法：1234567891011from test_math import *# 三种方法都可以suite.addTests(unittest.TestLoader().loadTestsFromName('test_math.TestMath'))suite.addTests(unitest.TestLoader().loadTestsFromNanes(['test_math.TestMath'])suite.addTests(unitest.TestLoader().loadTestsFromTestCase(TestMath))# 如果test_math在/usr/test/目录下suite.addTests(unittest.TestLoader().discover(r'/usr/test/'))# 可用添加单个testcasesuite.addTest(TestMath('test_add')) loadTestsFromName(模块名.testcase名) loadTestsFromTestCase(testcase名) discover(start_dir, pattern=’test*.py’, top_level_dir=None)。start_dir是目标文件夹路径，unittest会查找指定目录及子目录下的全部符合pattern的模块并执行里面的TestCase。电脑中不能有同名的目标文件夹，否则unittest可能无法找到正确的位置。patter默认是’test*.py’。 搭建测试环境TaseCase父类提供了setUp()，tearDown()，setUpClass()，tearDownClass()。我们在自己的测试用例中重写就可以了。 setUp()与tearDown()会在每个测试之前执行。setUp()负责搭建测试环境，tearDown()负责清理环境。如果setUp()执行失败那么这次测试不会进行，如果setUp()成功执行那么不管测试是否成功tearDown()都会执行。1234567891011121314151617import unittestfrom manage import create_app, dbclass TestBasic(unittest.TestCase): def setUp(self): self.app = create_app('TESTING') self.app_context = self.app.app_context() self.app_context.push() self.client = self.app.test_client(use_cookies=True) db.create_all() def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() ... 如果想要在所以case之前执行一次环境准备，所有case之后清理环境，可用setUpClass()和tearDownClass()。不过要带上@classmethod装饰器。12345678910111213141516171819import unittestfrom manage import create_app, dbclass TestBasic(unittest.TestCase): @classmethod def setUp(cls): cls.app = create_app('TESTING') cls.app_context = cls.app.app_context() cls.app_context.push() cls.client = cls.app.test_client(use_cookies=True) db.create_all() @classmethod def tearDown(cls): db.session.remove() db.drop_all() cls.app_context.pop() ... 执行测试及控制输出通常我们使用unittest.main()就会调用Test Runner开始测试。当然也可以手动执行Runner。123if __name__ == "__main__": runner = unittest.TextTest.Runner(verbosity=2) runner.run(suite) verbosity设定了测试报告的详细程度，有0，1，2三种。默认值是1，数字越大越详细。 也可以把输出写到文件里,将文件指针传给Runner()里的stream参数就可以了：123with open('/usr/test/report', 'w') as f: runner = unittest.TextTest.Runner(verbosity=2, stream=f) runner.run(suite) 跳过测试unittest提供3种跳过测试的装饰器：skip([reason])、skipIf(condtion[,reason])，skipUnless(conditon[,reason])。12345678910111213from mathfunc import *import unittestclass TestMath(unittest.TestCase): @unittest.skip('跳过add函数') def test_add(self): self.assertTrue(1+2, add(1, 2)) def test_minus(self): self.assertEqual(2-1, minus(2, 1)) def test_string(self): self.assertIn('h' in string('hello'))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常见用法]]></title>
    <url>%2F2018%2F05%2F23%2Fgit%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用git也有一段时间了，一直没有做总结，在这里记录一下方便以后查看。 安装gitwindows下直接从官网下载就可以了，安装过程是傻瓜式的，一路点确定就OK。安装完成后发现多了个叫git bash的程序，打开程序会弹出一个命令行窗口就可以了。 linux下安装git很简单，直接在终端输入git，系统会告诉你是否已经安装。如果没有安装还会告诉你安装方法。Debian和Ubantu下通过sudo apt-get install git就可以进行安装。 配置git由于git是分布式版本控制系统，所以必须指出每台机器的身份。这就要配置git相关变量：12git config --global user.username &quot;name&quot;git config --global user.email &quot;email&quot; 有时候我们发现自己的账户和邮箱配置错了，重设我们的账户和邮箱：12git config --global --replace-all user.username &quot;new name&quot;git config --global --replace-all user.email &quot;new email&quot; 创建版本库cd到目标文件夹下，打开git bash或在终端输入：1git init 这就创建了一个版本库，有了版本库就可以开始使用git的各项功能了。 git分区git有分区的概念，平时我们新建、删除、修改文件都是在工作区，通过git add命令把工作区的变动提交到暂存区(stage)，再用git commit把stage的内容提交到分支。 查看git状态12git status #查看当前仓库的状态（是否有文件被修改，有文件没有commit等）git diff file #用于比较工作区版本与缓存区版本的不同 git指出有一个modified：learngit.txt,且not staged(没有提交至暂存区) 添加远程仓库想把github中的仓库和本地仓库关联起来，就要先在github中添加这台机器的ssh。可以通过 1ssh-keygen -t rsa -C &quot;email&quot; 来获得本机的ssh密钥，这条命令会在当前文件夹下生成.ssh文件夹，里面有两个文件：id_rsa和id_rsa.pub。带pub的是公钥，把id_rsa.pub里的内容添加到github上。 远程仓库与本地仓库通过这条命令可以实现，”url”是远程仓库的网址：1git remote add origin &quot;url&quot; origin就是这个git本地仓库对远程仓库的称呼，也可以用别的名字，但是通常都用origin。 删除本地仓库与远程仓库的关联也很简单：1git remote remove origin 把本地库内容推送到远程1git push origin master 如果是第一次推送，可以为push加上-u参数，这样以后推送的时候就不用再输入github的账号和密码了。master代表远程仓库的主分支，如果要推送到其他分支就换成其他分支名。 抓取远程库内容抓取远程仓库内容并merge到本地1git pull origin 克隆一份仓库有时候我们在github上可能看到一些很有意思的库，可以用这个命令把它下载到本地，其中”url”是这个仓库的网址：1git clone &quot;url&quot; 显示过往提交记录12git log # 显示提交日志，每次提交会有一个专属的版本号，通过版本号可回溯至本次提交git log --pretty=oneline # 在log显示信息过乱时可以加 --pretty=online参数，只显示提交记录及其版本号 HEAD表示这是当前版本，可以用HEAD^表示上一版本，HEAD^表示上上版本…HEAD~100表示第前100个版本。 版本回退使用git的一个主要好用就是git提供方便的版本控制，可以在需要的时候回退到任意版本。 版本回退命令：1git reset --hard &apos;版本号&apos; 版本号可以用git log查询，结合这两个命令就可以实现版本回退啦~ 但是这里有个问题：当我们回到历史版本后，git log命令就无法显示最新版本的版本号。相当于我们穿越到过去，却没办法回来了。幸好git relog命令可以解决这个问题，git relog记录了每一次命令： 在这个例子中，可以通过git reset --hard 78ab7e9从be2a4ae回退到78ab7e9版本。 管理修改有时我们修改了工作区或暂存区的文件，过了一会儿又后悔了，可以用下面的命令撤销这些修改：1git checkout file 如果文件已经commit到了暂存区，想要把它从暂存区里撤下来也是可以的：1git reset HEAD file 处理冲突在合并分支时，可能会遇到两个分支的内容有冲突而导致合并失败的现象（这在执行pull操作时尤其常见，特别是当你在github上在线修改了一个文件，而本地没有修改时）。git会在冲突文件中用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同内容的分支。我们需要将文件进行修改后再执行git commit：12345678910111213# 可以看到，两个分支冲突了&lt;&lt;&lt;&lt;&lt;&lt;HEADgit is good=======git is very good&gt;&gt;&gt;&gt;&gt;&gt;branch# 将文件修改一下git is very good# 提交git add test.txtgit commit -m &quot;解决冲突&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL之基础语法]]></title>
    <url>%2F2018%2F03%2F31%2F%E3%80%8AMySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[数据库常用对象在MySQL中，表、视图、存储过程和索引等具体存储数据或对数据进行操作的实体都被称为数据库对象。 表表是包含数据库中所有数据的数据库对象，由行和列组成，用于组织和存储数据类型 字段表中每列被称为一个字段，字段具有自己的属性，如字段类型、字段大小等。其中，字段类型是字段最重要的属性，它决定了字段能存储哪种数据。 索引索引是一个单独的、物理的数据结构。它是依赖于表建立的，在数据库中索引使用数据库程序无需对整个表进行扫描就可以在其中找到所需的数据。 视图视图是从一张或多张表中导出的表（也称虚拟表），是用户查看数据的一种方式，表中包括几个被定义的数据列与数据行，其结构和数据建立在对表的查询基础之上。 存储过程存储过程是一组为了完成特定功能的SQL语句集合（包括查询、插入、删除、更新等操作），经编译后以名称的形式存储在SQL Server服务端的数据库中，由用户通过指定存储过程的名字来执行对应的存储操作。 存储引擎存储引擎其实就是如何在存储数据，如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL支持很多表，每种类型都有自己的特定作用、优点和缺点。MySQL还相应提供了很多不同的存储引擎，可以以最适合于应用需求的方式存储数据。 存储引擎的概念MySQL中的数据用各种不同的技术存储在文件或内存中，这些技术采用不同的存储机制、索引技巧、锁定水平并最终提供广泛的、不同的功能和能力。通过选择不同的技术，能够获取额外的速度或者功能，从而改善应用的整体功能。 查询当前数据库的引擎1show variables like '%storage_engine%'; InnoDB引擎InnoDB支持自动增长列：AUTO_INCREMENT。自动增长列的值不能为空，且值必须唯一。MySQL中规定自动增长列必须为主键，在插入值时，如果自动增长列不输入值或插入的值为0、null，则插入的值为自动增长后的值。 InnoDB支持外键（foreign key）。外键所在表为子表，外键所依赖的表为父表。父表中被子表外键关联的字段必须为主键。当修改父表的某天信息时，子表也必须有相应的改变。 InnoDB是如下情况的理想引擎： 更新密集的表。InnnoDB特别适合处理多重并发的更新请求 事务。InnoDB是唯一支持事务的标志MySQL存储引擎。在管理敏感数据（如用户注册）时特别有用 自动灾难修复。与其他引擎不同，InnoDB能自动从灾难中恢复，虽然MyISAM也能做到但是其过程要长得多 MyISAM引擎MyISAM引擎的优点在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。 数据类型MySQL支持5中基本字段类型：数值型，字符型，文本型，逻辑型和日期时间型。 数值型MySQL支持所有标准SQL数值数据类型。这些数值类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 整数型 浮点数型 时间日期型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性。 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 创建表时，使用字符串类型时应遵循以下原则： 从速度方面考虑，要选择固定的列，可以使用CHAR类型 要节省空间，使用动态的列，可以使用VARCHAR类型 要将列中的内容限制在一种选择，可以用ENUM类型 允许一个列中有多于一个的条目，可以用SET类型 布尔型其实MySQL里根本没有布尔型，虽然可以用boolean但实际上MySQL会把它替换成tinyint(1)。用1或True表示真，0或False表示假。 SQL语句使用数据库，首先要会SQL语句。下列SQL语句中，带{}的是必选项，[]是可选项，[default]表示可选并有默认值的选项，|表示或。sql语句以;结尾，也可以用\g或\G，\g与;是相同的，而\G可以让结果显示更美观。 创建数据库12create database [if not exists] 数据库名[default]character set [=] 字符集名; character set默认情况下是MySQL服务器配置文件里的字符集。可以是GB2312或GBK（简体中文）、UTF8（针对Unicode的可变长度的字符编码，又称万国码）、BIG5（繁体中文）、Latin1（拉丁文）等，最常见的就是GBK和UTF8。 查看数据库1show database [like '模式']; 查看所有数据库，like用于指定匹配模式（支持正则）。如： 1show database like 'db_%'; 选择数据库1use 数据库名; 使用use语句将数据库指定为当前数据库后，当前数据库在当前工作会话关闭（即断开与该数据库的连接）或再次使用use语句指定数据库时结束工作状态。 删除数据库1drop database [if exists] 数据库名; if exists在删除数据库前先判断数据库是否已经存在，只有已经存在是才会执行删除操作，这样可以避免删除不存在的数据库时产生异常。 创建数据表12create [temporary] table [if not exists] 数据表名(&#123;create_defination[,create_defination]&#125;) [table_options] [select_statement]; 说明： temporary：创建一个临时表 if not exists：避免表存在时出错 create_defination：定义表的列属性 table_options：表的一些特性参数，涉及表数据如何存储。如engine选项：engine=MyISAM。 select_statement：select语句描述部分，用它可以快速创建表 create_defination格式： col_name type [not null | null] [default default_value] [auto_increment] [primary key] [reference_defination] 下面是例子： 12345create table test ( id tinyint not null auto_increment primary key, name char(20) not null, age tinyint,); 查看表结构1&#123;describe | desc&#125; 数据表名 [列名]; 修改表结构修改表结构指增加或删除字段、修改字段名称或字段类型、设置取消主键外键、设置取消索引等 1alter table 数据表名 alter_spec[,alter_spec] | table_options alter_spec: add create_defination[first | after column_name] //添加新字段 add index [index_name] (index_col_name) //添加索引名称 add primary key (index_col_name) //添加主键名称 add unique [index_name] (index_col_name) //添加唯一索引 alter col_name {set default 默认值 | drop default} //修改字段默认值 change old_col_name create_defination //修改字段名、类型 modify col_name create_defination //修改字段定义 drop col_name //删除字段 drop index index_name //删除索引 rename as new_tab_name //修改表名 alter table语句允许指定多个动作，其动作间用逗号分隔，每个动作表示一个修改。 添加新字段及修改字段定义12alter table users add email varchar(20) not null after location,modify name char(10); 修改字段名1alter table users change user username varhcar(20) not null; 删除字段1alter table users drop email; 修改表名1alter table users rename the_users; 复制表在一张已存在的数据表的基础上创建一份该表的备份，也就是复制表： 1create table [if not exists] 数据表名 like 源数据表名; 使用该语法复制数据表时，将创建一个与源数据表相同结构的新表，该数据表的别名、数据类型和索引都将被复制，但是表的内容是不会被复制的。因此，创建的表是一张空表: 1create table if not exists user like the_users; 如果在复制表格式的同时也想复制表中的内容，可以使用as（查询表达式）字句实现： 1create table if not exists user as select * from the_users; 删除表1drop table [if exists] 数据表名; 可同时删除多张表，多个表之间用逗号,连接。 插入数据12insert [low_priority | delayed | high_priority] [ignore][into] 数据表名 [(字段名)] values (&#123;值 | default&#125;),(...),... [low_priority | delayed | high_priority]：low_priority是insert、delete、update都可选的操作，降低insert、delete、update的优先级。delayed是insert语句支持的一种可选修饰符，用于指定MySQL服务器把待插入的行数据放在一个缓冲器中，直到待插数据的表空闲时，才真正的在表中插入数据行。high_priority是insert和select语句支持的一种可选修饰符，用于指定insert和select操作优先执行。 [ignore]： 在执行insert语句时，所出现的错误都会被当做警告 [into]： 指定被操作的数据表 [(字段名,…)]： 当不指定该选项时，表示要向表中所有列插入数据，否则表示向数据表的指定列插入数据。 ({值 | default}),(…),…：用于指定需要插入的数据清单，其顺序必须与字段的顺序相对应。其中的每一列的数据可以是一个变量、常量、表达式或者null。但是其数据类型要与对应的字段类型相匹配；也可以使用default关键字，表示为该列插入默认值，但是前提是已经明确指定了默认值，否则会出错。 插入完整数据1insert into users values (1, 'qiuyue', 19); 插入数据记录的一部分只插入表的一行中的某几个字段的值。 1insert into users (name, age) values ('qiuyue', 19); MySQL支持同时插入多行数据，不同行的数据之间用,分割。 插入查询结果MySQL支持将查询结果插入到数据表中。可以通过insert...select...实现。 123insert into [low_priority | high_priority] [ignore][into] 数据表名 [(字段名,...)]select ...; [(字段名,…)]： 当不指定该选项时，表示要向表中所有列插入数据，否则表示向数据表的指定列插入数据。 select字句：用于快速地从一个或多个表中取出数据，并将这些数据作为行数据插入到目标数据表中。select字句返回的结果集中的字段数量、字段类型必须与目标数据表完全一致。 1insert into users (username,age) select username,age from students; 修改数据执行修改操作可以用update语句： 123update 数据表名set 字段1=值1[,字段2=值2 ...][where 条件表达式] [order by...] [limit 行数] set： 指定表中要修改的字段名及字段值，其中的值可以是表达式，也可以是该字段所对应的默认值。如果指定默认值，那么使用关键字default指定。 where: 用于限定表中要修改的行，如果不指定该字句那么update会更新所有行 [order by] : 用于限定表中的行的被修改的次序。 [limit] : 限定被修改的行数 1update users set username='qiuyue' where id=1; 删除数据12delete from 数据表名[where 条件表达式] [order by...] [limit 行数]; 如果没有指定where条件，将删除所有记录。一般删除条件为数据的id，以避免一些错误的发生。 1delete from users where id=2; 如果要删除所有行，还可以使用truncate table语句： 1truncate [table] 数据表名 truncate会删除数据表中所有数据且无法恢复。delete与truncate区别如下： 使用turncate语句会重新设置auto_increment计数器的初始值 对于参与了索引和视图的表不能使用truncate语句 truncate比delete使用的系统和事物资源少。每删除一条记录delete语句都会添加一条日志，而truncate只再事物日志中记录页的释放。 查询语句select语句基本语法如下： 123456select selection_list //要查询的内容，选择哪些列from 数据表名 //指定数据表where primary_constraint //查询时要满足的条件order by sroting_cloumns //如何对结果进行排序having secondary_constraint //查询时满足的第二条件limit count //限定输出的查询结果数 查询一张表的一列或多列12select * from users; //查询users表所有内容select id,age from users; //查询users表id列和age列所有内容 从多个表中获取数据使用select语句进行多表查询，需要确定所查询的数据在哪个表中，多个表之间用,分隔： 12select users.id,users.name,student.id,student.namefrom users,student; 还可以在where子句中用连接符=来确定表之间的联系。然后根据这个条件返回查询结果： 1select users.name,student.location from users,studnet where users.id=student.id and users.id=1; users.id=student.id表示将users和student两张表根据users.id=stduent.id的条件连接起来，叫做等同连接。如果不使用users.id=stduent.id那么产生的结果是两张表的笛卡尔积，叫全连接。 带关键字in的查询1select 字段 from 表名 where 字段 [not] in (元素1，元素2 ...); 关键字in可以判断某个字段的值是否在指定的集合中，如果在该记录会被查询出来： 1select name,age from users where name in ('Mike', 'David'); 带关键字between…and…的范围查询between and是前闭后闭的 1select * from users where id between 2 and 7; 带like的字符匹配查询通过like可以实现模糊查询，它有两种通配符%和_: %可以匹配0个或多个字符，可以代表任意长度的字符串。如&quot;Mi%ke&quot;可以匹配Mike，Miosfke等 _只能匹配一个字符。 关键字distinct去除结果重复行1select distinct 字段名 from 表名; 关键字group by分组查询通过关键字group by可以将数据划分到不同的组中，实现对记录的分组查询。 1select name,age,location,class_id from students group by class_id; 默认情况下只会显示分组中一个成员的信息，要显示分组中某个字段的所有成员可以用group_ concat()函数： 12select group_concat(name) as name,group_concat(age) as age,class_id from students group by class_id; 聚合函数查询聚合函数特点是根据一组数据求出一个值。常与group by搭配使用。 count()对于*以外的任何参数，返回所选集合中非null值的行的数目，对于*返回集合中所有行的数目。 1select count(name) as num,class_id from students group by class_id; sum(),avg(),max(),min()连接查询连接是把不同表的记录连接在一起的最普遍的方法。 内连接查询内连接会把不符合连接条件的行从视图中删除，最常见的例子是相等查询： 12select s.name,s.age,s.class_id,c.name as class_name from students as s join classes as c where s.class_id=c.id and s.id&gt;5; 左外连接返回结果除了内连接的数据外，还包括左表中不符合条件的数据，并在右表相应列加null值 1select 字段 from 左表名 left join 右表名 on 条件; 右外连接返回结果除了内连接的数据外，还包括右表中不符合条件的数据，并在左表相应列加null值 1select 字段 from 左表名 left join 右表名 on 条件; 子查询子查询就是select查询是另一个查询的附属。在外面一层的查询中使用里面一层查询产生的结果集，这样就不是执行多个独立的查询而是执行包含一个或多个子查询的单独查询。 遇到多层查询时，MySQL会先从最内层的查询开始，然后从它开始向外移动到外层，这个过程中每个查询产生的结果集都被赋予给包围它的父集，接着这个父查询被执行。 子查询可以用在任何可以使用表达式的地方。 带关键字in的子查询1select * from users where id in (select id from students); 带关键字exists的子查询使用关键字exists时，内层查询语句不返回查询的记录而是返回一个真假值。如果内层查询语句查询到满足条件的记录就返回True,否则返回False。当返回值为True，外层语句就会进行，否则外层语句查询不到任何记录。 1select * from users where exists (select * from students where id=27); 带关键字any、all的子查询这两个关键字多用于比较运算。any表示满足其中任意一个条件，只要满足内层查询语句返回的结果中的任意一个，就可以通过该条件来执行外层查询。 1select * from users where id &gt; any(select id from students); all表示满足所有条件，只有满足内层查询语句返回的所有结果，才可以执行外层查询。 1select * from users where id &gt; all(select id from students); 使用正则表达式查询1字段名 regexp MySQL中正则表达式格式与普通格式是一样的。 1select id,name from users where name regexp '^M.*e [JS].+o&#123;2,4&#125;y$'; 语句执行顺序MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。 下面来分析一下这些语句： FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3,如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6. HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. ORDER BY: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10. LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。 where和having的区别：where是在分组之前进行过滤，而having是在分组之后对条件进行判断。这里要提醒一下: select 中的选择字段除非使用了聚合函数如SUM(), AVG() 等，必须是 group_by 中的分组字段，否则 select 选择字段必须是group_by分组字段。要解决这个问题也很简单，只要使用命令 SET sql_mode=(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;));，或者在配置文件my.ini中将sql_mode修改为：’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F2018%2F01%2F09%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程/线程众所周知，CPU是计算机的核心，它承担了所有的计算任务。而操作系统是计算机的管理者，是一个大管家，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。应用应用程序是具有某种功能的程序，程序运行与操作系统之上。 进程进程是一个具有一定功能的程序在一个数据集上的一次动态执行过程。进程由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时需要的数据和工作区；程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。不同的进程之间拥有的独立的控制流和虚拟内存空间 简单来说进程就是动起来的程序 线程在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。 线程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。一个进程可以拥有多个线程，而且属于同一个进程的多个线程间会共享该进行的资源。 进程与线程的区别 一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。 切换进程需要的资源比切换线程的要多的多。 进程之间相互独立，而同一个进程下的线程共享程序的内存空间（如代码段，数据集，堆栈等）。某进程内的线程在其他进程不可见。换言之，线程共享同一片内存空间，而进程各有独立的内存空间。 以下是我在知乎上看到的关于进程与线程的讨论，其中一个作者感觉很有道理，摘抄如下： 作者：zhonyong链接：https://www.zhihu.com/question/25532384/answer/81152571 首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。下面细说背景：CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。========= 重要的东西出现了========进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。到此全文结束，再一个总结：进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。 开进程需要时间学习《python爬虫开发与项目实践》时，执行下面一段代码： 1234567891011121314from multiprocessing import Processimport osdef run_process(name): print("Child process %s (%s) is running" % (name,os.getpid()))if __name__ == "__main__": print("parant process %s " % os.getpid()) for i in range(5): p = Process(target=run_process, args=(str(i),)) print("process will start") p.start() p.join() print("process end") 显示的结果是 123456789101112parant process 6332 process will startprocess will startprocess will startprocess will startprocess will startChild process 2 (9896) is runningChild process 0 (11208) is runningChild process 3 (5464) is runningChild process 1 (10208) is runningChild process 4 (12596) is runningprocess end 可以看到，程序在执行完 1print ("parant process %s " % os.getpid()) 没有接着马上执行run_process()，而是先打印process will start，最后把子进程一起执行。这是因为子进程的创建是需要时间的，在这个空闲时间里父进程继续执行代码，而子进程在创建完成后显示。 Pool进程池需要创建多个进程时，可以使用multiprocessing中的Pool类开进程池。Pool()默认开启数量等于当前cpu核心数的子进程（当然可以手动改变） 1234567891011121314from multiprocessing import Pooldef hello(i): print("hello ,this is the %d process" % i)def main(): p = Pool() for i in range(1,5): p.apply_async(target=hell0,args=(i,)) p.close p.joinif __name__ == "__main__": main() apply_async表示在开进程时不阻塞主进程，是异步IO的一种方式之一。targe参数传入要在子线程中执行的函数对象，args以元组的方式传入函数的参数。join会等待线程池中的每一个线程执行完毕，在调用join之前必须要先调用close，close表示不能再向线程池中添加新的process了。 进程间的通信每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。Python提供了多种进程通信的方式，其中以Queue和Pipe用得最多。下面分别介绍这两种模式。 QueueQueue是一种多进程安全的队列。实现多进程间的通信有两种方法： get() 用于向队列中加入数据。有两个属性：blocked和timeout。blocked为true时（默认为True）且timeout为正值时，如果当队列已满会阻塞timeout时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出Queue.Full异常。 put() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked和timeout。blocked为true（默认为True）且timeout为正值时，如果当前队列为空会阻塞timeout时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出Queue.Empty异常。 1234567891011121314151617181920212223242526from multiprocessing import Process,Queueimport osdef put_data(q,nums): print('现在的进程编号为：%s，这是一个put进程' % os.getpid()) for num in nums: q.put(num) print('%d已经放入队列中啦！' % num)def get_data(q): print('现在的进程编号为：%s，这是一个get进程' % os.getpid()) while True: print('已经从队列中获取%s并从中删除' % q.get())if __name__ == '__main__': q = Queue() p1 = Process(target=put_data,args=(q,['1','2','3'],)) p2 = Process(target=put_data,args=(q,['4','5','6'],)) p3 = Process(target=get_data,args=(q,)) p1.start() p2.start() p3.start() p1.join() p2.join() # p3是个死循环，需要手动结束这个进程 p3.terminate() 我们来看一下运行结果： 123456789101112131415现在的进程编号为：10336，这是一个put进程1已经放入队列中啦！2已经放入队列中啦！3已经放入队列中啦！现在的进程编号为：9116，这是一个get进程已经从队列中获取1,并从中删除已经从队列中获取2并从中删除已经从队列中获取3并从中删除现在的进程编号为：2732，这是一个put进程4已经放入队列中啦！5已经放入队列中啦！已经从队列中获取4,并从中删除6已经放入队列中啦！已经从队列中获取5并从中删除已经从队列中获取6并从中删除 PipePipe与Queue不同之处在于Pipe是用于两个进程之间的通信。就像进程位于一根水管的两端。让我们看看Pipe官方文档的描述： Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe. Piep返回conn1和conn2代表水管的两端。Pipe还有一个参数duplex（adj. 二倍的，双重的 n. 双工；占两层楼的公寓套房），默认为True。当duplex为True时，开启双工模式，此时水管的两边都可以进行收发。当duplex为False，那么conn1只负责接受信息，conn2只负责发送信息。conn通过send()和recv()来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv()会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。 123456789101112131415161718192021222324from multiprocessing import Process,Pipeimport osdef put_data(p,nums): print('现在的进程编号为：%s，这个一个send进程' % os.getpid()) for num in nums: p.send(num) print('%s已经放入管道中啦！' % num)def get_data(p): print('现在的进程编号为：%s，这个一个recv进程' % os.getpid()) while True: print('已经从管道中获取%s并从中删除' % p.recv())if __name__ == '__main__': p = Pipe(duplex=False) # 此时Pipe[1]即是Pipe返回的conn2 p1 = Process(target=put_data,args=(p[1],['1','2','3'],)) # 此时Pipe[0]即是Pipe返回的conn1 p3 = Process(target=get_data,args=(p[0],)) p1.start() p3.start() p1.join() p3.terminate() 让我们看一下输出结果 12345678现在的进程编号为：9868，这个一个recv进程现在的进程编号为：9072，这个一个send进程1已经放入管道中啦！已经从管道中获取1,并从中删除2已经放入管道中啦！已经从管道中获取2并从中删除3已经放入管道中啦！已经从管道中获取3并从中删除 控制线程我们是没有办法完全人为控制线程的，因为线程是由操作系统同一调度的。但是可以用一些方式来影响线程的调用，比如互斥锁，sleep（阻塞），死锁等。 线程的几种状态新建—–就绪——————运行—–死亡&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待（阻塞） 线程的生命周期由run方法决定，当run方法结束时线程死亡。可以通过继承Thread，重写run方法改变Thread的功能，最后还是通过start()方法开线程。 12345678910111213141516171819202122from threading import Threadclass MyThread(Thread): def run(self): print('i am sorry')if __name__ == '__main__': t = MyThread() t.start()``` 通过args参数以一个元组的方式给线程中的函数传参。```pythonfrom threading import Threaddef sorry(name): print('i am sorry',name)if __name__ == '__main__': t = Thread(target=sorry,args=('mike')) t.start() 线程锁多线程中任务中，可能会发生多个线程同时对一个公共资源（如全局变量）进行操作的情况，这是就会发生混乱。为了避免这种情况，需要引入线程锁的概念。只有一个线程能处于上锁状态，当一个线程上锁之后，如果有另外一个线程试图获得锁，该线程就会挂起直到拥有锁的线程将锁释放。这样就保证了同时只有一个线程对公共资源进行访问或修改。 12345678910111213141516171819from threading import Thread,Locknum = 0def puls(): # 获得一个锁 lock = Lock() global num # acquire()方法上锁 lock.acquire() num += 1 print(num) # release()方法解锁 lock.release()if __name__ == '__main__': for i in range(5): t = Thread(target=plus) t.start() t.join() join()方法会阻塞主线程直到子线程全部结束（也就是同步） 锁的用处: 确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。 锁的坏处: 阻止了多线程并发执行，效率大大降低。 由于存在多个锁，不同的线程持有不同的锁并试图获取对方的锁时，可能造成死锁。 守护线程线程其实并没有主次的概念，我们一般说的‘主线程’实际上是 main 函数的线程，而所谓主线程结束子线程也会结束是因为在主线程结束时调用了系统的退出函数。而守护线程是指 ‘不重要线程’。主线程会等所有 ‘重要’ 线程结束后才结束。通常当客户端访问服务器时会为这次访问开启一个守护线程。将setDaemon属性设为True即可将该线程设为守护线程。 123456789101112from threading import Threadn = 100def count(x,y): return n=x+yif __name__ == '__main__': t = Thread(target=count,args=(1,2)) t.setDaemon = True # ...]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新开始]]></title>
    <url>%2F2017%2F12%2F02%2F%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[前阵子手贱删了博客文件，还糊里糊涂地把coding里的项目也删了。然后各种蜜汁错误，各种无法重新部署。最近几天又蜜汁部署成功。可以说十分难受了。 不过塞翁失马，焉知非福。经过这么一遭我再次练习了一遍coding+hexo下博客的部署，也算是好事一桩了吧？（强行自我安慰一波233）以后我一定天天向上，重新做人，再不手贱。 再次感谢王哥的教程，很详细，帮助很大，很好，很棒。感兴趣的同志可以去他那里转转呀（手动滑稽）windliang的博客 扯到这里算是暂时结束，以后有时间再上来扯扯淡，写点学习心得啥的吧。]]></content>
      <categories>
        <category>矫情</category>
      </categories>
      <tags>
        <tag>闲聊</tag>
      </tags>
  </entry>
</search>
