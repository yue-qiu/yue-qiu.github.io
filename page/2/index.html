<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="高山仰止，景行行止。虽不能至，心向往之。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    精神的壳</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
<link rel="alternate" href="/atom.xml" title="精神的壳" type="application/atom+xml">
</head></html>

<body>
  <main class="content">
    <section class="jumbotron">
  <div class="video">
    
    <div class="video-frame">
      <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
    </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay="" poster="/images/ocean/ocean.png"
        x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">精神的壳</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="精神的壳"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>
<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>
    
    
    <article id="post-http包——go网络服务的第一步" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/06/03/http包——go网络服务的第一步/">初探http包——go网络服务的第一步</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/03/http包——go网络服务的第一步/" class="article-date">
  <time datetime="2020-06-03T12:04:54.000Z" itemprop="datePublished">2020-06-03</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>仅需几行 go 代码就可以构建一个高效的 HTTP 服务器:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">       w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world!"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问 <code>127.0.0.1:8080</code> 就可以看到，一个服务器已经成功启动了（而且和 Python 等语言自带的服务器相比性能很强哦）：</p>
<p><img src="https://i.loli.net/2020/06/03/k3QcvMgNR1mr59A.png" alt="http服务器"></p>
<p>对一次 HTTP 通信，我们只需要关注客户端（client）和服务端（Server）即可。而一个 HTTP 服务器最重要的功能莫过于 <code>路由</code>，即实现一个多路选择器（multiplexer）。本文就来探索这背后的秘密。</p>
<p>先认识一下 Server 类：</p>
<p><img src="https://i.loli.net/2020/06/03/asTBZgulqdQXwco.png" alt="http.Server"></p>
<h2 id="从-Handler-说起"><a href="#从-Handler-说起" class="headerlink" title="从 Handler 说起"></a>从 Handler 说起</h2><p>Handler 是一个抽象接口，其唯一的方法是 <code>ServeHTTP(ResponseWriter, *Request)</code>。<br>实现了 Handler 接口的对象可以注册到 Server，为特定的路径及其子树提供服务。</p>
<p>下面是 http 包中实现了 Handler 的类：</p>
<p><img src="https://i.loli.net/2020/06/03/v63t1eTHROSb9dM.png" alt="Handler接口"></p>
<p>因为本包多处使用到名为 handler 的 Handler 实例，而这些实例可能拥有不同的实现，所以有必要做一个分类：</p>
<ul>
<li>handler 处理器函数：签名为 <code>func(ResponseWriter, *Request)</code> 的函数</li>
<li>handler 处理器：经过 <code>HandleFunc</code> 包装，实现了 <code>Handler</code> 接口的函数</li>
<li>handler 对象：任何实现了 <code>Handler</code> 接口的结构体</li>
</ul>
<p><img src="https://i.loli.net/2020/06/04/Y9glIrx8Ud5yfou.png" alt="Handler对象之间的关系"></p>
<h2 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h2><p>Server 根据请求选择合适的处理器构建响应，那么当然事先要在 Server 中把 请求-处理器 之间的关系注册好，<code>ServerMux</code> 就是负责关系请求模式串和处理器之间的关系的。</p>
<p>注册一个处理器的常用方法就是调用 <code>http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>，其背后的逻辑如下：</p>
<p><img src="https://i.loli.net/2020/06/03/rvLk8VzcFeJyXNw.png" alt="构建处理函数"></p>
<p><code>http.HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code> 会使用 DefaultServeMux 的 <code>HandleFunc</code> 方法，该方法把 handler 处理器函数包装为 handler 处理器，然后通过 DefaultServeMux 的 <code>Handle</code> 方法把这个处理器注册到相应模式串去。这样就完成了一次 <code>模式串-处理器</code> 的注册。</p>
<p>当然，我们也可以创建一个 ServeMux 实例并调用其 <code>HandleFunc</code> 方法把处理器注册到自定义的 ServeMux 上去：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hiHandler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hiHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter,  r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprint(w, <span class="string">"hi, world!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"hello world!"</span>)</span><br><span class="line">    &#125;) <span class="comment">// ServeMux.HandleFunc 需要一个 handler 处理器函数</span></span><br><span class="line">    mux.Handle(<span class="string">"/bye"</span>, http.HandleFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"bye world!"</span>)</span><br><span class="line">    &#125;)) <span class="comment">// 把一个 handler 处理器函数包装成一个 handler 处理器</span></span><br><span class="line">    mux.Handle(<span class="string">"/hi"</span>, &amp;hiHandler&#123;&#125;) <span class="comment">// 直接给一个 handler 对象</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, mux) <span class="comment">// 指定 DefaultServer 使用自定义的 ServeMux</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>我们需要一个 Server 对各种请求进行总处理，调用 <code>http.ListenAndServe(string, Handler)</code> 会初始化一个 Server 实例，其背后逻辑如下：</p>
<p><img src="https://i.loli.net/2020/06/04/TiXUv2jkazD1HYN.png" alt="处理请求"></p>
<p>Server 会监听其 <code>Addr</code> 属性上的 TCP 连接，为每个到来的 TCP 连接创建一个 <code>http.conn</code> 作为其在服务器端的抽象。从 <code>http.conn</code> 中读取并解析 HTTP 请求，创建 <code>http.ResponseWriter</code> 作为该请求的响应的抽象，然后在 Server 的 <code>Handler</code> 字段中寻找是否指定了 ServerMux（字段为空则使用 DefaultServeMux）。最后在 ServeMux 中查找并调用相应的处理器构建 HTTP 响应。</p>
<p>Serer 当然也是可以自定义的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"hello world!"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    server := &amp;http.Server&#123; <span class="comment">// 自定义 Server 的各种属性</span></span><br><span class="line">        Handler: mux,</span><br><span class="line">        Addr: <span class="string">":8086"</span>,</span><br><span class="line">        ReadTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">        WriteTimeout: <span class="number">2</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line">    server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搞搞中间件"><a href="#搞搞中间件" class="headerlink" title="搞搞中间件"></a>搞搞中间件</h2><p>既然 handler 处理器负责对请求构建响应，而函数在 go 中又是所谓“一等公民”（可以被赋值与返回），那么我们可以对它做点文章。比如在一个处理器之外再包一层逻辑形成一个有额外行为的新处理器。</p>
<p>例如，只要我们实现了签名为 <code>func(Handler) Handler</code> 的函数，就可以额外实现一层逻辑，比如打印响应到来的时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprint(w, <span class="string">"hello world!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    timeLog := <span class="function"><span class="keyword">func</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">        <span class="comment">// 构建一个新的处理器，里面包含原处理器</span></span><br><span class="line">        <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">            log.Printf( <span class="string">"handling the request at: %v"</span>,  time.Now())</span><br><span class="line">            next.ServeHTTP(writer, request)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    http.Handle(<span class="string">"/hello"</span>, timeLog(http.HandlerFunc(hello)))</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/03/http包——go网络服务的第一步/" data-id="ckoqt9nsp000cb0up2l4mq2ct" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-channel-Go的传声筒" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/06/01/channel-Go的传声筒/">Go底层大冒险之channel</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/01/channel-Go的传声筒/" class="article-date">
  <time datetime="2020-06-01T06:54:30.000Z" itemprop="datePublished">2020-06-01</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>得益于 goroutine 的设计，Go 在执行并发任务是可谓是得心应手。既然存在并发，就必然牵扯到多任务同步的问题。当然，我们可以直接用共享内存来通信（如共享变量），但是 Go 的设计哲学中有一句话叫做<code>不要用共享内存来通信，而是用通信共享内存</code>。利用内置的 channel 结构体在多个 goroutine 间通信是更安全也是更被推崇的。</p>
<p>channel 在 runtime 中用 <code>hchan</code>  结构体表示，每次创建 channel 都是创建了一个这样的结构体:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span> <span class="comment">// channel 中元素个数</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span> <span class="comment">// channel 中循环队列长度</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// channel 的缓冲区数据指针</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span> <span class="comment">// channel 能收发的元素大小</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// channel 能够收发的元素类型</span></span><br><span class="line">    sendx    <span class="keyword">uint</span> <span class="comment">// 缓冲过区中 channel 的发送操作处理到的位置</span></span><br><span class="line">    recvx    <span class="keyword">uint</span> <span class="comment">// 缓冲区中 channel 的接收操作处理到的位置</span></span><br><span class="line">    recvq    waitq <span class="comment">// 阻塞在这个 hchan 上的接收 goroutine 队列</span></span><br><span class="line">    sendq    waitq <span class="comment">// 阻塞在这个 hchan 上的发送 goroutine 队列</span></span><br><span class="line"></span><br><span class="line">    lock mutex <span class="comment">// 解决可能的线程竞争问题，也就是说 channel 是线程安全的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next     *sudog <span class="comment">// 下一个 sudog</span></span><br><span class="line">    prev     *sudog <span class="comment">// 上一个 sudong</span></span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// 指向数据</span></span><br><span class="line">    c        *hchan <span class="comment">// 属于哪个 channel</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向-Channel-发送"><a href="#向-Channel-发送" class="headerlink" title="向 Channel 发送"></a>向 Channel 发送</h2><p>函数 <code>runtime.chansend</code> 负责向 channel 发送数据的全部逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止发生竞争条件。如果 Channel 已经关闭，那么向该 Channel 发送数据时就会报”send on closed channel” 错误并中止程序。整个函数的执行过程可分为三部分：</p>
<ol>
<li>存在等待的接收者时，把数据直接发送给阻塞的接收者</li>
<li>存在可用缓冲区时，把数据写入缓冲区</li>
<li>不存在缓冲区或缓冲区已满时，等待其它 goroutine 从该 channel 接收数据</li>
</ol>
<h3 id="直接发送"><a href="#直接发送" class="headerlink" title="直接发送"></a>直接发送</h3><p>如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，那么 runtime.chansend 函数会从接收队列 recvq 中取出最先陷入等待的 Goroutine 并直接向它发送数据:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送数据时调用 <code>runtime.send</code> 函数，该函数的执行可以分成两个部分：</p>
<ol>
<li>将发送的数据直接拷贝到 x = &lt;-c 表达式中变量 x 所在的内存地址上</li>
<li>将等待接收数据的 Goroutine 标记成可运行状态 Grunnable 并把该 Goroutine 放到发送方所在的处理器的 runnext 上等待执行</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        sendDirect(c.elemtype, sg, ep) <span class="comment">// 直接把数据拷贝到接收 goroutine 对应变量的内存地址</span></span><br><span class="line">        sg.elem = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlock()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    goready(gp, skip+<span class="number">1</span>) <span class="comment">// 改变接收 goroutine 的状态，放入处理器 runnext 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送到缓冲区"><a href="#发送到缓冲区" class="headerlink" title="发送到缓冲区"></a>发送到缓冲区</h3><p>如果创建的 Channel 包含缓冲区并且 channel 中的数据没有装满，chansend 就会执行下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        qp := chanbuf(c, c.sendx) <span class="comment">// 计算出缓冲区下一个可用位置</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, ep) <span class="comment">// 发送数据到缓冲区</span></span><br><span class="line">        c.sendx++ <span class="comment">// 更新缓冲区指针</span></span><br><span class="line">        <span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="number">0</span> <span class="comment">// 缓冲区是一个循环队列，如果满了就指向队头</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++ <span class="comment">// 更新缓冲区计数</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞发送"><a href="#阻塞发送" class="headerlink" title="阻塞发送"></a>阻塞发送</h3><p>如果 channel 上没有等待接收的 goroutine 或缓冲区不可用，当前发送数据的 goroutine 会被阻塞并加入 channel 的发送队列。chansend 会执行下面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gp := getg() <span class="comment">// 获得当前尝试向 channel 发送数据的 Goroutine</span></span><br><span class="line">    mysg := acquireSudog() <span class="comment">// 获取一个 sudog 结构体并设置相关的属性</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg <span class="comment">// 表示当前 Goroutine 等待在 sudog 上</span></span><br><span class="line">    c.sendq.enqueue(mysg) <span class="comment">// 将准备好的 sudog 加入 channel 的发送队列</span></span><br><span class="line">    goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>) <span class="comment">// 将当前 Goroutine 陷入沉睡并等待唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些清空属性的收尾工作</span></span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>使用 <code>ch &lt;- i</code> 向一个 channel 发送数据时：</p>
<ol>
<li>如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 sendx 所在的位置上；</li>
<li>如果不满足上面的两种情况，就会创建一个 runtime.sudog 结构并将其加入 Channel 的 sendq 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据</li>
</ol>
<p>发送过程中，2 个时机会触发 Goroutine 调度：</p>
<ol>
<li>发送数据时发现 channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 runnext 属性，但是并不会立刻触发调度</li>
<li>发送数据时并没有找到接收方并且缓冲区已经满了，这时就会将自己加入 Channel 的 sendq 队列并调用 runtime.goparkunlock 触发 Goroutine 的调度让出处理器的使用权</li>
</ol>
<h2 id="从-Channel-接收"><a href="#从-Channel-接收" class="headerlink" title="从 Channel 接收"></a>从 Channel 接收</h2><p>使用 <code>i &lt;- ch</code> 或 <code>i, ok &lt;- ch</code> 都可以从 channel 接收数据，不同方法在 runtime 最后都是调用 <code>runtime.chanrecv</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123; <span class="comment">// channel 为空（未创建对象）</span></span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂起当前 goroutien</span></span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123; <span class="comment">// 如果 channel 已经关闭并且缓冲区没有数据，直接返回</span></span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemclr(c.elemtype, ep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞接收"><a href="#非阻塞接收" class="headerlink" title="非阻塞接收"></a>非阻塞接收</h3><p>当 Channel 的 sendq 队列中包含处于等待状态的 Goroutine 时，该函数会取出队列头等待的 Goroutine，处理的逻辑和发送时相差无几。</p>
<ul>
<li>如果 channel 不存在缓冲区：将 channel 发送队列 sendq 中 Goroutine 存储的 elem 数据拷贝到目标内存地址中；</li>
<li>如果 channel 存在缓冲区：<ol>
<li>将 recvx 指向的缓冲区的数据拷贝到接收方的内存地址</li>
<li>将发送队列 sendq 头的 sudog 中数据拷贝到缓冲区，释放一个阻塞的发送方<br><img src="https://i.loli.net/2020/05/25/13WoPzZrpjmYEnh.png" alt="存在缓冲区"></li>
</ol>
</li>
</ul>
<p>无论发生哪种情况，运行时都会调用 runtime.goready 函数将当前处理器的 runnext 设置成发送数据的 Goroutine，在调度器下一次调度时将阻塞的发送方唤醒。</p>
<h3 id="阻塞接收"><a href="#阻塞接收" class="headerlink" title="阻塞接收"></a>阻塞接收</h3><p>当 channel 的发送队列中不存在等待的 Goroutine 并且缓冲区中也不存在任何数据时，从管道中接收数据的操作会变成阻塞操作。当前请求接收的 Goroutine 会被包装成一个 sudog 放入该 channel 的接收等待队列 recvq，然后触发调度。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>从 channel 中接收数据，可能有以下 5 中情况：</p>
<ol>
<li>如果 Channel 为空，那么就会直接调用 runtime.gopark 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 函数会直接返回；</li>
<li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，就会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据就会直接读取 recvx 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；</li>
</ol>
<p>接收过程中，2 个过程会触发 goroutine 调度：</p>
<ol>
<li>channel 为空</li>
<li>缓冲区中不存在数据并且也不存在数据的发送者</li>
</ol>
<h2 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h2><p>close 一个已被关闭的 channel 会导致 panic。正常情况下，<br>runtime 会清空所有 sudog 上的数据 elem，并把阻塞在这个 channel 上的 goroutine （revq 和 sendq 上的）加入调度队列触发调度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/01/channel-Go的传声筒/" data-id="ckoqt9nuj000yb0upisgjy47m" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-Vim-从入门到放弃" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/05/22/Vim-从入门到放弃/">Vim 从入门到放弃</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/22/Vim-从入门到放弃/" class="article-date">
  <time datetime="2020-05-22T15:17:28.000Z" itemprop="datePublished">2020-05-22</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/开发工具/">开发工具</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>如果问世界上最强大的语言是什么？答案或许有很多，但是如果问世界上最强大的编辑器是什么，恐怕很多人都回答都是 Vim。笔者从入门编程的第一天开始就听说了 Vim 的大名，然而苦于一大堆眼花缭乱的命令，屡屡尝试最后都是无疾而终。最近决心一定要把玩意儿入门了，于是开始跟着官方 tutorial 学习。打开中文版官方 tutorial 命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor zh</span><br></pre></td></tr></table></figure>
<p>大部分 Vim 命令都可以看作三部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator [number] motion</span><br></pre></td></tr></table></figure>
<p>operator 是要执行的操作（删除、修改等），number 代表该操作重复的次数，motion 是以什么格式作为操作单位（w 代表单词，$ 代表行末等）</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>Vim 使用 h、j、k、l 四个键是光标在左、下、上、右间移动（当然，直接使用光标键也可以）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     ^</span><br><span class="line">     k</span><br><span class="line">&lt;h       l&gt;</span><br><span class="line">     j</span><br><span class="line">     v</span><br></pre></td></tr></table></figure>
<p>光标在行内移动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#w：从当前位置起移动到下 # 个单词的头部</span><br><span class="line"></span><br><span class="line">#b：#w 的逆操作</span><br><span class="line"></span><br><span class="line">#e：从当前位置其移动到第 # 个单词的尾部</span><br><span class="line"></span><br><span class="line">$：移动到当前行尾部</span><br><span class="line"></span><br><span class="line">0：移动到当前行头部</span><br><span class="line"></span><br><span class="line">fPattern：正向跳转到 Pattern 字符</span><br><span class="line"></span><br><span class="line">tPattern：反向跳转到 Pattern 字符</span><br><span class="line"></span><br><span class="line">%：如果当前位置是 (、)、[、]、&#123;、&#125;，将光标移动到配对的括号上</span><br><span class="line">G：移动到文件末尾</span><br><span class="line"></span><br><span class="line">gg：移动到文件头</span><br><span class="line"></span><br><span class="line">#G：移动到文件的第 # 行</span><br><span class="line"></span><br><span class="line">ctrl+G：显示光标在文件中的位置信息</span><br><span class="line"></span><br><span class="line">ctrl+o：移动到早前光标所在位置（o 表示 older）</span><br><span class="line"></span><br><span class="line">ctrl+i：ctrl+o 的逆操作（i 在 o 的前面）</span><br></pre></td></tr></table></figure>
<p>除了主动移动外，有时需要在文件中根据模式进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/Pattern：Pattern 表示模式，/ 表示向下搜索</span><br><span class="line"></span><br><span class="line">?Pattern：? 表示向上搜索</span><br><span class="line"></span><br><span class="line">执行搜索操作后，n 表示继续搜索，N 表示反方向搜索</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当然可以进入 insert 模式后按下 Backspace 进行删除，这里讨论的是如何在 normal 模式下删除：</p>
<p><code>d</code> 是一个 operator，表示删除（delete）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x： 删除当前光标所在字符</span><br><span class="line">d#w or d#e or d#$ or d#0：d 表示删除操作，w、e、$、0 表示不同操作单位，# 表示重复次数</span><br><span class="line">dd：删除当前行</span><br><span class="line">#dd：删除 # 行</span><br><span class="line">dfPatern：从当前位置删除到 Pattern 字符</span><br><span class="line">di&quot;：删除双引号 &quot;&quot; 里面的内容</span><br><span class="line">da&quot;：删除双引号 &quot;&quot; 及其里面的内容</span><br><span class="line">shift+d：相当于 d$</span><br><span class="line">shift+s：相当于 dd</span><br><span class="line">J：相当于 dd</span><br></pre></td></tr></table></figure>
<p>有修改就有撤销：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u：撤销上次一命令</span><br><span class="line">U：恢复本行的原始状态（撤销作用在本行的命令）</span><br><span class="line">ctrl+R：u 的逆操作</span><br></pre></td></tr></table></figure>
<h2 id="复制-amp-粘贴"><a href="#复制-amp-粘贴" class="headerlink" title="复制&amp;粘贴"></a>复制&amp;粘贴</h2><p><code>y</code> 是一个 operator，表示复制（copy）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#yy：复制 # 行</span><br><span class="line"></span><br><span class="line">y#w or y#e or y#$ or y#0：y 表示复制操作，w、e、$、0 表示不同操作单位，# 表示重复次数</span><br><span class="line"></span><br><span class="line">v 进入 visual 模式，然后用移动键（h、j、k、l）进行选择</span><br><span class="line">被选中的区域可以进行批量 d、y 操作。</span><br></pre></td></tr></table></figure>
<p>删除操作删掉的数据会保存在 vim 的缓存中，用如下命令把上一次删除的数据复制到相应位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#p：复制 # 次，如果被删除数据是一整行那么在光标的下一行插入</span><br></pre></td></tr></table></figure>
<h2 id="插入-amp-替换"><a href="#插入-amp-替换" class="headerlink" title="插入&amp;替换"></a>插入&amp;替换</h2><p>在行的指定区域进入 insert 模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A：光标移到行末并进入 insert 模式</span><br><span class="line"></span><br><span class="line">a：在光标后边进入 insert 模式</span><br></pre></td></tr></table></figure>
<p>在 normal 模式下对光标指向的字符进行替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rnew：当前字符替换为 new</span><br><span class="line"></span><br><span class="line">Rnew：连续替换多个字符，类似于原地直接修改</span><br></pre></td></tr></table></figure>
<p>如果单个字符修改不够用，可以一次修改更多。<code>c</code> 是一个 operator，表示修改（change）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c#w or c#e or c#$ or c#0：改变从当前位置到指定位置的所有文本，会自动进入 insert 模式</span><br></pre></td></tr></table></figure>
<p>对文本中符合模式的字符串进行替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:s/old/new&lt;回车&gt; 替换当前行第一个匹配项 </span><br><span class="line"></span><br><span class="line">:s/old/new/g 替换当前行所有匹配项 </span><br><span class="line"></span><br><span class="line">:#,#s/old/new/g 替换 # 到 # 行所有的匹配项</span><br><span class="line"></span><br><span class="line">:%s/old/new/g 替换文本中每个匹配项</span><br><span class="line"></span><br><span class="line">:%s/old/new/gc 文本中每个匹配项都提示是否进行替换</span><br></pre></td></tr></table></figure>
<p>插入空行并进入 insert 模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o：在下一行插入空行</span><br><span class="line"></span><br><span class="line">O：在上一行插入空行</span><br></pre></td></tr></table></figure>
<h2 id="保存操作"><a href="#保存操作" class="headerlink" title="保存操作"></a>保存操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:!command：执行 command，即使有命令行参数也可以这么操作</span><br><span class="line"></span><br><span class="line">:w FILENAME 把文件另存为 FILEMNAME</span><br><span class="line"></span><br><span class="line">v 进入 visual 模式，选择相应文本后用 :w FILENAME 把选择的文本另存为 FILENAME</span><br><span class="line"></span><br><span class="line">:r FILENAME 把文件 FILENAME 内容插入到光标之后</span><br><span class="line"></span><br><span class="line">:r !command 把 command 的输出插入到光标之后</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/22/Vim-从入门到放弃/" data-id="ckoqt9nsk000ab0up6jyzm77t" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/">Vim</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-调度器—Go语言的大管家" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/04/27/调度器—Go语言的大管家/">Go底层大冒险之调度器</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/27/调度器—Go语言的大管家/" class="article-date">
  <time datetime="2020-04-27T08:41:26.000Z" itemprop="datePublished">2020-04-27</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源，每一次线程上下文的切换都需要消耗 1us 左右的时间。而 Go 调度器对 Goroutine 的上下文切换约为 0.2us，减少了 80% 的额外开销</p>
<p>Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>调度器的三个组成部分：G(Goroutine)，P(处理器)，M(线程)</p>
<ul>
<li>G：代表 Goroutine，是一个待执行的任务</li>
<li>P：代表处理器，相当于一个与线程绑定的小型调度器</li>
<li>M：代表操作系统线程</li>
</ul>
<p><img src="https://i.loli.net/2020/04/26/F617HYhRtfTrJlM.png" alt="GMP模型"></p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>Gorotuine 就是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 表现为私有结构体 g，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack stack <span class="comment">// 栈内存范围</span></span><br><span class="line">    preempt <span class="keyword">bool</span> <span class="comment">// 抢占信号</span></span><br><span class="line">    _panic *_panic <span class="comment">// 存储 panic 结构体的链表</span></span><br><span class="line">    _defer *_defer <span class="comment">// 存储 defer 结构体的链表</span></span><br><span class="line">    m *m <span class="comment">// 当前占用线程</span></span><br><span class="line">    sched gobuf <span class="comment">// 与 Goroutine 调度相关的数据</span></span><br><span class="line">    atomicstatus <span class="keyword">uint32</span> <span class="comment">// Goroutine 的状态</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sched</code> 字段对 Goroutine 的调度至关重要：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">    pc <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">    g guintptr <span class="comment">// 持有这个 gobuf 的 Goroutine</span></span><br><span class="line">    ret sys.Uintreg <span class="comment">// 系统调用的返回值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Goroutine 的状态可分为三类：等待中、可运行、运行中</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态</li>
<li>运行时：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code></li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code></li>
</ul>
<!-- ![Goroutine状态](https://i.loli.net/2020/04/26/HYZyCRmugW4XA8K.png) -->
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，这样不会触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少非常多的额外开销。我们也可以使用 runtime.GOMAXPROCS 来改变程序中最大的线程数。</p>
<p><img src="https://i.loli.net/2020/04/26/ihSrwOGqjRa3mCo.png" alt="M与CPU"></p>
<p>线程表现为私有结构体 m，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0 *g <span class="comment">// 持有调度栈的 goroutine，深度参与 goroutine 的创建过程</span></span><br><span class="line">    curg *g <span class="comment">// 当前线程持有的 goroutine</span></span><br><span class="line">    p puintptr <span class="comment">// 正在运行的调度器</span></span><br><span class="line">    nextp puintptr <span class="comment">// 备用调度器</span></span><br><span class="line">    oldp puintptr <span class="comment">// 之前使用的调度器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时切换，提高线程的利用率。</p>
<p>调度器在启动时就会创建 GOMAXPROCS 个处理器，即处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上并利用线程的计算资源运行 Goroutine。</p>
<p>处理器表现为私有结构体 p，下面是一些比较重要的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    status <span class="keyword">uint32</span> <span class="comment">// 处理器状态</span></span><br><span class="line">    m muintptr <span class="comment">// 当前绑定的线程</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span> <span class="comment">// 等待队列队头</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span> <span class="comment">// 等待队列队尾</span></span><br><span class="line">    runq [<span class="number">256</span>]guintptr <span class="comment">// 等待队列</span></span><br><span class="line">    runnext guintptr <span class="comment">// 下一个需要执行的 goroutine</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/26/TaxLscAnwlDZq7m.png" alt="GMP三者关系"></p>
<h2 id="创建-Goroutine"><a href="#创建-Goroutine" class="headerlink" title="创建 Goroutine"></a>创建 Goroutine</h2><p><code>go</code> 关键字会被转换为 <code>runtime.newproc</code>，该函数会接收大小和表示函数的指针:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">    gp := getg()</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runtime.newproc1</code> 根据入参初始化一个 <code>g</code>，该函数的行为可分为：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体：从处理器的 <code>gFree</code> 列表得到一个空闲的 g。如果获取失败则创建一个新的 g</li>
<li>将传入的参数移到 Goroutine 的栈上：将 fn 的参数全部压栈</li>
<li>更新 Goroutine 调度相关的属性：设置新 g 的 sp、pc并更新其状态到 <code>_Grunnable</code></li>
<li>将 Goroutine 加入运行队列 runq：Go 语言中有两个运行队列，一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列<br><img src="https://i.loli.net/2020/04/27/1bVMsIOvXk3Dlx7.png" alt="运行队列"></li>
</ol>
<h2 id="触发调度"><a href="#触发调度" class="headerlink" title="触发调度"></a>触发调度</h2><ul>
<li><p>主动挂起：当 goroutine 陷入休眠（如 <code>time.sleep</code>）或阻塞在一次 chan 操作时，goroutine 触发主动挂起。主动挂起会将当前 goroutine 暂停。调度器把 goroutine 状态设为 <code>_Gwaiting</code> 并<strong>解除 goroutine 与线程的绑定</strong>（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程。当主动挂起的 goroutine 满足特定条件后，运行时将其状态设为 <code>_Grunnable</code> 并放到运行队列等待调度。</p>
</li>
<li><p>系统调用：当 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并<strong>解除线程和处理器的绑定</strong>（相当于让出处理器，这样处理器就可以绑定到其它线程上。原线程陷入系统调用等待返回。这个过程触发一次线程切换的系统调用）。系统调用结束后，为这个 goroutine 重新分配资源并更新其状态为 <code>_Grunnable</code>，找到一个可用的处理器与这个 goroutine 绑定。</p>
</li>
</ul>
<p>下面这段代码示范了运行时在主动挂起和系统调用时进行协程调度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">improt (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    sched := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    loopCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-sched:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    loopCount += <span class="number">1</span></span><br><span class="line">                    fmt.Printf(<span class="string">"loop %d\n"</span>, loopCount) <span class="comment">// Printf 属于 IO，可能会阻塞然后触发调度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sched &lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 主动阻塞在一次 channel 操作上，触发调度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反复执行这段程序会发现输出结果不唯一，因为 <code>fmt.Printf</code> 操作具体什么时候阻塞是说不准的。但只要有 loop 被打印出来，可以肯定发生了两次调度：一次由 chan 发送操作导致，一次由 IO 操作导致。</p>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>总结起来三个特点：多线程、任务窃取、抢占式：</p>
<ol>
<li>多线程：进程中可以同时存在多个活跃线程。多线程调度器引入了 GOMAXPROCS 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数</li>
<li>任务窃取：进行 goroutine 调度时，调度器会先从当前处理器或全局待运行队列中获得一个 goroutine；如果获取失败，则从其它处理器的待运行队列中随机获取 goroutine</li>
<li>抢占式：STW 和栈扫描时会触发抢占。当前 goroutine 被设为 _Gpreempted，调度器进行一次 goroutine 调度</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/27/调度器—Go语言的大管家/" data-id="ckoqt9nt9000qb0upmyy1z56o" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-网络IO" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/04/17/网络IO/">网络IO</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/17/网络IO/" class="article-date">
  <time datetime="2020-04-17T15:17:38.000Z" itemprop="datePublished">2020-04-17</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h1><p>计算机之间可以通信，本质上也是计算机进程相互通信。为了方便不同终端进行通信，网络协议栈抽象出socket层，通过对socket文件描述符的操作来进行网络IO。当然，不同的应用场景，衍生出了不同的网络模型</p>
<h2 id="一次网络响应"><a href="#一次网络响应" class="headerlink" title="一次网络响应"></a>一次网络响应</h2><p>互联网应用中，多数架构是 CS 模式，即 client 发出请求，server 接受请求，处理之后返回响应。这样的一次交互，伴随着 client 和 server 的 IO 操作。</p>
<p>一次简单的交互，往往涉及网络 IO 和磁盘文件 IO。大致流程如图：</p>
<p><img src="https://i.loli.net/2020/04/17/jMxUNO7ltuwgRTX.png" alt="一次IO"></p>
<p>对 Server 而言，处理响应的过程如下：</p>
<ol>
<li>Server 的进程发起 Read 系统调用，内核随即从硬件 Disk 读取数据到内核缓冲区（kernel buf）</li>
<li>内核把 kernel buf 的数据 copy 到应用程序进程的缓冲区，应用程序就可以对数据进行修改。</li>
<li>应用进程将数据通过系统调用 Send 发送到 socket 缓冲区，每个 socket 文件都在内核维护了一个发送/接受缓冲区。</li>
<li>最后再把 socket 发送缓冲区的数据 copy 到 NIC 网卡中，通过协议栈发送到Client 的网卡。</li>
</ol>
<p>所谓的IO，就是将硬件（磁盘、网卡）的数据读取到程序的内存中。</p>
<p>因为应用程序很少可以直接和硬件交互，因此操作系统作为两者的桥梁。通常操作系统在对接两端（应用程序与硬件）时，自身有一个内核 buf，用于数据的 copy 中转。</p>
<p><img src="https://i.loli.net/2020/04/17/lJoTNEzbcdejuFt.png" alt="硬件、内核、应用"></p>
<p>一般网络 IO 分为两个阶段：</p>
<ol>
<li>等待数据阶段。数据通过协议栈发送到网卡，网卡再通过 DMA copy 到 kernel buf</li>
<li>拷贝数据阶段。将 kernel buf 的数据 copy 到 app buf 中。</li>
</ol>
<h2 id="Linux-5-种-IO-模型"><a href="#Linux-5-种-IO-模型" class="headerlink" title="Linux 5 种 IO 模型"></a>Linux 5 种 IO 模型</h2><h3 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h3><p>所谓阻塞 IO 指在网络 IO 的两个阶段进程都会阻塞。</p>
<p><img src="https://i.loli.net/2020/04/17/WoMVpI9X72KzcGN.png" alt="阻塞IO"></p>
<p>进程对象发起 Recv 操作，这是一个系统调用，然后内核会看 kernel buf 是否有数据，如果没有数据，那么进程将会被挂起，直到 kernek buf 从硬件或者网络读取到数据之后，内核再把数据从 kernel buf copy 到 app buf中，然后唤醒发起调用的进程，并且 Recv 操作将会返回数据。接下来进行可以对进程 buf 的数据进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sock.accept() <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">    print(<span class="string">'client &#123;&#125; connect'</span>.format(conn.fileno()))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>) <span class="comment"># 进程会阻塞直至有数据返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'client &#123;&#125; closed'</span>.format(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'data is '</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h3><p>当进程把一个文件描述符设置成非阻塞时，执行 read 和 write 等 I/O 操作就会立刻返回。在 C 语言中，我们可以使用如下所示的代码片段将一个文件描述符设置成非阻塞的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<p>如果没有数据，发起的 IO 系统调用会马上返回一个 <code>EWOULDBLOCK</code> 错误。函数返回之后，进程没有被挂起，可以继续做别的。</p>
<p><img src="https://i.loli.net/2020/04/17/6yAJMt5CG4dRj2Z.png" alt="非阻塞IO"></p>
<p>进程获得了 EWOULDBLOCK 之后会再次发起非阻塞 IO 请求，这个过程还是会使用 CPU，因此也称之为轮询（polling）。然而此时应用程序可以对读取操作系统缓冲区中的数据并进行操作。换言之进程使用非阻塞 I/O 时可以在等待过程中执行其他的任务。</p>
<p>内核有数据的时候，内核将 kernel buf 的数据 copy 到 app buf 的过程还是需要 cpu 参与，对于非阻塞 IO 来说，这个过程仍然是阻塞的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"></span><br><span class="line">address = (<span class="string">''</span>, <span class="number">5000</span>)</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">sock.bind(address)</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 获得 EWOULDBLOCK 错误，轮询</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'client &#123;&#125; connect'</span>.format(conn.fileno()))</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>) <span class="comment"># 将 socket 设置为非阻塞的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 轮询</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.args[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            print(<span class="string">'client &#123;&#125; closed'</span>.format(conn.fileno()))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'data is '</span>, data)</span><br><span class="line">            conn.sendall(data)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<h3 id="多路复用-IO"><a href="#多路复用-IO" class="headerlink" title="多路复用 IO"></a>多路复用 IO</h3><p>阻塞 IO 会让线程挂起。非阻塞 IO 需要一直做 polling，每一次 polling 都会做系统调用，某种程度下，非阻塞 IO 的性能将还不如阻塞 IO。既然需要内核频繁操作，那么就有人想出了新的模型：让内核代理去做轮询，然后应用进程只有数据准备了再发起 IO 操作不就好了吗？</p>
<p>多路复用 IO 就是这样的原理，所谓“多路复用”是指一个线程复用多个 socket。由内核负责监控应用指定的 socket 文件描述符，socket 准备好（可读，可写，异常等）时，通知应用进程。“准备好”是一个事件，当事件发生，通知应用进程，而应用进程可以执行事先注册的对应该事件的回调函数。有大量事件发生的前提下，多用复用 IO 可以极大提高服务器并发性能。</p>
<blockquote>
<p>多路复用 IO = 多路监听 + 阻塞/非阻塞 IO。多路监听指的是下文的 select/poll/epoll 等监听系统，这些系统监听的 socket 则负责 IO。</p>
</blockquote>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 系统调用提供一个机制来实现同步 IO：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/05/30/fMzL5wP7vETWpC6.png" alt="select模型g"></p>
<p>调用 select 将导致阻塞直到指定的文件描述符准备好执行 IO，或者可选参数 timeout 指定的时间已经过去。</p>
<p>select 成功返回时，返回值是 ready 状态的 fd 数目。每组 set 都被修改以使它只包含准备好 IO 的文件描述符。</p>
<p>例如，假设有两个 fd 分别是 7 和 9 被放在 readfds。select 返回后，应用进程需要遍历 readfds，判断其中每一个 fd 的状态，如果 7 发生读事件而 9 没有，那么对 7 读不会阻塞，对 9 读可能阻塞（”可能”是因为数据或许正好在 select 返回后就可用，这种情况下，下一次调用 select 将返回 9）。</p>
<p><strong>因为 fd_set 是静态创建的，它们对 fd 的最大数目强加了一个限制，能够放进 set 中的 fd 的数量由在 32 位机默认是 1024，64位机默认是2048。</strong></p>
<p>缺点：</p>
<ol>
<li>单进程可以打开 fd 有限制；</li>
<li>对得到的 fd_set 进行线性扫描，即采用轮询的方法，效率较低；</li>
<li>包含大量 fd 的数组在用户态和内核态的地址空间反复复制，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，也需要反复在用户态和内核态之间复制结构体，但是 poll 采用链表的方式替换原有 fd_set，使其<strong>没有连接数的限制</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;             <span class="comment">/* 文件描述符 */</span></span><br><span class="line">short events;       <span class="comment">/* 期望的事件 */</span></span><br><span class="line">short revents;      <span class="comment">/* 实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个 pollfd 指定一个被监视的 fd。传递一个 pollfd 链表指示 poll 监视多个 fd。每个结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域。revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>设想一下如下场景：有 100 万个客户端同时与一个服务器进程保持着 TCP 连接。而每一时刻，通常只有几百上千个 TCP 连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在 select/poll 时代，服务器进程每次都把这 100 万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll 一般只能处理几千的并发连接。</p>
<p>epoll 是是之前的 select/poll 的增强版本。相比 select/poll，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p>
<p>epoll 提供三个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll的事件注册函数，注册要监听的事件类型。</span></span><br><span class="line"><span class="comment">第一个参数是 epoll_create()的返回值；</span></span><br><span class="line"><span class="comment">第二个参数表示动作，用三个宏来表示：EPOLL_CTL_ADD，EPOLL_CTL_MOD，EPOLL_CTL_DEL；</span></span><br><span class="line"><span class="comment">第三个参数是需要监听的 fd；</span></span><br><span class="line"><span class="comment">第四个参数是告诉内核需要监听什么事 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一步：epoll_create 系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。</p>
<p>第二步：epoll_ctl 系统调用。通过此调用向 epoll 对象中添加、删除、修改感兴趣的事件，返回 0 表示成功，返回 -1 表示失败。</p>
<p>第三部：epoll_wait 系统调用。通过此调用收集收集在 epoll 监控中已经发生的事件。</p>
<p><strong>下面来看看 epoll 是怎么实现的：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span></span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每次调用 epoll_create 方法，内核创建一个 eventpoll 结构体，用于存放通过 epoll_ctl 方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来。</p>
<p>所有添加到 epoll 中的事件都会与设备(网卡等)建立回调关系。也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫 ep_poll_callback，它会将发生的事件添加到 rdlist 双链表中。</p>
<p>每一个事件都会创建一个对应的 epitem 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span>  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 epoll_wait 检查是否有事件发生时，只需要检查 eventpoll 对象中的 rdlist 双链表中是否有 epitem 元素即可。如果 rdlist 不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户:</p>
<p><img src="https://i.loli.net/2020/04/24/ZVMg1j5dHoRU6Bf.png" alt="Epoll实现"></p>
<p>优点：</p>
<ol>
<li>支持一个进程持有大数目的 fd。epoll 底层用红黑树管理 fd，所支持的 fd 上限是最大可以打开文件的数目。</li>
<li>IO 效率不随 fd 数目增加而线性下降。举个例子：传统的 select/poll 另一个致命弱点就是当你拥有一个很大的 socket 集合，任一时间只有部分 socket 处于 ready 状态。但是 select/poll 每次调用返回后都要线性扫描全部的 socket、检查所有 socket 的状态，导致效率呈现线性下降。epoll 不存在这个问题，它只会对 ready socket 进行操作。</li>
<li>epoll 对每个 fd 只会进行一次用户态到内核态的复制。</li>
</ol>
<h2 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h2><ul>
<li>水平触发（Level Triggered, LT）：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知。LT 同时支持阻塞 IO 与非阻塞 IO。在这种模式下，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。<strong>传统的 select/poll 都是采用这种模式，epoll 默认也是这种模式</strong>。</li>
<li>边缘触发（Edge Triggered, ET）：当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知。事件通知仅在被监听文件描述符的缓冲区状态在满/不满之间变化的时候才会发生一次。边缘触发需要一次性的把缓冲区的数据读完，也就是一直读直到读到 EGAIN （缓冲区为空）为止，否则在这个 fd 的内核缓冲区下一次处于满状态前无法再次获得它。因为这一点，边缘触发需要设置文件句柄为非阻塞。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平触发，就算 buf 容量不足，下次监听系统也会 fd</span></span><br><span class="line">ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘触发，读就要一次性读完，否则下次监听系统未必会再返回 fd</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (ret == EAGAIN) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>对于监听的sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上</li>
<li>对于读写的connfd，水平触发模式下，阻塞和非阻塞效果都一样</li>
<li>对于读写的connfd，边缘触发模式下，必须使用非阻塞IO，并要一次性全部读写完数据</li>
</ol>
<h2 id="信号-IO"><a href="#信号-IO" class="headerlink" title="信号 IO"></a>信号 IO</h2><p>让内核在描述符就绪时发送 SIGIO 信号通知进程。这种模型为信号驱动式 IO（signal-driven IO），和事件驱动类似，也是一种回调方式。与非阻塞方式不一样的地方是，发起了信号驱动的系统调用，进程没有挂起，可以做的事情，可是实际中，代码逻辑通常还是主循环，主循环里可能还是会阻塞。因此使用这样的 IO 的软件很少。</p>
<p>当信号返回可以读写的时候，因为还需要 cpu 将内核数据 copy 到 app buf，拷贝数据阶段毫无疑问还是阻塞的。</p>
<p><img src="https://i.loli.net/2020/04/17/73r6sTCnzG45HFN.png" alt="信号IO"></p>
<h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><p>异步是指应用与内核存在 CPU 竞争（在同步 IO 中应用都是等 kernel buf 中的数据拷贝到 app buf 后再执行的）。</p>
<p><img src="https://i.loli.net/2020/04/17/lYpgvAdNwyQuCr9.png" alt="异步IO"></p>
<p>无论是第一阶段数据准备还是第二阶段数据拷贝，发起系统调用的进程都不会被阻塞。第二阶段过程中，进程没有阻塞，那么可以抢占 CPU，而 kernel buf copy 数据到 app buf 的时候，也需要 CPU，这就造成了应用和内核进行 CPU 竞争，步调不一致了。某些情况下，其性能反而不如其他 IO 模式。使用的人也很少。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IO 即数据在 app buf、kernel buf、硬件三者之间的流动。</p>
<p>数据等待阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>阻塞：进程挂起</li>
<li>非阻塞：进程不挂起，立即返回，返回EWOULDBLOCK</li>
</ul>
<p>数据拷贝阶段根据发起 IO 请求的进程是否阻塞分为：</p>
<ul>
<li>同步：内核拷贝数据占用 CPU</li>
<li>异步：进程可能和内核竞争 CPU</li>
</ul>
<p>同步非阻塞就是十分常见的多路复用结合非阻塞IO实现的方案，也称之为事件驱动。同步有利于逻辑的书写，非阻塞有利于调用率实现并发。因此现实中更多的IO模型是多路复用IO，并且在发展过程中，select，poll和epoll是逐步进化链。epoll实现了内核级数据结构优化，在实际性能上又了很大的提升。</p>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/e62f0ef9629d" target="_blank" rel="noopener">简明网络IO</a></p>
<p><a href="https://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">select、poll、epoll之间的区别总结</a></p>
<p><a href="https://blog.csdn.net/cuiyifang/article/details/7957937" target="_blank" rel="noopener">epoll简介及例子</a></p>
<p><a href="https://blog.csdn.net/u011063112/article/details/81771440" target="_blank" rel="noopener">epoll详解</a></p>
<p><a href="https://www.cnblogs.com/yorkyang/p/7688865.html" target="_blank" rel="noopener">epoll的水平触发与边缘触发</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/17/网络IO/" data-id="ckoqt9nwi0030b0ups6d0ostx" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-并发编程-以Go为例" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/03/24/并发编程-以Go为例/">并发编程-以 Go 为例</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/24/并发编程-以Go为例/" class="article-date">
  <time datetime="2020-03-24T15:49:51.000Z" itemprop="datePublished">2020-03-24</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>所谓<code>并发</code>(concurrency) 是指几段程序在同一时间段内交错执行，当我们无法肯定一个事件一定会会先于另一个事件发生，那么就可以说这几个时间是“并发”的。如果一个函数在并发调用时仍能正确执行，这个函数就是<code>并发安全</code>的；如果一个类型的所有可访问方法和操作都是并发安全的，则它就是一个并发安全的类型。</p>
<p>本文主要介绍了几种并发编程中常见的问题及对策，所有的例子都会用 Go 语言来描述，还会涉及到一些 Go 对并发编程的支持。</p>
<h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>竞态是指多个 goroutine 并发执行时，程序无法给出正确结果。比如多个 goroutine 同时修改了一个包级别变量的值，那么很可能导致某一个 goroutine 的修改对另一个 goroutine 不可见：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">100</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        amount += <span class="number">200</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码执行以后，balance 有几种可能取值：300，200，100。程序中的这种状态称为<code>数据竞态</code>，是竞态的一种。数据竞态发生在多个 goroutine 并发读写同一个变量并且至少一个为写操作的时候。</p>
<p>有三种方法可以避免数据竞态：</p>
<ol>
<li>不对变量做写操作。如果没有 goroutine 对变量的值进行修改，那么数据竞态自然无从说起。</li>
<li>避免多个 goroutine 对一个变量进行访问。简言之就是这个变量的所有操作都在一个<code>监控 goroutine</code> 内执行，由于一个 goroutine 内的结果是<code>串行一致</code>的，也就不会产生修改不可见的问题。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接写 amount</span></span><br><span class="line"><span class="keyword">var</span> balance = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 其它 goroutine 通过这个通道间接读 amount</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> monitor()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">0</span> <span class="comment">// amount 被限制在 monitor goroutine 中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> count := &lt;- deposit:</span><br><span class="line">                amount += count</span><br><span class="line">            <span class="keyword">case</span> balance &lt;- amount:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    deposit &lt;- count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;- balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使一个变量无法被完全限制在一个 goroutine 内，也可以把对这个变量的操作划分为好几个阶段，只要每个阶段被限制在一个 goroutine 内访问就可以了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(origin <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    book = <span class="built_in">new</span>(Book)</span><br><span class="line">    book.content = <span class="string">"hello world"</span></span><br><span class="line">    origin &lt;- book</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revise</span><span class="params">(origin &lt;- <span class="keyword">chan</span> *Book, corrected <span class="keyword">chan</span>&lt;- *Book)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> book := <span class="keyword">range</span> origin &#123;</span><br><span class="line">        book.content += <span class="string">"!"</span></span><br><span class="line">        corrected &lt;- book</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在一个时刻只允许一个 goroutine 操作这个变量。这种方法称为<code>互斥机制</code>。我们可以使用带一个缓冲的通道来实现：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> amount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> sema = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取信号量</span></span><br><span class="line">    amount += count</span><br><span class="line">    &lt;- sema <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这是一个非常简陋的实现。Go 已经为我们造好了完备的轮子：sync.Mutex。有了互斥锁，代码就可以写成这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，sync.Mutex 是“不可再入”的。</p>
<p>当读操作远多于写操作时，互斥锁会明显拖累系统的速度（最严重时只有单个 goroutine 会被执行）。读写锁 sync.RWMutex 特别适合这种场景。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    rwmu sync.RWMutex</span><br><span class="line">    amount <span class="keyword">int</span> <span class="comment">// 通常被保护变量放在锁后面声明</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    rwmu.Lock()</span><br><span class="line">    amount += count</span><br><span class="line">    rwmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rwmu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> rwmu.UnRlock()</span><br><span class="line">    <span class="keyword">return</span> amount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写锁支持四种操作：获得写锁 Lock()，释放写锁 UnLock()，获得读锁 RLock()，释放读锁 UnRLock()。</p>
<p>写锁又称为<code>排它锁（X锁）</code>：若事务 T 对数据 A 加上 X 锁，T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
<p>读锁又称为<code>共享锁（S锁）</code>：若事务 T 对 数据 A 加上 S 锁，则 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对A做任何修改。</p>
<p>写锁最多有一个，而读锁可以有多个。一个 goroutine 获得写锁后，直到这个写锁被释放前，其它 goroutine 不可以获得读锁或者写锁；一个 goroutine 获得读锁后，其它 goroutine 可以获得读锁，但是不能获得写锁。</p>
<p>如果写锁和读锁是平级的，假设当前已经上了读锁，此时一个 goroutine 的 Lock() 操作会被阻塞。而如果不断有 goroutine 获得读锁那么 Lock() 操作就会一直阻塞下去。因此，<code>写锁的优先级高于读锁</code>，即当获得写锁的请求产生以后，直到 Lock() 执行成功前所有 RLock() 操作都会阻塞。</p>
<p>对读操作上读锁，避免读到脏数据的同时又提高了资源访问速度！</p>
<p>要注意的是，go 的读写锁是通过互斥锁加上引用计数器实现的，所以除非读操作确实远远比写操作多，否则读写锁未必就比互斥锁效率高。</p>
<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p>即使是一个只包含单个操作的只读操作，上锁也是必要的。一是为了防止这个操作被插入到该变量的写操作前，二是将处理器缓存中的内容刷入内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        fmt.Print(<span class="string">"y="</span>, y, <span class="string">" "</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        fmt.Print(<span class="string">"x="</span>, x, <span class="string">" "</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 A、B 四行语句的交替执行，以上代码的如下输出是可接受的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=0 x=1 // A1-&gt;A2-&gt;B1-&gt;B2 </span><br><span class="line">y=2 x=1 // B1-&gt;A1-&gt;A2-&gt;B2</span><br><span class="line">x=0 y=2 // B1-&gt;B2-&gt;A1-&gt;A2</span><br><span class="line">x=1 y=2 // A1-&gt;B1-&gt;B2-&gt;A2</span><br></pre></td></tr></table></figure>
<p>现代计算机一般会有多个处理器，每个处理器都有自己的缓存。对变量的写操作通常不会直接写入内存，而是先记录在处理器缓存中，在操作系统认为必要的时候再刷回内存。由于处理器缓存的存在，写操作（A1 &amp;&amp; B1）可能不会立即对其它 goroutine 可见，那么其它 goroutine 就会使用过期值。此外，由于赋值语句和输出语句对应不同变量，编译器可能认为这两个语句的执行顺序是不重要的，于是私自调换了语句的执行顺序，CPU 执行指令时也可能发生指令重排，在不影响语义的前提下把后面的指令放到前面来执行。我们可能看到这样的非预期输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=0 x=0 // A2-&gt;B2-&gt;A1-&gt;B1 or A2-&gt;B2-&gt;B1-&gt;A1</span><br><span class="line">y=2 x=0 // B1-&gt;A2-&gt;B2-&gt;A1</span><br><span class="line">x=0 y=0 // B2-&gt;A2-&gt;A1-&gt;B1 or B2-&gt;A2-&gt;B1-&gt;A1</span><br><span class="line">x=1 y=0 // A1-&gt;B2-&gt;A2-&gt;B1</span><br></pre></td></tr></table></figure>
<p>此时，指令的执行顺序看起来就和代码的编写顺序不一样了。而通道通信和互斥锁这样的<strong>同步原语</strong>会强制刷回内存，并插入内存屏障（Memory Barrier）。如此一来某个 Goroutine 中指令执行顺序就对别的 Goroutine 可见了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> ok = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x = <span class="number">1</span>   <span class="comment">// A1</span></span><br><span class="line">        ok &lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">        fmt.Print(<span class="string">"y="</span>, y, <span class="string">" "</span>) <span class="comment">// A2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y = <span class="number">2</span>   <span class="comment">// B1</span></span><br><span class="line">        &lt;-ok</span><br><span class="line">        fmt.Print(<span class="string">"x="</span>, x, <span class="string">" "</span>) <span class="comment">// B2</span></span><br><span class="line">        done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- done</span><br><span class="line">    &lt;- done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/24/并发编程-以Go为例/" data-id="ckoqt9nuu0019b0upw0v6zx9z" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-也谈进程、线程与协程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/03/02/也谈进程、线程与协程/">也说进程、线程与协程</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/02/也谈进程、线程与协程/" class="article-date">
  <time datetime="2020-03-02T02:05:30.000Z" itemprop="datePublished">2020-03-02</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>CPU 被誉为“计算机的大脑”，这个比喻可以说是很恰当了。计算机无论是进行 IO 还是计算都要在 CPU 的控制下完成。如此一来，一个强大的“大脑”对于整个系统而言就是非常重要的了，这也是为什么我们总能看到厂家不断地宣传自己 CPU 的主频有多高，核心有多大。</p>
<p>要提高 CPU 的性能，最直接的方法当然是不断增强单个处理器的性能，让处理器频率更高。就像要举起一块石头，让自己变得足够强壮就可以了。</p>
<p>但是这种方法很快就受制于物理定律：当前技术条件下无限提高频率是不可能的，而且过高的频率也会导致发热量过大。因此，工程师们只好退而求其次，转而增加一个 CPU 内的处理器数量。还是要举起石头，一个人无论如何也举不起来，那多喊几个小弟帮忙总可以吧？</p>
<p>有了多核 CPU，程序就可以被划分为相对独立的几个部分，每一部分运行在不同的处理器上。当然，这样做也会带来额外的开销。如果操作系统和程序不能很好地协调多处理器，那么执行速度未必就有明显提高（乃至降低也说不定~）。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>下面给出进程的定义：</p>
<blockquote>
<p>进程是具有一定独立功能的程序在一个数据集合上的一次动态执行过程</p>
</blockquote>
<p>进程是操作系统<strong>分配资源</strong>的最小单位，拥有代码文本、被分配的系统资源、独立的虚拟内存地址、堆栈空间：</p>
<p><img src="https://i.loli.net/2020/03/02/qz7MdhlxtQmK8pI.png" alt="进程内存空间"></p>
<p>操作系统为每个进程维护了一个程序控制块（PCB, Process Contral Block），用来保存该进程的状态信息（进程标识、寄存器、打开文件资源、调度信息等）。PCB 是进程存在的唯一标识。</p>
<p><img src="https://i.loli.net/2021/01/20/Q2zIDlrHYA5sqv9.png" alt="image.png"></p>
<p>进程在整个生命周期期间处于以下五个状态之一：</p>
<ul>
<li>NULL -&gt; 创建：一个新进程被产生出来执行一个程序</li>
<li>创建 -&gt; 就绪：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态</li>
<li>就绪 -&gt; 运行：处于就绪状态的进程被进程调度程序选中后，就分配到处理机上来运行</li>
<li>运行 -&gt; 结束：当进程表示它已经完成或者因出错，当前运行进程会由操作系统作结束处理</li>
<li>运行 -&gt; 就绪：处于运行状态的进程在其运行过程中，由于分配给它的处理机时间片用完而让出处理机</li>
<li>运行 -&gt; 等待：当进程请求某资源且必须等待时</li>
<li>等待 -&gt; 就绪：当进程要等待某事件到来时，它从阻塞状态变到就绪状态</li>
</ul>
<p><img src="https://i.loli.net/2020/03/02/dY1JoNBIRLCFE4G.png" alt="进程状态"></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。一个进程可以拥有多个线程，同属一个进程的多个线程会共享该进程的内存地址空间、打开文件、代码段、全局数据段。</p>
<p>线程是进程的一部分，描述一段指令流的执行状态，是系统<strong>调度</strong>的基本单位。每个线程拥有自己的线程控制块（TCB, Thread Contral Block），保存了线程标识、从属进程、寄存器状态等信息。每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史）。</p>
<p><img src="https://i.loli.net/2020/03/02/P6MXJ5WHtQNp4x1.png" alt="线程内存空间"></p>
<p>如前面所言，程序被划分为几部分跑在不同处理器上，这些被划分出来的“部分”就可以看做一个个的线程。</p>
<h2 id="进程与线程的异同"><a href="#进程与线程的异同" class="headerlink" title="进程与线程的异同"></a>进程与线程的异同</h2><p>进程和线程的切换是 OS 通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算。每次 CPU 计算的指令数量和代码跑过的 CPU 时间是相关的，跑满 OS 分配的时间片后就会被强制挂起，开发者无法精确的控制它们。</p>
<ul>
<li>地址空间：<strong>同一进程的线程共享本进程的地址空间</strong>，而进程之间则是独立的地址空间</li>
<li>资源分配：<strong>同一进程内的线程共享本进程的资源如全局数据、打开文件、CPU</strong>等，但是进程之间的资源是独立的</li>
<li>程序入口：每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。而线程不能够独立执行，必须依存在进程中，由进程对多个线程执行控制。</li>
<li>健壮性：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程是编译器级的，进程是和线程是操作系统级的</strong>。</p>
<p>协程（Coroutine）是比线程更轻量级的存在，可以说是一种<strong>用户态线程</strong>。它更像是一个函数，只是这个函数可以像线程那样中途让出执行权，满足某种条件后又从等待的地方继续运行。</p>
<p>协程的<strong>切换策略仅由用户态控制</strong>，对于操作系统是透明的，所以协程间的切换非常快。但这也导致协程无法充分利用多核 CPU，因为协程再多，在操作系统眼里也只有一个线程在运行罢了。</p>
<p><img src="https://i.loli.net/2020/03/02/X3jbaStuZRByIdw.png" alt="协程"></p>
<p>Go 的调度器使用 m:n 调度，其中 m 是 goroutine 数，n 是活跃线程数（由 GOMAXPROCS 决定，默认等于处理器核心数）。当一个 goroutine 陷入休眠或阻塞在一次管道通信上，调度器会把它的状态设为 <code>_Gwaiting</code> 并解除它与线程的绑定（相当于让出线程，随后就可以执行一次 goroutine 调度），等待状态的 goroutine 不占用线程；而如果 goroutine 阻塞在一次 IO 或其它系统调用上调度器会更新 goroutine 状态为 <code>_Gsyscall</code> 并解除线程和处理器的绑定（相当于让出处理器，这样处理器就可以绑定到其它线程上。这个过程触发一次线程切换的系统调用）。</p>
<p>以 go 为例，在一个线程里面开启多个协程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;    <span class="comment">// 开启一个新的协程</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">"%v: Hello World!\n"</span>, n)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协程的优点：</p>
<ol>
<li>创建成本低。在 go 里每个协程大约只占用 1k 的内存。</li>
<li>调度成本低。协程属于用户态，不需要经过操作系统管理，调度时<strong>不需要陷入内核</strong>。</li>
<li>减少上锁频率。因为协程都是跑在一个线程里的，且都是非抢占式调度，所以不用担心指令执行到一半被夺去运行权限的问题。但是如果协程间存在竞争，并不能保证临界区，所以也不是完全不需要锁。</li>
</ol>
<p>协程的缺点：</p>
<ol>
<li>无法充分利用多核资源，因为所有协程都是属于一个线程的，协程需要和进程配合才能运行在多核 CPU 上</li>
<li>执行线程级的阻塞操作会阻塞掉整个程序</li>
</ol>
<h2 id="进程、线程和协程的调度成本对比"><a href="#进程、线程和协程的调度成本对比" class="headerlink" title="进程、线程和协程的调度成本对比"></a>进程、线程和协程的调度成本对比</h2><p>进程的切换带来以下<strong>直接开销</strong>：</p>
<ul>
<li>陷入内核</li>
<li>切换页表，刷新 TLB</li>
<li>保存寄存器值等硬件上下文</li>
<li>更新 PCB 中的信息（改掉进程的“运行态”），把 PCB 放入相关的状态队列</li>
</ul>
<p>此外还有由于 Cache 大规模失效带来的<strong>间接开销</strong>，即原进程缓存下来的指令和数据统统失效，CPU 需要直接访问内存的频率增加。</p>
<p>与进程相比，线程切换的开销就小了很多，主要体现在省略了切换虚拟地址空间这一步：</p>
<ul>
<li>陷入内核</li>
<li>保存寄存器值等硬件上下文</li>
<li>更新 TCB 中的信息（改掉线程的“运行态”），把 TCB 放入相关的状态队列</li>
</ul>
<p>而协程的切换就更轻量级了，它干脆连内核态也不陷入了：</p>
<ul>
<li>保存寄存器值等硬件上下文</li>
<li>更新协程状态（改掉协程的“运行态”），把协程放入相关的状态队列</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/02/也谈进程、线程与协程/" data-id="ckoqt9nuo0015b0up7rrphc0v" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-开始你的Go-Module之路" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/02/21/开始你的Go-Module之路/">开始你的Go Module之路</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/21/开始你的Go-Module之路/" class="article-date">
  <time datetime="2020-02-21T15:07:01.000Z" itemprop="datePublished">2020-02-21</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/语言/">语言</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>在 go 的历史上出现过一大批包管理工具，如 dep，vendor 等。自 go1.12 以来官方引入了 go module 来解决这个乱象。</p>
<h1 id="从-GOPATH-说起"><a href="#从-GOPATH-说起" class="headerlink" title="从 GOPATH 说起"></a>从 GOPATH 说起</h1><p>GOPATH 是最早的 go 包管理方案，安装 golang 之后需要配置两个环境变量 <code>GOROOT</code> 与 <code>GOPATH</code>, 前者是 go 安装目录，后者是开发者自定义的用于存放代码的地方。GOPATH 下存在三个目录：</p>
<ul>
<li>bin: 存放编译后的可执行文件</li>
<li>pkg: 存放 go 的链接文件(suffix = .a)</li>
<li>src: 存放源代码</li>
</ul>
<p>平时我们的项目就放在 src 下，每个项目一个文件夹。每当我们用 import 语句导入包，go 会从 <code>$GOROOT/src</code> 和 <code>$GOPATH/src</code> 查找匹配的目录。举个栗子，假设我的 GOPATH 是 E:\go，在 src 下创建一个项目 service，里面有个 main.go 文件和 test 包：</p>
<p><img src="https://i.loli.net/2020/02/21/B9VCsnjychDQTJ4.png" alt="service"></p>
<p>main.go 文件内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/ramya-rao-a/go-outline"</span></span><br><span class="line">    <span class="string">"./test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>fmt 是 go 自带的包，位于 $GOROOT/src/fmt；github.com/ramya-rao-a/go-outline 是第三方包，位于 $GOPATH/src/github.com/ramya-rao-a/go-outline；test 是自定义包，<code>.</code> 表示 mian.go 所在文件夹，位于 $GOPATH/src/service/test</p>
<h1 id="升级，Go-module！"><a href="#升级，Go-module！" class="headerlink" title="升级，Go module！"></a>升级，Go module！</h1><p>讲了一大堆，是时候进入正题了。前面讲利用 GOPATH 进行包管理这个方法是在是太麻烦了，每个项目都要配一个专属的 GOPATH，不然各个项目的包就会混在一起。</p>
<p>go1.12 后，设置环境变量 <code>GO111MODULE=on</code>，每个软件包都可以声明为一个 module。每个 module 的依赖包都会放在 $GOPATH/pkg/mod 下。如果没有设置 GOPATH 也没关系，go 会在用户的 $home 目录下创建一个 go 文件夹作为默认的 GOPATH</p>
<h2 id="声明-module"><a href="#声明-module" class="headerlink" title="声明 module"></a>声明 module</h2><p>modulename 是任意的。如果想把这个包发布出去，最好还是按 github.com/user/xxxx 的形式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init &lt;modulename&gt;</span><br></pre></td></tr></table></figure>
<p>举个栗子，还是那个 service 项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init github.com/yue-qiu/service</span><br></pre></td></tr></table></figure>
<p>现在，在这个项目里，github.com/yue-qiu/service 就是这个项目的根目录。main.go 改写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/ramya-rao-a/go-outline"</span></span><br><span class="line">    <span class="string">"github.com/yue-qiu/service/test"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// your code</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>go mod 命令提供了一系列与 module 相关的用法：</p>
<p><img src="https://i.loli.net/2020/02/22/qk9bN2IMT48OSza.png" alt="module"></p>
<ul>
<li>go mod download: 根据 go.mod 中的内容拉取依赖包到本地</li>
<li>go mod tidy: 根据项目的导入信息往 go.mod 中添加、删除依赖包记录。建议少用，因为它会自动把所有依赖包升级到最新版本</li>
<li>go mod graph: 打印项目的依赖关系图</li>
<li>go mod vendor: 将 go.mod 中记录的依赖包缓存到一个 vendor 目录，这样在没网的情况下也能编译项目了</li>
<li>go mod edit [flag]: [flag] 又分好几种：<ul>
<li>fmt: 格式化 go.mod</li>
<li>require=path@version or droprequire=path@version: 添加依赖 or 删除依赖</li>
<li>replace=oldpath=newpath or droprequire=oldpath: 替换依赖</li>
</ul>
</li>
</ul>
<p>这里重点说下 -replace 选项，因为在生产中经常遇到的一种情况是由于这样那样的原因我们需要 fork 一个私有仓库去改动第三方开源库，例如有个小哥针对 logrus 做了二次开发 github.com/gogap/logrus，这个时候就需要用 github.com/gogap/logrus 替换之前的第三方开源库 github.com/sirupsen/logrus，操作如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go mod edit -replace=<span class="string">"github.com/sirupsen/logrus=github.com/gogap/logrus@v0.8.2"</span></span><br><span class="line"></span><br><span class="line">$ cat go.mod</span><br><span class="line"></span><br><span class="line">module <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require github.com/sirupsen/logrus v1.4.2</span><br><span class="line"></span><br><span class="line">replace github.com/sirupsen/logrus =&gt; github.com/gogap/logrus v0.8.2</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/21/开始你的Go-Module之路/" data-id="ckoqt9nt6000nb0upl6pn6s5h" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-回车-or-换行？" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/02/16/回车-or-换行？/">回车 or 换行？</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/16/回车-or-换行？/" class="article-date">
  <time datetime="2020-02-16T12:23:01.000Z" itemprop="datePublished">2020-02-16</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机系统/">计算机系统</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <p>以前编程的时候一直没注意回车符与换行符的区别，只是大概知道一个是 \r 一个是 \n。今天心血来潮查了一下，发现这还蛮有趣的~</p>
<h1 id="回车-CR"><a href="#回车-CR" class="headerlink" title="回车 CR"></a>回车 CR</h1><p>原名 Carriage Return，ASCII 码 13。表示光标回到行首。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello\rworld"</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>
<h1 id="换行-LF"><a href="#换行-LF" class="headerlink" title="换行 LF"></a>换行 LF</h1><p>原名 Line Feed，ASCII 码 10。表示光标移动到下一行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"hello\nworld"</span>)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment">#   hello</span></span><br><span class="line"><span class="comment">#   world</span></span><br></pre></td></tr></table></figure>
<h1 id="渊源"><a href="#渊源" class="headerlink" title="渊源"></a>渊源</h1><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。但是它有一个问题，就是打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p><img src="https://i.loli.net/2020/02/16/kMxhL2pTCwBZASi.png" alt="打字机"></p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。至于为什么回车在前换行在后呢？因为回车需要的时间更长，机器可以利用这个间隙完成换行操作。</p>
<p>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了。于是，就出现了分歧：</p>
<ul>
<li>\r\n: Windows 系统行末结束符</li>
<li>\r: Mac 系统行末结束符</li>
<li>\n: Unix 系统行末结束符</li>
</ul>
<p>一个直接后果是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。</p>
<p>总结：虽然不同操作系统对行末结束符的定义不同，但 \r\n 是历史传统而且被多个标准（如 HTTP，SMTP）所采纳，所以实际使用中还是以 \r\n 居多。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/16/回车-or-换行？/" data-id="ckoqt9nt3000kb0up6rnhuop6" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
    <article id="post-URI与URL" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h2 itemprop="name">
  <a class="article-title" href="/2020/02/13/URI与URL/">网络那些事之URI</a>
</h2>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/13/URI与URL/" class="article-date">
  <time datetime="2020-02-13T01:29:36.000Z" itemprop="datePublished">2020-02-13</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>

    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="什么是-URI"><a href="#什么是-URI" class="headerlink" title="什么是 URI"></a>什么是 URI</h1><p>URI(Uniform Resource Identifier)：统一资源标识符，用于<strong>唯一标识一个资源</strong>。</p>
<p>URL(Uniform Resource Locator)：统一资源定位符，表明在一个资源在网络中的访问方式。通常表现为 <code>协议+路径+参数</code></p>
<p>URN(Uniform Resource Name)：统一资源定位名称，通过某个命名空间中的唯一 ID 来标识一个资源</p>
<p><img src="https://i.loli.net/2020/02/13/2XjAU6Phz9ONJQq.png" alt="URI"></p>
<p>举个例子：小红的学号是 123456，这个学号就是 URN，能对应到小红这个人；小红的家庭住址是翻斗大街翻斗花园二号楼一零零一室，这个地址就是 URL，去那里就能找到小红。小红的学号、小红的住址都属于 URI。</p>
<h1 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h1><p>一个标准的 URI 格式为：<code>[scheme:]scheme-specific-part</code>，如：<a href="http://qiuyueqy.com" target="_blank" rel="noopener">http://qiuyueqy.com</a>, mailto:<a href="mailto:qiuyue9971@126.com" target="_blank" rel="noopener">qiuyue9971@126.com</a>, news:comp.go.lang</p>
<p>URI 可以细分为为<code>不透明的(opaque)</code>和<code>分层的(hierarchical)</code>两类：</p>
<ul>
<li>opaque 指 scheme-specific-part 不以 / 开头，是一个整体。呈 [scheme]:opaque[?query][#fragment] 的形式。如：mailto:<a href="mailto:qiuyue9971@126.com" target="_blank" rel="noopener">qiuyue9971@126.com</a>，<a href="http://www.google.com:443" target="_blank" rel="noopener">www.google.com:443</a>, opaque 必须是绝对的。</li>
<li>hierarchical 指 scheme-specific-part 以 / 开头且可以划分为好几部分。呈 [scheme:][//[userinfo@]host[:port]]path[?query][#fragment] 的形式。如：<a href="http://qiuyueqy.com/categories/" target="_blank" rel="noopener">http://qiuyueqy.com/categories/</a>, hierarchical 可以是绝对的，也可以是相对的，如：<a href="https://github.com/yue-qiu/CUG_EmptyClassroom" target="_blank" rel="noopener">https://github.com/yue-qiu/CUG_EmptyClassroom</a>, ../../static/verify.js</li>
</ul>
<h1 id="谈谈-URI-编码"><a href="#谈谈-URI-编码" class="headerlink" title="谈谈 URI 编码"></a>谈谈 URI 编码</h1><p>利用 URI 传参时，如果某些 URI 组件字符（如 /:?@&amp;=+$,#）同时也是参数的一部分会导致 URI 歧义。此外，URI 只支持 ASCII 编码，对于茫茫多的特殊字符（如：广东省）如何表示？</p>
<p>所谓办法总比困难多，为了解决这些问题，URI 编码应运而生。举个栗子，对下面这个未经编码的 URI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>
<p>要表示特殊字符，我们把它按某个字符集（通常是 UTF-8）编码成十六进制的 %hh 形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://qiuyueqy.com?page=2&amp;category=%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>
<p>如果这个 URI 是另一个 URI 的参数，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpw://www.google.com?callback=http://qiuyueqy.com/?page=2&amp;category=广东</span><br></pre></td></tr></table></figure>
<p>显然，由于参数中 /、? 等组件字符的存在，上面这个 URI 的解释是有歧义的。这时，我们把整个回调 URI（包括它的组件字符）进行编码，再作为参数就没问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpw://www.google.com?callback=http%3A%2F%2Fqiuyueqy.com%2F%3Fpage%3D2%26category%3D%E5%B9%BF%E4%B8%9C</span><br></pre></td></tr></table></figure>
<h1 id="golang-对-URL-的实现"><a href="#golang-对-URL-的实现" class="headerlink" title="golang 对 URL 的实现"></a>golang 对 URL 的实现</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> URL <span class="keyword">struct</span> &#123;</span><br><span class="line">    Scheme   <span class="keyword">string</span>    <span class="comment">//具体指访问服务器上的资源使用的哪种协议</span></span><br><span class="line">    Opaque   <span class="keyword">string</span>    <span class="comment">// 编码后的不透明数据</span></span><br><span class="line">    User     *Userinfo <span class="comment">// 用户名和密码信息,有些协议需要传入明文用户名和密码来获取资源，比如 FTP</span></span><br><span class="line">    Host     <span class="keyword">string</span>    <span class="comment">// host或host:port，服务器地址，可以是 IP 地址，也可以是域名信息</span></span><br><span class="line">    Path     <span class="keyword">string</span>  <span class="comment">//路径，使用"/"分隔</span></span><br><span class="line">    RawQuery <span class="keyword">string</span> <span class="comment">// 编码后的查询字符串，没有'?'</span></span><br><span class="line">    Fragment <span class="keyword">string</span> <span class="comment">// 引用的片段（文档位置），没有'#'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/13/URI与URL/" data-id="ckoqt9nsh0008b0up0xqas72e" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/应用层/">应用层</a></li></ul>

    </footer>

  </div>

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>精神的壳 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="精神的壳"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>


<script src="/js/copybtn.js"></script>




<script src="/js/ocean.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>